// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/sut63/team17/app/ent/activity"
	"github.com/sut63/team17/app/ent/agency"
	"github.com/sut63/team17/app/ent/course"
	"github.com/sut63/team17/app/ent/degree"
	"github.com/sut63/team17/app/ent/district"
	"github.com/sut63/team17/app/ent/faculty"
	"github.com/sut63/team17/app/ent/gender"
	"github.com/sut63/team17/app/ent/institution"
	"github.com/sut63/team17/app/ent/place"
	"github.com/sut63/team17/app/ent/postal"
	"github.com/sut63/team17/app/ent/prefix"
	"github.com/sut63/team17/app/ent/professor"
	"github.com/sut63/team17/app/ent/professorship"
	"github.com/sut63/team17/app/ent/province"
	"github.com/sut63/team17/app/ent/region"
	"github.com/sut63/team17/app/ent/results"
	"github.com/sut63/team17/app/ent/student"
	"github.com/sut63/team17/app/ent/subdistrict"
	"github.com/sut63/team17/app/ent/subject"
	"github.com/sut63/team17/app/ent/term"
	"github.com/sut63/team17/app/ent/year"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity      = "Activity"
	TypeAgency        = "Agency"
	TypeCourse        = "Course"
	TypeDegree        = "Degree"
	TypeDistrict      = "District"
	TypeFaculty       = "Faculty"
	TypeGender        = "Gender"
	TypeInstitution   = "Institution"
	TypePlace         = "Place"
	TypePostal        = "Postal"
	TypePrefix        = "Prefix"
	TypeProfessor     = "Professor"
	TypeProfessorship = "Professorship"
	TypeProvince      = "Province"
	TypeRegion        = "Region"
	TypeResults       = "Results"
	TypeStudent       = "Student"
	TypeSubdistrict   = "Subdistrict"
	TypeSubject       = "Subject"
	TypeTerm          = "Term"
	TypeYear          = "Year"
)

// ActivityMutation represents an operation that mutate the Activities
// nodes in the graph.
type ActivityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_ACTIVITYNAME     *string
	_ADDED            *time.Time
	_HOURS            *int
	add_HOURS         *int
	clearedFields     map[string]struct{}
	acti_stud         *int
	clearedacti_stud  bool
	acti_place        *int
	clearedacti_place bool
	acti_agen         *int
	clearedacti_agen  bool
	acti_year         *int
	clearedacti_year  bool
	done              bool
	oldValue          func(context.Context) (*Activity, error)
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows to manage the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for $n.Name.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the id field of the mutation.
func withActivityID(id int) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetACTIVITYNAME sets the ACTIVITYNAME field.
func (m *ActivityMutation) SetACTIVITYNAME(s string) {
	m._ACTIVITYNAME = &s
}

// ACTIVITYNAME returns the ACTIVITYNAME value in the mutation.
func (m *ActivityMutation) ACTIVITYNAME() (r string, exists bool) {
	v := m._ACTIVITYNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldACTIVITYNAME returns the old ACTIVITYNAME value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldACTIVITYNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldACTIVITYNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldACTIVITYNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldACTIVITYNAME: %w", err)
	}
	return oldValue.ACTIVITYNAME, nil
}

// ResetACTIVITYNAME reset all changes of the "ACTIVITYNAME" field.
func (m *ActivityMutation) ResetACTIVITYNAME() {
	m._ACTIVITYNAME = nil
}

// SetADDED sets the ADDED field.
func (m *ActivityMutation) SetADDED(t time.Time) {
	m._ADDED = &t
}

// ADDED returns the ADDED value in the mutation.
func (m *ActivityMutation) ADDED() (r time.Time, exists bool) {
	v := m._ADDED
	if v == nil {
		return
	}
	return *v, true
}

// OldADDED returns the old ADDED value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldADDED(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldADDED is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldADDED requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldADDED: %w", err)
	}
	return oldValue.ADDED, nil
}

// ResetADDED reset all changes of the "ADDED" field.
func (m *ActivityMutation) ResetADDED() {
	m._ADDED = nil
}

// SetHOURS sets the HOURS field.
func (m *ActivityMutation) SetHOURS(i int) {
	m._HOURS = &i
	m.add_HOURS = nil
}

// HOURS returns the HOURS value in the mutation.
func (m *ActivityMutation) HOURS() (r int, exists bool) {
	v := m._HOURS
	if v == nil {
		return
	}
	return *v, true
}

// OldHOURS returns the old HOURS value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldHOURS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHOURS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHOURS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHOURS: %w", err)
	}
	return oldValue.HOURS, nil
}

// AddHOURS adds i to HOURS.
func (m *ActivityMutation) AddHOURS(i int) {
	if m.add_HOURS != nil {
		*m.add_HOURS += i
	} else {
		m.add_HOURS = &i
	}
}

// AddedHOURS returns the value that was added to the HOURS field in this mutation.
func (m *ActivityMutation) AddedHOURS() (r int, exists bool) {
	v := m.add_HOURS
	if v == nil {
		return
	}
	return *v, true
}

// ResetHOURS reset all changes of the "HOURS" field.
func (m *ActivityMutation) ResetHOURS() {
	m._HOURS = nil
	m.add_HOURS = nil
}

// SetActiStudID sets the acti_stud edge to Student by id.
func (m *ActivityMutation) SetActiStudID(id int) {
	m.acti_stud = &id
}

// ClearActiStud clears the acti_stud edge to Student.
func (m *ActivityMutation) ClearActiStud() {
	m.clearedacti_stud = true
}

// ActiStudCleared returns if the edge acti_stud was cleared.
func (m *ActivityMutation) ActiStudCleared() bool {
	return m.clearedacti_stud
}

// ActiStudID returns the acti_stud id in the mutation.
func (m *ActivityMutation) ActiStudID() (id int, exists bool) {
	if m.acti_stud != nil {
		return *m.acti_stud, true
	}
	return
}

// ActiStudIDs returns the acti_stud ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiStudID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiStudIDs() (ids []int) {
	if id := m.acti_stud; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiStud reset all changes of the "acti_stud" edge.
func (m *ActivityMutation) ResetActiStud() {
	m.acti_stud = nil
	m.clearedacti_stud = false
}

// SetActiPlaceID sets the acti_place edge to Place by id.
func (m *ActivityMutation) SetActiPlaceID(id int) {
	m.acti_place = &id
}

// ClearActiPlace clears the acti_place edge to Place.
func (m *ActivityMutation) ClearActiPlace() {
	m.clearedacti_place = true
}

// ActiPlaceCleared returns if the edge acti_place was cleared.
func (m *ActivityMutation) ActiPlaceCleared() bool {
	return m.clearedacti_place
}

// ActiPlaceID returns the acti_place id in the mutation.
func (m *ActivityMutation) ActiPlaceID() (id int, exists bool) {
	if m.acti_place != nil {
		return *m.acti_place, true
	}
	return
}

// ActiPlaceIDs returns the acti_place ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiPlaceID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiPlaceIDs() (ids []int) {
	if id := m.acti_place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiPlace reset all changes of the "acti_place" edge.
func (m *ActivityMutation) ResetActiPlace() {
	m.acti_place = nil
	m.clearedacti_place = false
}

// SetActiAgenID sets the acti_agen edge to Agency by id.
func (m *ActivityMutation) SetActiAgenID(id int) {
	m.acti_agen = &id
}

// ClearActiAgen clears the acti_agen edge to Agency.
func (m *ActivityMutation) ClearActiAgen() {
	m.clearedacti_agen = true
}

// ActiAgenCleared returns if the edge acti_agen was cleared.
func (m *ActivityMutation) ActiAgenCleared() bool {
	return m.clearedacti_agen
}

// ActiAgenID returns the acti_agen id in the mutation.
func (m *ActivityMutation) ActiAgenID() (id int, exists bool) {
	if m.acti_agen != nil {
		return *m.acti_agen, true
	}
	return
}

// ActiAgenIDs returns the acti_agen ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiAgenID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiAgenIDs() (ids []int) {
	if id := m.acti_agen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiAgen reset all changes of the "acti_agen" edge.
func (m *ActivityMutation) ResetActiAgen() {
	m.acti_agen = nil
	m.clearedacti_agen = false
}

// SetActiYearID sets the acti_year edge to Year by id.
func (m *ActivityMutation) SetActiYearID(id int) {
	m.acti_year = &id
}

// ClearActiYear clears the acti_year edge to Year.
func (m *ActivityMutation) ClearActiYear() {
	m.clearedacti_year = true
}

// ActiYearCleared returns if the edge acti_year was cleared.
func (m *ActivityMutation) ActiYearCleared() bool {
	return m.clearedacti_year
}

// ActiYearID returns the acti_year id in the mutation.
func (m *ActivityMutation) ActiYearID() (id int, exists bool) {
	if m.acti_year != nil {
		return *m.acti_year, true
	}
	return
}

// ActiYearIDs returns the acti_year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiYearID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiYearIDs() (ids []int) {
	if id := m.acti_year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiYear reset all changes of the "acti_year" edge.
func (m *ActivityMutation) ResetActiYear() {
	m.acti_year = nil
	m.clearedacti_year = false
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._ACTIVITYNAME != nil {
		fields = append(fields, activity.FieldACTIVITYNAME)
	}
	if m._ADDED != nil {
		fields = append(fields, activity.FieldADDED)
	}
	if m._HOURS != nil {
		fields = append(fields, activity.FieldHOURS)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldACTIVITYNAME:
		return m.ACTIVITYNAME()
	case activity.FieldADDED:
		return m.ADDED()
	case activity.FieldHOURS:
		return m.HOURS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldACTIVITYNAME:
		return m.OldACTIVITYNAME(ctx)
	case activity.FieldADDED:
		return m.OldADDED(ctx)
	case activity.FieldHOURS:
		return m.OldHOURS(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldACTIVITYNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetACTIVITYNAME(v)
		return nil
	case activity.FieldADDED:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetADDED(v)
		return nil
	case activity.FieldHOURS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHOURS(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.add_HOURS != nil {
		fields = append(fields, activity.FieldHOURS)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldHOURS:
		return m.AddedHOURS()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldHOURS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHOURS(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldACTIVITYNAME:
		m.ResetACTIVITYNAME()
		return nil
	case activity.FieldADDED:
		m.ResetADDED()
		return nil
	case activity.FieldHOURS:
		m.ResetHOURS()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.acti_stud != nil {
		edges = append(edges, activity.EdgeActiStud)
	}
	if m.acti_place != nil {
		edges = append(edges, activity.EdgeActiPlace)
	}
	if m.acti_agen != nil {
		edges = append(edges, activity.EdgeActiAgen)
	}
	if m.acti_year != nil {
		edges = append(edges, activity.EdgeActiYear)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeActiStud:
		if id := m.acti_stud; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiPlace:
		if id := m.acti_place; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiAgen:
		if id := m.acti_agen; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiYear:
		if id := m.acti_year; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedacti_stud {
		edges = append(edges, activity.EdgeActiStud)
	}
	if m.clearedacti_place {
		edges = append(edges, activity.EdgeActiPlace)
	}
	if m.clearedacti_agen {
		edges = append(edges, activity.EdgeActiAgen)
	}
	if m.clearedacti_year {
		edges = append(edges, activity.EdgeActiYear)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeActiStud:
		return m.clearedacti_stud
	case activity.EdgeActiPlace:
		return m.clearedacti_place
	case activity.EdgeActiAgen:
		return m.clearedacti_agen
	case activity.EdgeActiYear:
		return m.clearedacti_year
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeActiStud:
		m.ClearActiStud()
		return nil
	case activity.EdgeActiPlace:
		m.ClearActiPlace()
		return nil
	case activity.EdgeActiAgen:
		m.ClearActiAgen()
		return nil
	case activity.EdgeActiYear:
		m.ClearActiYear()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeActiStud:
		m.ResetActiStud()
		return nil
	case activity.EdgeActiPlace:
		m.ResetActiPlace()
		return nil
	case activity.EdgeActiAgen:
		m.ResetActiAgen()
		return nil
	case activity.EdgeActiYear:
		m.ResetActiYear()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// AgencyMutation represents an operation that mutate the Agencies
// nodes in the graph.
type AgencyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_AGENCY          *string
	clearedFields    map[string]struct{}
	agen_acti        map[int]struct{}
	removedagen_acti map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Agency, error)
}

var _ ent.Mutation = (*AgencyMutation)(nil)

// agencyOption allows to manage the mutation configuration using functional options.
type agencyOption func(*AgencyMutation)

// newAgencyMutation creates new mutation for $n.Name.
func newAgencyMutation(c config, op Op, opts ...agencyOption) *AgencyMutation {
	m := &AgencyMutation{
		config:        c,
		op:            op,
		typ:           TypeAgency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgencyID sets the id field of the mutation.
func withAgencyID(id int) agencyOption {
	return func(m *AgencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Agency
		)
		m.oldValue = func(ctx context.Context) (*Agency, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgency sets the old Agency of the mutation.
func withAgency(node *Agency) agencyOption {
	return func(m *AgencyMutation) {
		m.oldValue = func(context.Context) (*Agency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AgencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAGENCY sets the AGENCY field.
func (m *AgencyMutation) SetAGENCY(s string) {
	m._AGENCY = &s
}

// AGENCY returns the AGENCY value in the mutation.
func (m *AgencyMutation) AGENCY() (r string, exists bool) {
	v := m._AGENCY
	if v == nil {
		return
	}
	return *v, true
}

// OldAGENCY returns the old AGENCY value of the Agency.
// If the Agency object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AgencyMutation) OldAGENCY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAGENCY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAGENCY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAGENCY: %w", err)
	}
	return oldValue.AGENCY, nil
}

// ResetAGENCY reset all changes of the "AGENCY" field.
func (m *AgencyMutation) ResetAGENCY() {
	m._AGENCY = nil
}

// AddAgenActiIDs adds the agen_acti edge to Activity by ids.
func (m *AgencyMutation) AddAgenActiIDs(ids ...int) {
	if m.agen_acti == nil {
		m.agen_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.agen_acti[ids[i]] = struct{}{}
	}
}

// RemoveAgenActiIDs removes the agen_acti edge to Activity by ids.
func (m *AgencyMutation) RemoveAgenActiIDs(ids ...int) {
	if m.removedagen_acti == nil {
		m.removedagen_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedagen_acti[ids[i]] = struct{}{}
	}
}

// RemovedAgenActi returns the removed ids of agen_acti.
func (m *AgencyMutation) RemovedAgenActiIDs() (ids []int) {
	for id := range m.removedagen_acti {
		ids = append(ids, id)
	}
	return
}

// AgenActiIDs returns the agen_acti ids in the mutation.
func (m *AgencyMutation) AgenActiIDs() (ids []int) {
	for id := range m.agen_acti {
		ids = append(ids, id)
	}
	return
}

// ResetAgenActi reset all changes of the "agen_acti" edge.
func (m *AgencyMutation) ResetAgenActi() {
	m.agen_acti = nil
	m.removedagen_acti = nil
}

// Op returns the operation name.
func (m *AgencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agency).
func (m *AgencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AgencyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AGENCY != nil {
		fields = append(fields, agency.FieldAGENCY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AgencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agency.FieldAGENCY:
		return m.AGENCY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AgencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agency.FieldAGENCY:
		return m.OldAGENCY(ctx)
	}
	return nil, fmt.Errorf("unknown Agency field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agency.FieldAGENCY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAGENCY(v)
		return nil
	}
	return fmt.Errorf("unknown Agency field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AgencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AgencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AgencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AgencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agency nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AgencyMutation) ResetField(name string) error {
	switch name {
	case agency.FieldAGENCY:
		m.ResetAGENCY()
		return nil
	}
	return fmt.Errorf("unknown Agency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AgencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agen_acti != nil {
		edges = append(edges, agency.EdgeAgenActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AgencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agency.EdgeAgenActi:
		ids := make([]ent.Value, 0, len(m.agen_acti))
		for id := range m.agen_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AgencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedagen_acti != nil {
		edges = append(edges, agency.EdgeAgenActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AgencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agency.EdgeAgenActi:
		ids := make([]ent.Value, 0, len(m.removedagen_acti))
		for id := range m.removedagen_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AgencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AgencyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AgencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Agency unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AgencyMutation) ResetEdge(name string) error {
	switch name {
	case agency.EdgeAgenActi:
		m.ResetAgenActi()
		return nil
	}
	return fmt.Errorf("unknown Agency edge %s", name)
}

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	course           *string
	clearedFields    map[string]struct{}
	cour_facu        *int
	clearedcour_facu bool
	cour_degr        *int
	clearedcour_degr bool
	cour_inst        *int
	clearedcour_inst bool
	done             bool
	oldValue         func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourse sets the course field.
func (m *CourseMutation) SetCourse(s string) {
	m.course = &s
}

// Course returns the course value in the mutation.
func (m *CourseMutation) Course() (r string, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourse returns the old course value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCourse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourse: %w", err)
	}
	return oldValue.Course, nil
}

// ResetCourse reset all changes of the "course" field.
func (m *CourseMutation) ResetCourse() {
	m.course = nil
}

// SetCourFacuID sets the cour_facu edge to Faculty by id.
func (m *CourseMutation) SetCourFacuID(id int) {
	m.cour_facu = &id
}

// ClearCourFacu clears the cour_facu edge to Faculty.
func (m *CourseMutation) ClearCourFacu() {
	m.clearedcour_facu = true
}

// CourFacuCleared returns if the edge cour_facu was cleared.
func (m *CourseMutation) CourFacuCleared() bool {
	return m.clearedcour_facu
}

// CourFacuID returns the cour_facu id in the mutation.
func (m *CourseMutation) CourFacuID() (id int, exists bool) {
	if m.cour_facu != nil {
		return *m.cour_facu, true
	}
	return
}

// CourFacuIDs returns the cour_facu ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourFacuID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourFacuIDs() (ids []int) {
	if id := m.cour_facu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourFacu reset all changes of the "cour_facu" edge.
func (m *CourseMutation) ResetCourFacu() {
	m.cour_facu = nil
	m.clearedcour_facu = false
}

// SetCourDegrID sets the cour_degr edge to Degree by id.
func (m *CourseMutation) SetCourDegrID(id int) {
	m.cour_degr = &id
}

// ClearCourDegr clears the cour_degr edge to Degree.
func (m *CourseMutation) ClearCourDegr() {
	m.clearedcour_degr = true
}

// CourDegrCleared returns if the edge cour_degr was cleared.
func (m *CourseMutation) CourDegrCleared() bool {
	return m.clearedcour_degr
}

// CourDegrID returns the cour_degr id in the mutation.
func (m *CourseMutation) CourDegrID() (id int, exists bool) {
	if m.cour_degr != nil {
		return *m.cour_degr, true
	}
	return
}

// CourDegrIDs returns the cour_degr ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourDegrID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourDegrIDs() (ids []int) {
	if id := m.cour_degr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourDegr reset all changes of the "cour_degr" edge.
func (m *CourseMutation) ResetCourDegr() {
	m.cour_degr = nil
	m.clearedcour_degr = false
}

// SetCourInstID sets the cour_inst edge to Institution by id.
func (m *CourseMutation) SetCourInstID(id int) {
	m.cour_inst = &id
}

// ClearCourInst clears the cour_inst edge to Institution.
func (m *CourseMutation) ClearCourInst() {
	m.clearedcour_inst = true
}

// CourInstCleared returns if the edge cour_inst was cleared.
func (m *CourseMutation) CourInstCleared() bool {
	return m.clearedcour_inst
}

// CourInstID returns the cour_inst id in the mutation.
func (m *CourseMutation) CourInstID() (id int, exists bool) {
	if m.cour_inst != nil {
		return *m.cour_inst, true
	}
	return
}

// CourInstIDs returns the cour_inst ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourInstID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourInstIDs() (ids []int) {
	if id := m.cour_inst; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourInst reset all changes of the "cour_inst" edge.
func (m *CourseMutation) ResetCourInst() {
	m.cour_inst = nil
	m.clearedcour_inst = false
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.course != nil {
		fields = append(fields, course.FieldCourse)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCourse:
		return m.Course()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCourse:
		return m.OldCourse(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCourse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourse(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cour_facu != nil {
		edges = append(edges, course.EdgeCourFacu)
	}
	if m.cour_degr != nil {
		edges = append(edges, course.EdgeCourDegr)
	}
	if m.cour_inst != nil {
		edges = append(edges, course.EdgeCourInst)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourFacu:
		if id := m.cour_facu; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourDegr:
		if id := m.cour_degr; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourInst:
		if id := m.cour_inst; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcour_facu {
		edges = append(edges, course.EdgeCourFacu)
	}
	if m.clearedcour_degr {
		edges = append(edges, course.EdgeCourDegr)
	}
	if m.clearedcour_inst {
		edges = append(edges, course.EdgeCourInst)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeCourFacu:
		return m.clearedcour_facu
	case course.EdgeCourDegr:
		return m.clearedcour_degr
	case course.EdgeCourInst:
		return m.clearedcour_inst
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeCourFacu:
		m.ClearCourFacu()
		return nil
	case course.EdgeCourDegr:
		m.ClearCourDegr()
		return nil
	case course.EdgeCourInst:
		m.ClearCourInst()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeCourFacu:
		m.ResetCourFacu()
		return nil
	case course.EdgeCourDegr:
		m.ResetCourDegr()
		return nil
	case course.EdgeCourInst:
		m.ResetCourInst()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DegreeMutation represents an operation that mutate the Degrees
// nodes in the graph.
type DegreeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	degree           *string
	clearedFields    map[string]struct{}
	degr_stud        map[int]struct{}
	removeddegr_stud map[int]struct{}
	degr_cour        map[int]struct{}
	removeddegr_cour map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Degree, error)
}

var _ ent.Mutation = (*DegreeMutation)(nil)

// degreeOption allows to manage the mutation configuration using functional options.
type degreeOption func(*DegreeMutation)

// newDegreeMutation creates new mutation for $n.Name.
func newDegreeMutation(c config, op Op, opts ...degreeOption) *DegreeMutation {
	m := &DegreeMutation{
		config:        c,
		op:            op,
		typ:           TypeDegree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDegreeID sets the id field of the mutation.
func withDegreeID(id int) degreeOption {
	return func(m *DegreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Degree
		)
		m.oldValue = func(ctx context.Context) (*Degree, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Degree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDegree sets the old Degree of the mutation.
func withDegree(node *Degree) degreeOption {
	return func(m *DegreeMutation) {
		m.oldValue = func(context.Context) (*Degree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DegreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DegreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DegreeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDegree sets the degree field.
func (m *DegreeMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the degree value in the mutation.
func (m *DegreeMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old degree value of the Degree.
// If the Degree object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DegreeMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDegree is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ResetDegree reset all changes of the "degree" field.
func (m *DegreeMutation) ResetDegree() {
	m.degree = nil
}

// AddDegrStudIDs adds the degr_stud edge to Student by ids.
func (m *DegreeMutation) AddDegrStudIDs(ids ...int) {
	if m.degr_stud == nil {
		m.degr_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.degr_stud[ids[i]] = struct{}{}
	}
}

// RemoveDegrStudIDs removes the degr_stud edge to Student by ids.
func (m *DegreeMutation) RemoveDegrStudIDs(ids ...int) {
	if m.removeddegr_stud == nil {
		m.removeddegr_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegr_stud[ids[i]] = struct{}{}
	}
}

// RemovedDegrStud returns the removed ids of degr_stud.
func (m *DegreeMutation) RemovedDegrStudIDs() (ids []int) {
	for id := range m.removeddegr_stud {
		ids = append(ids, id)
	}
	return
}

// DegrStudIDs returns the degr_stud ids in the mutation.
func (m *DegreeMutation) DegrStudIDs() (ids []int) {
	for id := range m.degr_stud {
		ids = append(ids, id)
	}
	return
}

// ResetDegrStud reset all changes of the "degr_stud" edge.
func (m *DegreeMutation) ResetDegrStud() {
	m.degr_stud = nil
	m.removeddegr_stud = nil
}

// AddDegrCourIDs adds the degr_cour edge to Course by ids.
func (m *DegreeMutation) AddDegrCourIDs(ids ...int) {
	if m.degr_cour == nil {
		m.degr_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.degr_cour[ids[i]] = struct{}{}
	}
}

// RemoveDegrCourIDs removes the degr_cour edge to Course by ids.
func (m *DegreeMutation) RemoveDegrCourIDs(ids ...int) {
	if m.removeddegr_cour == nil {
		m.removeddegr_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegr_cour[ids[i]] = struct{}{}
	}
}

// RemovedDegrCour returns the removed ids of degr_cour.
func (m *DegreeMutation) RemovedDegrCourIDs() (ids []int) {
	for id := range m.removeddegr_cour {
		ids = append(ids, id)
	}
	return
}

// DegrCourIDs returns the degr_cour ids in the mutation.
func (m *DegreeMutation) DegrCourIDs() (ids []int) {
	for id := range m.degr_cour {
		ids = append(ids, id)
	}
	return
}

// ResetDegrCour reset all changes of the "degr_cour" edge.
func (m *DegreeMutation) ResetDegrCour() {
	m.degr_cour = nil
	m.removeddegr_cour = nil
}

// Op returns the operation name.
func (m *DegreeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Degree).
func (m *DegreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DegreeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.degree != nil {
		fields = append(fields, degree.FieldDegree)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DegreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case degree.FieldDegree:
		return m.Degree()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DegreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case degree.FieldDegree:
		return m.OldDegree(ctx)
	}
	return nil, fmt.Errorf("unknown Degree field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case degree.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DegreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DegreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DegreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DegreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DegreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Degree nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DegreeMutation) ResetField(name string) error {
	switch name {
	case degree.FieldDegree:
		m.ResetDegree()
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DegreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.degr_stud != nil {
		edges = append(edges, degree.EdgeDegrStud)
	}
	if m.degr_cour != nil {
		edges = append(edges, degree.EdgeDegrCour)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DegreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegrStud:
		ids := make([]ent.Value, 0, len(m.degr_stud))
		for id := range m.degr_stud {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeDegrCour:
		ids := make([]ent.Value, 0, len(m.degr_cour))
		for id := range m.degr_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DegreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddegr_stud != nil {
		edges = append(edges, degree.EdgeDegrStud)
	}
	if m.removeddegr_cour != nil {
		edges = append(edges, degree.EdgeDegrCour)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DegreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegrStud:
		ids := make([]ent.Value, 0, len(m.removeddegr_stud))
		for id := range m.removeddegr_stud {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeDegrCour:
		ids := make([]ent.Value, 0, len(m.removeddegr_cour))
		for id := range m.removeddegr_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DegreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DegreeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DegreeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DegreeMutation) ResetEdge(name string) error {
	switch name {
	case degree.EdgeDegrStud:
		m.ResetDegrStud()
		return nil
	case degree.EdgeDegrCour:
		m.ResetDegrCour()
		return nil
	}
	return fmt.Errorf("unknown Degree edge %s", name)
}

// DistrictMutation represents an operation that mutate the Districts
// nodes in the graph.
type DistrictMutation struct {
	config
	op               Op
	typ              string
	id               *int
	district         *string
	clearedFields    map[string]struct{}
	dist_subd        *int
	cleareddist_subd bool
	dist_post        *int
	cleareddist_post bool
	dist_prov        map[int]struct{}
	removeddist_prov map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*District, error)
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows to manage the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for $n.Name.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the id field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDistrict sets the district field.
func (m *DistrictMutation) SetDistrict(s string) {
	m.district = &s
}

// District returns the district value in the mutation.
func (m *DistrictMutation) District() (r string, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old district value of the District.
// If the District object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DistrictMutation) OldDistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrict is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ResetDistrict reset all changes of the "district" field.
func (m *DistrictMutation) ResetDistrict() {
	m.district = nil
}

// SetDistSubdID sets the dist_subd edge to Subdistrict by id.
func (m *DistrictMutation) SetDistSubdID(id int) {
	m.dist_subd = &id
}

// ClearDistSubd clears the dist_subd edge to Subdistrict.
func (m *DistrictMutation) ClearDistSubd() {
	m.cleareddist_subd = true
}

// DistSubdCleared returns if the edge dist_subd was cleared.
func (m *DistrictMutation) DistSubdCleared() bool {
	return m.cleareddist_subd
}

// DistSubdID returns the dist_subd id in the mutation.
func (m *DistrictMutation) DistSubdID() (id int, exists bool) {
	if m.dist_subd != nil {
		return *m.dist_subd, true
	}
	return
}

// DistSubdIDs returns the dist_subd ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DistSubdID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) DistSubdIDs() (ids []int) {
	if id := m.dist_subd; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistSubd reset all changes of the "dist_subd" edge.
func (m *DistrictMutation) ResetDistSubd() {
	m.dist_subd = nil
	m.cleareddist_subd = false
}

// SetDistPostID sets the dist_post edge to Postal by id.
func (m *DistrictMutation) SetDistPostID(id int) {
	m.dist_post = &id
}

// ClearDistPost clears the dist_post edge to Postal.
func (m *DistrictMutation) ClearDistPost() {
	m.cleareddist_post = true
}

// DistPostCleared returns if the edge dist_post was cleared.
func (m *DistrictMutation) DistPostCleared() bool {
	return m.cleareddist_post
}

// DistPostID returns the dist_post id in the mutation.
func (m *DistrictMutation) DistPostID() (id int, exists bool) {
	if m.dist_post != nil {
		return *m.dist_post, true
	}
	return
}

// DistPostIDs returns the dist_post ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DistPostID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) DistPostIDs() (ids []int) {
	if id := m.dist_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistPost reset all changes of the "dist_post" edge.
func (m *DistrictMutation) ResetDistPost() {
	m.dist_post = nil
	m.cleareddist_post = false
}

// AddDistProvIDs adds the dist_prov edge to Province by ids.
func (m *DistrictMutation) AddDistProvIDs(ids ...int) {
	if m.dist_prov == nil {
		m.dist_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.dist_prov[ids[i]] = struct{}{}
	}
}

// RemoveDistProvIDs removes the dist_prov edge to Province by ids.
func (m *DistrictMutation) RemoveDistProvIDs(ids ...int) {
	if m.removeddist_prov == nil {
		m.removeddist_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddist_prov[ids[i]] = struct{}{}
	}
}

// RemovedDistProv returns the removed ids of dist_prov.
func (m *DistrictMutation) RemovedDistProvIDs() (ids []int) {
	for id := range m.removeddist_prov {
		ids = append(ids, id)
	}
	return
}

// DistProvIDs returns the dist_prov ids in the mutation.
func (m *DistrictMutation) DistProvIDs() (ids []int) {
	for id := range m.dist_prov {
		ids = append(ids, id)
	}
	return
}

// ResetDistProv reset all changes of the "dist_prov" edge.
func (m *DistrictMutation) ResetDistProv() {
	m.dist_prov = nil
	m.removeddist_prov = nil
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.district != nil {
		fields = append(fields, district.FieldDistrict)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldDistrict:
		return m.District()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldDistrict:
		return m.OldDistrict(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dist_subd != nil {
		edges = append(edges, district.EdgeDistSubd)
	}
	if m.dist_post != nil {
		edges = append(edges, district.EdgeDistPost)
	}
	if m.dist_prov != nil {
		edges = append(edges, district.EdgeDistProv)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeDistSubd:
		if id := m.dist_subd; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeDistPost:
		if id := m.dist_post; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeDistProv:
		ids := make([]ent.Value, 0, len(m.dist_prov))
		for id := range m.dist_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddist_prov != nil {
		edges = append(edges, district.EdgeDistProv)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeDistProv:
		ids := make([]ent.Value, 0, len(m.removeddist_prov))
		for id := range m.removeddist_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddist_subd {
		edges = append(edges, district.EdgeDistSubd)
	}
	if m.cleareddist_post {
		edges = append(edges, district.EdgeDistPost)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeDistSubd:
		return m.cleareddist_subd
	case district.EdgeDistPost:
		return m.cleareddist_post
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeDistSubd:
		m.ClearDistSubd()
		return nil
	case district.EdgeDistPost:
		m.ClearDistPost()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeDistSubd:
		m.ResetDistSubd()
		return nil
	case district.EdgeDistPost:
		m.ResetDistPost()
		return nil
	case district.EdgeDistProv:
		m.ResetDistProv()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// FacultyMutation represents an operation that mutate the Faculties
// nodes in the graph.
type FacultyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	faculty          *string
	clearedFields    map[string]struct{}
	facu_cour        map[int]struct{}
	removedfacu_cour map[int]struct{}
	facu_prof        map[int]struct{}
	removedfacu_prof map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Faculty, error)
}

var _ ent.Mutation = (*FacultyMutation)(nil)

// facultyOption allows to manage the mutation configuration using functional options.
type facultyOption func(*FacultyMutation)

// newFacultyMutation creates new mutation for $n.Name.
func newFacultyMutation(c config, op Op, opts ...facultyOption) *FacultyMutation {
	m := &FacultyMutation{
		config:        c,
		op:            op,
		typ:           TypeFaculty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacultyID sets the id field of the mutation.
func withFacultyID(id int) facultyOption {
	return func(m *FacultyMutation) {
		var (
			err   error
			once  sync.Once
			value *Faculty
		)
		m.oldValue = func(ctx context.Context) (*Faculty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faculty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaculty sets the old Faculty of the mutation.
func withFaculty(node *Faculty) facultyOption {
	return func(m *FacultyMutation) {
		m.oldValue = func(context.Context) (*Faculty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFaculty sets the faculty field.
func (m *FacultyMutation) SetFaculty(s string) {
	m.faculty = &s
}

// Faculty returns the faculty value in the mutation.
func (m *FacultyMutation) Faculty() (r string, exists bool) {
	v := m.faculty
	if v == nil {
		return
	}
	return *v, true
}

// OldFaculty returns the old faculty value of the Faculty.
// If the Faculty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacultyMutation) OldFaculty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFaculty is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFaculty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaculty: %w", err)
	}
	return oldValue.Faculty, nil
}

// ResetFaculty reset all changes of the "faculty" field.
func (m *FacultyMutation) ResetFaculty() {
	m.faculty = nil
}

// AddFacuCourIDs adds the facu_cour edge to Course by ids.
func (m *FacultyMutation) AddFacuCourIDs(ids ...int) {
	if m.facu_cour == nil {
		m.facu_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.facu_cour[ids[i]] = struct{}{}
	}
}

// RemoveFacuCourIDs removes the facu_cour edge to Course by ids.
func (m *FacultyMutation) RemoveFacuCourIDs(ids ...int) {
	if m.removedfacu_cour == nil {
		m.removedfacu_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfacu_cour[ids[i]] = struct{}{}
	}
}

// RemovedFacuCour returns the removed ids of facu_cour.
func (m *FacultyMutation) RemovedFacuCourIDs() (ids []int) {
	for id := range m.removedfacu_cour {
		ids = append(ids, id)
	}
	return
}

// FacuCourIDs returns the facu_cour ids in the mutation.
func (m *FacultyMutation) FacuCourIDs() (ids []int) {
	for id := range m.facu_cour {
		ids = append(ids, id)
	}
	return
}

// ResetFacuCour reset all changes of the "facu_cour" edge.
func (m *FacultyMutation) ResetFacuCour() {
	m.facu_cour = nil
	m.removedfacu_cour = nil
}

// AddFacuProfIDs adds the facu_prof edge to Professor by ids.
func (m *FacultyMutation) AddFacuProfIDs(ids ...int) {
	if m.facu_prof == nil {
		m.facu_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.facu_prof[ids[i]] = struct{}{}
	}
}

// RemoveFacuProfIDs removes the facu_prof edge to Professor by ids.
func (m *FacultyMutation) RemoveFacuProfIDs(ids ...int) {
	if m.removedfacu_prof == nil {
		m.removedfacu_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfacu_prof[ids[i]] = struct{}{}
	}
}

// RemovedFacuProf returns the removed ids of facu_prof.
func (m *FacultyMutation) RemovedFacuProfIDs() (ids []int) {
	for id := range m.removedfacu_prof {
		ids = append(ids, id)
	}
	return
}

// FacuProfIDs returns the facu_prof ids in the mutation.
func (m *FacultyMutation) FacuProfIDs() (ids []int) {
	for id := range m.facu_prof {
		ids = append(ids, id)
	}
	return
}

// ResetFacuProf reset all changes of the "facu_prof" edge.
func (m *FacultyMutation) ResetFacuProf() {
	m.facu_prof = nil
	m.removedfacu_prof = nil
}

// Op returns the operation name.
func (m *FacultyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Faculty).
func (m *FacultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacultyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.faculty != nil {
		fields = append(fields, faculty.FieldFaculty)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faculty.FieldFaculty:
		return m.Faculty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faculty.FieldFaculty:
		return m.OldFaculty(ctx)
	}
	return nil, fmt.Errorf("unknown Faculty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faculty.FieldFaculty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaculty(v)
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacultyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacultyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacultyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacultyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Faculty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacultyMutation) ResetField(name string) error {
	switch name {
	case faculty.FieldFaculty:
		m.ResetFaculty()
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.facu_cour != nil {
		edges = append(edges, faculty.EdgeFacuCour)
	}
	if m.facu_prof != nil {
		edges = append(edges, faculty.EdgeFacuProf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacultyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeFacuCour:
		ids := make([]ent.Value, 0, len(m.facu_cour))
		for id := range m.facu_cour {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeFacuProf:
		ids := make([]ent.Value, 0, len(m.facu_prof))
		for id := range m.facu_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfacu_cour != nil {
		edges = append(edges, faculty.EdgeFacuCour)
	}
	if m.removedfacu_prof != nil {
		edges = append(edges, faculty.EdgeFacuProf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacultyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeFacuCour:
		ids := make([]ent.Value, 0, len(m.removedfacu_cour))
		for id := range m.removedfacu_cour {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeFacuProf:
		ids := make([]ent.Value, 0, len(m.removedfacu_prof))
		for id := range m.removedfacu_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacultyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacultyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacultyMutation) ResetEdge(name string) error {
	switch name {
	case faculty.EdgeFacuCour:
		m.ResetFacuCour()
		return nil
	case faculty.EdgeFacuProf:
		m.ResetFacuProf()
		return nil
	}
	return fmt.Errorf("unknown Faculty edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op               Op
	typ              string
	id               *int
	gender           *string
	clearedFields    map[string]struct{}
	gend_stud        map[int]struct{}
	removedgend_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGender sets the gender field.
func (m *GenderMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *GenderMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *GenderMutation) ResetGender() {
	m.gender = nil
}

// AddGendStudIDs adds the gend_stud edge to Student by ids.
func (m *GenderMutation) AddGendStudIDs(ids ...int) {
	if m.gend_stud == nil {
		m.gend_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.gend_stud[ids[i]] = struct{}{}
	}
}

// RemoveGendStudIDs removes the gend_stud edge to Student by ids.
func (m *GenderMutation) RemoveGendStudIDs(ids ...int) {
	if m.removedgend_stud == nil {
		m.removedgend_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgend_stud[ids[i]] = struct{}{}
	}
}

// RemovedGendStud returns the removed ids of gend_stud.
func (m *GenderMutation) RemovedGendStudIDs() (ids []int) {
	for id := range m.removedgend_stud {
		ids = append(ids, id)
	}
	return
}

// GendStudIDs returns the gend_stud ids in the mutation.
func (m *GenderMutation) GendStudIDs() (ids []int) {
	for id := range m.gend_stud {
		ids = append(ids, id)
	}
	return
}

// ResetGendStud reset all changes of the "gend_stud" edge.
func (m *GenderMutation) ResetGendStud() {
	m.gend_stud = nil
	m.removedgend_stud = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender != nil {
		fields = append(fields, gender.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gend_stud != nil {
		edges = append(edges, gender.EdgeGendStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGendStud:
		ids := make([]ent.Value, 0, len(m.gend_stud))
		for id := range m.gend_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgend_stud != nil {
		edges = append(edges, gender.EdgeGendStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGendStud:
		ids := make([]ent.Value, 0, len(m.removedgend_stud))
		for id := range m.removedgend_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeGendStud:
		m.ResetGendStud()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// InstitutionMutation represents an operation that mutate the Institutions
// nodes in the graph.
type InstitutionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	institution      *string
	clearedFields    map[string]struct{}
	inst_cour        map[int]struct{}
	removedinst_cour map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Institution, error)
}

var _ ent.Mutation = (*InstitutionMutation)(nil)

// institutionOption allows to manage the mutation configuration using functional options.
type institutionOption func(*InstitutionMutation)

// newInstitutionMutation creates new mutation for $n.Name.
func newInstitutionMutation(c config, op Op, opts ...institutionOption) *InstitutionMutation {
	m := &InstitutionMutation{
		config:        c,
		op:            op,
		typ:           TypeInstitution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstitutionID sets the id field of the mutation.
func withInstitutionID(id int) institutionOption {
	return func(m *InstitutionMutation) {
		var (
			err   error
			once  sync.Once
			value *Institution
		)
		m.oldValue = func(ctx context.Context) (*Institution, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Institution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstitution sets the old Institution of the mutation.
func withInstitution(node *Institution) institutionOption {
	return func(m *InstitutionMutation) {
		m.oldValue = func(context.Context) (*Institution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstitutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstitutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstitutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInstitution sets the institution field.
func (m *InstitutionMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the institution value in the mutation.
func (m *InstitutionMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old institution value of the Institution.
// If the Institution object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstitutionMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstitution is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution reset all changes of the "institution" field.
func (m *InstitutionMutation) ResetInstitution() {
	m.institution = nil
}

// AddInstCourIDs adds the inst_cour edge to Course by ids.
func (m *InstitutionMutation) AddInstCourIDs(ids ...int) {
	if m.inst_cour == nil {
		m.inst_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.inst_cour[ids[i]] = struct{}{}
	}
}

// RemoveInstCourIDs removes the inst_cour edge to Course by ids.
func (m *InstitutionMutation) RemoveInstCourIDs(ids ...int) {
	if m.removedinst_cour == nil {
		m.removedinst_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinst_cour[ids[i]] = struct{}{}
	}
}

// RemovedInstCour returns the removed ids of inst_cour.
func (m *InstitutionMutation) RemovedInstCourIDs() (ids []int) {
	for id := range m.removedinst_cour {
		ids = append(ids, id)
	}
	return
}

// InstCourIDs returns the inst_cour ids in the mutation.
func (m *InstitutionMutation) InstCourIDs() (ids []int) {
	for id := range m.inst_cour {
		ids = append(ids, id)
	}
	return
}

// ResetInstCour reset all changes of the "inst_cour" edge.
func (m *InstitutionMutation) ResetInstCour() {
	m.inst_cour = nil
	m.removedinst_cour = nil
}

// Op returns the operation name.
func (m *InstitutionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Institution).
func (m *InstitutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstitutionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.institution != nil {
		fields = append(fields, institution.FieldInstitution)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstitutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case institution.FieldInstitution:
		return m.Institution()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstitutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case institution.FieldInstitution:
		return m.OldInstitution(ctx)
	}
	return nil, fmt.Errorf("unknown Institution field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstitutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case institution.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	}
	return fmt.Errorf("unknown Institution field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstitutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstitutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstitutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Institution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstitutionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstitutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstitutionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Institution nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstitutionMutation) ResetField(name string) error {
	switch name {
	case institution.FieldInstitution:
		m.ResetInstitution()
		return nil
	}
	return fmt.Errorf("unknown Institution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstitutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.inst_cour != nil {
		edges = append(edges, institution.EdgeInstCour)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstitutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case institution.EdgeInstCour:
		ids := make([]ent.Value, 0, len(m.inst_cour))
		for id := range m.inst_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstitutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinst_cour != nil {
		edges = append(edges, institution.EdgeInstCour)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstitutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case institution.EdgeInstCour:
		ids := make([]ent.Value, 0, len(m.removedinst_cour))
		for id := range m.removedinst_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstitutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstitutionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstitutionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Institution unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstitutionMutation) ResetEdge(name string) error {
	switch name {
	case institution.EdgeInstCour:
		m.ResetInstCour()
		return nil
	}
	return fmt.Errorf("unknown Institution edge %s", name)
}

// PlaceMutation represents an operation that mutate the Places
// nodes in the graph.
type PlaceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_PLACE            *string
	clearedFields     map[string]struct{}
	place_acti        map[int]struct{}
	removedplace_acti map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Place, error)
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows to manage the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for $n.Name.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the id field of the mutation.
func withPlaceID(id int) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPLACE sets the PLACE field.
func (m *PlaceMutation) SetPLACE(s string) {
	m._PLACE = &s
}

// PLACE returns the PLACE value in the mutation.
func (m *PlaceMutation) PLACE() (r string, exists bool) {
	v := m._PLACE
	if v == nil {
		return
	}
	return *v, true
}

// OldPLACE returns the old PLACE value of the Place.
// If the Place object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlaceMutation) OldPLACE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPLACE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPLACE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPLACE: %w", err)
	}
	return oldValue.PLACE, nil
}

// ResetPLACE reset all changes of the "PLACE" field.
func (m *PlaceMutation) ResetPLACE() {
	m._PLACE = nil
}

// AddPlaceActiIDs adds the place_acti edge to Activity by ids.
func (m *PlaceMutation) AddPlaceActiIDs(ids ...int) {
	if m.place_acti == nil {
		m.place_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.place_acti[ids[i]] = struct{}{}
	}
}

// RemovePlaceActiIDs removes the place_acti edge to Activity by ids.
func (m *PlaceMutation) RemovePlaceActiIDs(ids ...int) {
	if m.removedplace_acti == nil {
		m.removedplace_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplace_acti[ids[i]] = struct{}{}
	}
}

// RemovedPlaceActi returns the removed ids of place_acti.
func (m *PlaceMutation) RemovedPlaceActiIDs() (ids []int) {
	for id := range m.removedplace_acti {
		ids = append(ids, id)
	}
	return
}

// PlaceActiIDs returns the place_acti ids in the mutation.
func (m *PlaceMutation) PlaceActiIDs() (ids []int) {
	for id := range m.place_acti {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceActi reset all changes of the "place_acti" edge.
func (m *PlaceMutation) ResetPlaceActi() {
	m.place_acti = nil
	m.removedplace_acti = nil
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PLACE != nil {
		fields = append(fields, place.FieldPLACE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldPLACE:
		return m.PLACE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldPLACE:
		return m.OldPLACE(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldPLACE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPLACE(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldPLACE:
		m.ResetPLACE()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.place_acti != nil {
		edges = append(edges, place.EdgePlaceActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgePlaceActi:
		ids := make([]ent.Value, 0, len(m.place_acti))
		for id := range m.place_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplace_acti != nil {
		edges = append(edges, place.EdgePlaceActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgePlaceActi:
		ids := make([]ent.Value, 0, len(m.removedplace_acti))
		for id := range m.removedplace_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgePlaceActi:
		m.ResetPlaceActi()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// PostalMutation represents an operation that mutate the Postals
// nodes in the graph.
type PostalMutation struct {
	config
	op               Op
	typ              string
	id               *int
	postal           *string
	clearedFields    map[string]struct{}
	post_dist        map[int]struct{}
	removedpost_dist map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Postal, error)
}

var _ ent.Mutation = (*PostalMutation)(nil)

// postalOption allows to manage the mutation configuration using functional options.
type postalOption func(*PostalMutation)

// newPostalMutation creates new mutation for $n.Name.
func newPostalMutation(c config, op Op, opts ...postalOption) *PostalMutation {
	m := &PostalMutation{
		config:        c,
		op:            op,
		typ:           TypePostal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostalID sets the id field of the mutation.
func withPostalID(id int) postalOption {
	return func(m *PostalMutation) {
		var (
			err   error
			once  sync.Once
			value *Postal
		)
		m.oldValue = func(ctx context.Context) (*Postal, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Postal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostal sets the old Postal of the mutation.
func withPostal(node *Postal) postalOption {
	return func(m *PostalMutation) {
		m.oldValue = func(context.Context) (*Postal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PostalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPostal sets the postal field.
func (m *PostalMutation) SetPostal(s string) {
	m.postal = &s
}

// Postal returns the postal value in the mutation.
func (m *PostalMutation) Postal() (r string, exists bool) {
	v := m.postal
	if v == nil {
		return
	}
	return *v, true
}

// OldPostal returns the old postal value of the Postal.
// If the Postal object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PostalMutation) OldPostal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostal: %w", err)
	}
	return oldValue.Postal, nil
}

// ResetPostal reset all changes of the "postal" field.
func (m *PostalMutation) ResetPostal() {
	m.postal = nil
}

// AddPostDistIDs adds the post_dist edge to District by ids.
func (m *PostalMutation) AddPostDistIDs(ids ...int) {
	if m.post_dist == nil {
		m.post_dist = make(map[int]struct{})
	}
	for i := range ids {
		m.post_dist[ids[i]] = struct{}{}
	}
}

// RemovePostDistIDs removes the post_dist edge to District by ids.
func (m *PostalMutation) RemovePostDistIDs(ids ...int) {
	if m.removedpost_dist == nil {
		m.removedpost_dist = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpost_dist[ids[i]] = struct{}{}
	}
}

// RemovedPostDist returns the removed ids of post_dist.
func (m *PostalMutation) RemovedPostDistIDs() (ids []int) {
	for id := range m.removedpost_dist {
		ids = append(ids, id)
	}
	return
}

// PostDistIDs returns the post_dist ids in the mutation.
func (m *PostalMutation) PostDistIDs() (ids []int) {
	for id := range m.post_dist {
		ids = append(ids, id)
	}
	return
}

// ResetPostDist reset all changes of the "post_dist" edge.
func (m *PostalMutation) ResetPostDist() {
	m.post_dist = nil
	m.removedpost_dist = nil
}

// Op returns the operation name.
func (m *PostalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Postal).
func (m *PostalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PostalMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.postal != nil {
		fields = append(fields, postal.FieldPostal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PostalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postal.FieldPostal:
		return m.Postal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PostalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postal.FieldPostal:
		return m.OldPostal(ctx)
	}
	return nil, fmt.Errorf("unknown Postal field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postal.FieldPostal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostal(v)
		return nil
	}
	return fmt.Errorf("unknown Postal field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PostalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PostalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Postal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PostalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PostalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Postal nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PostalMutation) ResetField(name string) error {
	switch name {
	case postal.FieldPostal:
		m.ResetPostal()
		return nil
	}
	return fmt.Errorf("unknown Postal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PostalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post_dist != nil {
		edges = append(edges, postal.EdgePostDist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PostalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postal.EdgePostDist:
		ids := make([]ent.Value, 0, len(m.post_dist))
		for id := range m.post_dist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PostalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpost_dist != nil {
		edges = append(edges, postal.EdgePostDist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PostalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postal.EdgePostDist:
		ids := make([]ent.Value, 0, len(m.removedpost_dist))
		for id := range m.removedpost_dist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PostalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PostalMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PostalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Postal unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PostalMutation) ResetEdge(name string) error {
	switch name {
	case postal.EdgePostDist:
		m.ResetPostDist()
		return nil
	}
	return fmt.Errorf("unknown Postal edge %s", name)
}

// PrefixMutation represents an operation that mutate the Prefixes
// nodes in the graph.
type PrefixMutation struct {
	config
	op               Op
	typ              string
	id               *int
	prefix           *string
	clearedFields    map[string]struct{}
	pre_prof         map[int]struct{}
	removedpre_prof  map[int]struct{}
	pref_stud        map[int]struct{}
	removedpref_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Prefix, error)
}

var _ ent.Mutation = (*PrefixMutation)(nil)

// prefixOption allows to manage the mutation configuration using functional options.
type prefixOption func(*PrefixMutation)

// newPrefixMutation creates new mutation for $n.Name.
func newPrefixMutation(c config, op Op, opts ...prefixOption) *PrefixMutation {
	m := &PrefixMutation{
		config:        c,
		op:            op,
		typ:           TypePrefix,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefixID sets the id field of the mutation.
func withPrefixID(id int) prefixOption {
	return func(m *PrefixMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefix
		)
		m.oldValue = func(ctx context.Context) (*Prefix, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefix.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefix sets the old Prefix of the mutation.
func withPrefix(node *Prefix) prefixOption {
	return func(m *PrefixMutation) {
		m.oldValue = func(context.Context) (*Prefix, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefixMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefixMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrefixMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefix sets the prefix field.
func (m *PrefixMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the prefix value in the mutation.
func (m *PrefixMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old prefix value of the Prefix.
// If the Prefix object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrefixMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefix is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix reset all changes of the "prefix" field.
func (m *PrefixMutation) ResetPrefix() {
	m.prefix = nil
}

// AddPreProfIDs adds the pre_prof edge to Professor by ids.
func (m *PrefixMutation) AddPreProfIDs(ids ...int) {
	if m.pre_prof == nil {
		m.pre_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.pre_prof[ids[i]] = struct{}{}
	}
}

// RemovePreProfIDs removes the pre_prof edge to Professor by ids.
func (m *PrefixMutation) RemovePreProfIDs(ids ...int) {
	if m.removedpre_prof == nil {
		m.removedpre_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpre_prof[ids[i]] = struct{}{}
	}
}

// RemovedPreProf returns the removed ids of pre_prof.
func (m *PrefixMutation) RemovedPreProfIDs() (ids []int) {
	for id := range m.removedpre_prof {
		ids = append(ids, id)
	}
	return
}

// PreProfIDs returns the pre_prof ids in the mutation.
func (m *PrefixMutation) PreProfIDs() (ids []int) {
	for id := range m.pre_prof {
		ids = append(ids, id)
	}
	return
}

// ResetPreProf reset all changes of the "pre_prof" edge.
func (m *PrefixMutation) ResetPreProf() {
	m.pre_prof = nil
	m.removedpre_prof = nil
}

// AddPrefStudIDs adds the pref_stud edge to Student by ids.
func (m *PrefixMutation) AddPrefStudIDs(ids ...int) {
	if m.pref_stud == nil {
		m.pref_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.pref_stud[ids[i]] = struct{}{}
	}
}

// RemovePrefStudIDs removes the pref_stud edge to Student by ids.
func (m *PrefixMutation) RemovePrefStudIDs(ids ...int) {
	if m.removedpref_stud == nil {
		m.removedpref_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpref_stud[ids[i]] = struct{}{}
	}
}

// RemovedPrefStud returns the removed ids of pref_stud.
func (m *PrefixMutation) RemovedPrefStudIDs() (ids []int) {
	for id := range m.removedpref_stud {
		ids = append(ids, id)
	}
	return
}

// PrefStudIDs returns the pref_stud ids in the mutation.
func (m *PrefixMutation) PrefStudIDs() (ids []int) {
	for id := range m.pref_stud {
		ids = append(ids, id)
	}
	return
}

// ResetPrefStud reset all changes of the "pref_stud" edge.
func (m *PrefixMutation) ResetPrefStud() {
	m.pref_stud = nil
	m.removedpref_stud = nil
}

// Op returns the operation name.
func (m *PrefixMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefix).
func (m *PrefixMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrefixMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefix != nil {
		fields = append(fields, prefix.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrefixMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefix.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrefixMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefix.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Prefix field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefix.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrefixMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrefixMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrefixMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrefixMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefixMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefix nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrefixMutation) ResetField(name string) error {
	switch name {
	case prefix.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrefixMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pre_prof != nil {
		edges = append(edges, prefix.EdgePreProf)
	}
	if m.pref_stud != nil {
		edges = append(edges, prefix.EdgePrefStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrefixMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePreProf:
		ids := make([]ent.Value, 0, len(m.pre_prof))
		for id := range m.pre_prof {
			ids = append(ids, id)
		}
		return ids
	case prefix.EdgePrefStud:
		ids := make([]ent.Value, 0, len(m.pref_stud))
		for id := range m.pref_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrefixMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpre_prof != nil {
		edges = append(edges, prefix.EdgePreProf)
	}
	if m.removedpref_stud != nil {
		edges = append(edges, prefix.EdgePrefStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrefixMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePreProf:
		ids := make([]ent.Value, 0, len(m.removedpre_prof))
		for id := range m.removedpre_prof {
			ids = append(ids, id)
		}
		return ids
	case prefix.EdgePrefStud:
		ids := make([]ent.Value, 0, len(m.removedpref_stud))
		for id := range m.removedpref_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrefixMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrefixMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrefixMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrefixMutation) ResetEdge(name string) error {
	switch name {
	case prefix.EdgePreProf:
		m.ResetPreProf()
		return nil
	case prefix.EdgePrefStud:
		m.ResetPrefStud()
		return nil
	}
	return fmt.Errorf("unknown Prefix edge %s", name)
}

// ProfessorMutation represents an operation that mutate the Professors
// nodes in the graph.
type ProfessorMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	tel              *string
	email            *string
	clearedFields    map[string]struct{}
	prof_pre         *int
	clearedprof_pre  bool
	prof_facu        *int
	clearedprof_facu bool
	prof_pros        *int
	clearedprof_pros bool
	done             bool
	oldValue         func(context.Context) (*Professor, error)
}

var _ ent.Mutation = (*ProfessorMutation)(nil)

// professorOption allows to manage the mutation configuration using functional options.
type professorOption func(*ProfessorMutation)

// newProfessorMutation creates new mutation for $n.Name.
func newProfessorMutation(c config, op Op, opts ...professorOption) *ProfessorMutation {
	m := &ProfessorMutation{
		config:        c,
		op:            op,
		typ:           TypeProfessor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfessorID sets the id field of the mutation.
func withProfessorID(id int) professorOption {
	return func(m *ProfessorMutation) {
		var (
			err   error
			once  sync.Once
			value *Professor
		)
		m.oldValue = func(ctx context.Context) (*Professor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Professor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfessor sets the old Professor of the mutation.
func withProfessor(node *Professor) professorOption {
	return func(m *ProfessorMutation) {
		m.oldValue = func(context.Context) (*Professor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfessorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfessorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProfessorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ProfessorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProfessorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProfessorMutation) ResetName() {
	m.name = nil
}

// SetTel sets the tel field.
func (m *ProfessorMutation) SetTel(s string) {
	m.tel = &s
}

// Tel returns the tel value in the mutation.
func (m *ProfessorMutation) Tel() (r string, exists bool) {
	v := m.tel
	if v == nil {
		return
	}
	return *v, true
}

// OldTel returns the old tel value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTel: %w", err)
	}
	return oldValue.Tel, nil
}

// ResetTel reset all changes of the "tel" field.
func (m *ProfessorMutation) ResetTel() {
	m.tel = nil
}

// SetEmail sets the email field.
func (m *ProfessorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *ProfessorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *ProfessorMutation) ResetEmail() {
	m.email = nil
}

// SetProfPreID sets the prof_pre edge to Prefix by id.
func (m *ProfessorMutation) SetProfPreID(id int) {
	m.prof_pre = &id
}

// ClearProfPre clears the prof_pre edge to Prefix.
func (m *ProfessorMutation) ClearProfPre() {
	m.clearedprof_pre = true
}

// ProfPreCleared returns if the edge prof_pre was cleared.
func (m *ProfessorMutation) ProfPreCleared() bool {
	return m.clearedprof_pre
}

// ProfPreID returns the prof_pre id in the mutation.
func (m *ProfessorMutation) ProfPreID() (id int, exists bool) {
	if m.prof_pre != nil {
		return *m.prof_pre, true
	}
	return
}

// ProfPreIDs returns the prof_pre ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfPreID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfPreIDs() (ids []int) {
	if id := m.prof_pre; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfPre reset all changes of the "prof_pre" edge.
func (m *ProfessorMutation) ResetProfPre() {
	m.prof_pre = nil
	m.clearedprof_pre = false
}

// SetProfFacuID sets the prof_facu edge to Faculty by id.
func (m *ProfessorMutation) SetProfFacuID(id int) {
	m.prof_facu = &id
}

// ClearProfFacu clears the prof_facu edge to Faculty.
func (m *ProfessorMutation) ClearProfFacu() {
	m.clearedprof_facu = true
}

// ProfFacuCleared returns if the edge prof_facu was cleared.
func (m *ProfessorMutation) ProfFacuCleared() bool {
	return m.clearedprof_facu
}

// ProfFacuID returns the prof_facu id in the mutation.
func (m *ProfessorMutation) ProfFacuID() (id int, exists bool) {
	if m.prof_facu != nil {
		return *m.prof_facu, true
	}
	return
}

// ProfFacuIDs returns the prof_facu ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfFacuID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfFacuIDs() (ids []int) {
	if id := m.prof_facu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfFacu reset all changes of the "prof_facu" edge.
func (m *ProfessorMutation) ResetProfFacu() {
	m.prof_facu = nil
	m.clearedprof_facu = false
}

// SetProfProsID sets the prof_pros edge to Professorship by id.
func (m *ProfessorMutation) SetProfProsID(id int) {
	m.prof_pros = &id
}

// ClearProfPros clears the prof_pros edge to Professorship.
func (m *ProfessorMutation) ClearProfPros() {
	m.clearedprof_pros = true
}

// ProfProsCleared returns if the edge prof_pros was cleared.
func (m *ProfessorMutation) ProfProsCleared() bool {
	return m.clearedprof_pros
}

// ProfProsID returns the prof_pros id in the mutation.
func (m *ProfessorMutation) ProfProsID() (id int, exists bool) {
	if m.prof_pros != nil {
		return *m.prof_pros, true
	}
	return
}

// ProfProsIDs returns the prof_pros ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfProsID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfProsIDs() (ids []int) {
	if id := m.prof_pros; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfPros reset all changes of the "prof_pros" edge.
func (m *ProfessorMutation) ResetProfPros() {
	m.prof_pros = nil
	m.clearedprof_pros = false
}

// Op returns the operation name.
func (m *ProfessorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Professor).
func (m *ProfessorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProfessorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, professor.FieldName)
	}
	if m.tel != nil {
		fields = append(fields, professor.FieldTel)
	}
	if m.email != nil {
		fields = append(fields, professor.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProfessorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case professor.FieldName:
		return m.Name()
	case professor.FieldTel:
		return m.Tel()
	case professor.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProfessorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case professor.FieldName:
		return m.OldName(ctx)
	case professor.FieldTel:
		return m.OldTel(ctx)
	case professor.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Professor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case professor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case professor.FieldTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTel(v)
		return nil
	case professor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Professor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProfessorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProfessorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Professor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProfessorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProfessorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfessorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Professor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProfessorMutation) ResetField(name string) error {
	switch name {
	case professor.FieldName:
		m.ResetName()
		return nil
	case professor.FieldTel:
		m.ResetTel()
		return nil
	case professor.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Professor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProfessorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prof_pre != nil {
		edges = append(edges, professor.EdgeProfPre)
	}
	if m.prof_facu != nil {
		edges = append(edges, professor.EdgeProfFacu)
	}
	if m.prof_pros != nil {
		edges = append(edges, professor.EdgeProfPros)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProfessorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case professor.EdgeProfPre:
		if id := m.prof_pre; id != nil {
			return []ent.Value{*id}
		}
	case professor.EdgeProfFacu:
		if id := m.prof_facu; id != nil {
			return []ent.Value{*id}
		}
	case professor.EdgeProfPros:
		if id := m.prof_pros; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProfessorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProfessorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProfessorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprof_pre {
		edges = append(edges, professor.EdgeProfPre)
	}
	if m.clearedprof_facu {
		edges = append(edges, professor.EdgeProfFacu)
	}
	if m.clearedprof_pros {
		edges = append(edges, professor.EdgeProfPros)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProfessorMutation) EdgeCleared(name string) bool {
	switch name {
	case professor.EdgeProfPre:
		return m.clearedprof_pre
	case professor.EdgeProfFacu:
		return m.clearedprof_facu
	case professor.EdgeProfPros:
		return m.clearedprof_pros
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProfessorMutation) ClearEdge(name string) error {
	switch name {
	case professor.EdgeProfPre:
		m.ClearProfPre()
		return nil
	case professor.EdgeProfFacu:
		m.ClearProfFacu()
		return nil
	case professor.EdgeProfPros:
		m.ClearProfPros()
		return nil
	}
	return fmt.Errorf("unknown Professor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProfessorMutation) ResetEdge(name string) error {
	switch name {
	case professor.EdgeProfPre:
		m.ResetProfPre()
		return nil
	case professor.EdgeProfFacu:
		m.ResetProfFacu()
		return nil
	case professor.EdgeProfPros:
		m.ResetProfPros()
		return nil
	}
	return fmt.Errorf("unknown Professor edge %s", name)
}

// ProfessorshipMutation represents an operation that mutate the Professorships
// nodes in the graph.
type ProfessorshipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	professorship    *string
	clearedFields    map[string]struct{}
	pros_prof        map[int]struct{}
	removedpros_prof map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Professorship, error)
}

var _ ent.Mutation = (*ProfessorshipMutation)(nil)

// professorshipOption allows to manage the mutation configuration using functional options.
type professorshipOption func(*ProfessorshipMutation)

// newProfessorshipMutation creates new mutation for $n.Name.
func newProfessorshipMutation(c config, op Op, opts ...professorshipOption) *ProfessorshipMutation {
	m := &ProfessorshipMutation{
		config:        c,
		op:            op,
		typ:           TypeProfessorship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfessorshipID sets the id field of the mutation.
func withProfessorshipID(id int) professorshipOption {
	return func(m *ProfessorshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Professorship
		)
		m.oldValue = func(ctx context.Context) (*Professorship, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Professorship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfessorship sets the old Professorship of the mutation.
func withProfessorship(node *Professorship) professorshipOption {
	return func(m *ProfessorshipMutation) {
		m.oldValue = func(context.Context) (*Professorship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfessorshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfessorshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProfessorshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProfessorship sets the professorship field.
func (m *ProfessorshipMutation) SetProfessorship(s string) {
	m.professorship = &s
}

// Professorship returns the professorship value in the mutation.
func (m *ProfessorshipMutation) Professorship() (r string, exists bool) {
	v := m.professorship
	if v == nil {
		return
	}
	return *v, true
}

// OldProfessorship returns the old professorship value of the Professorship.
// If the Professorship object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorshipMutation) OldProfessorship(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfessorship is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfessorship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfessorship: %w", err)
	}
	return oldValue.Professorship, nil
}

// ResetProfessorship reset all changes of the "professorship" field.
func (m *ProfessorshipMutation) ResetProfessorship() {
	m.professorship = nil
}

// AddProsProfIDs adds the pros_prof edge to Professor by ids.
func (m *ProfessorshipMutation) AddProsProfIDs(ids ...int) {
	if m.pros_prof == nil {
		m.pros_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.pros_prof[ids[i]] = struct{}{}
	}
}

// RemoveProsProfIDs removes the pros_prof edge to Professor by ids.
func (m *ProfessorshipMutation) RemoveProsProfIDs(ids ...int) {
	if m.removedpros_prof == nil {
		m.removedpros_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpros_prof[ids[i]] = struct{}{}
	}
}

// RemovedProsProf returns the removed ids of pros_prof.
func (m *ProfessorshipMutation) RemovedProsProfIDs() (ids []int) {
	for id := range m.removedpros_prof {
		ids = append(ids, id)
	}
	return
}

// ProsProfIDs returns the pros_prof ids in the mutation.
func (m *ProfessorshipMutation) ProsProfIDs() (ids []int) {
	for id := range m.pros_prof {
		ids = append(ids, id)
	}
	return
}

// ResetProsProf reset all changes of the "pros_prof" edge.
func (m *ProfessorshipMutation) ResetProsProf() {
	m.pros_prof = nil
	m.removedpros_prof = nil
}

// Op returns the operation name.
func (m *ProfessorshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Professorship).
func (m *ProfessorshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProfessorshipMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.professorship != nil {
		fields = append(fields, professorship.FieldProfessorship)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProfessorshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case professorship.FieldProfessorship:
		return m.Professorship()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProfessorshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case professorship.FieldProfessorship:
		return m.OldProfessorship(ctx)
	}
	return nil, fmt.Errorf("unknown Professorship field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case professorship.FieldProfessorship:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfessorship(v)
		return nil
	}
	return fmt.Errorf("unknown Professorship field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProfessorshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProfessorshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Professorship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProfessorshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProfessorshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfessorshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Professorship nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProfessorshipMutation) ResetField(name string) error {
	switch name {
	case professorship.FieldProfessorship:
		m.ResetProfessorship()
		return nil
	}
	return fmt.Errorf("unknown Professorship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProfessorshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pros_prof != nil {
		edges = append(edges, professorship.EdgeProsProf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProfessorshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case professorship.EdgeProsProf:
		ids := make([]ent.Value, 0, len(m.pros_prof))
		for id := range m.pros_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProfessorshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpros_prof != nil {
		edges = append(edges, professorship.EdgeProsProf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProfessorshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case professorship.EdgeProsProf:
		ids := make([]ent.Value, 0, len(m.removedpros_prof))
		for id := range m.removedpros_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProfessorshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProfessorshipMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProfessorshipMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Professorship unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProfessorshipMutation) ResetEdge(name string) error {
	switch name {
	case professorship.EdgeProsProf:
		m.ResetProsProf()
		return nil
	}
	return fmt.Errorf("unknown Professorship edge %s", name)
}

// ProvinceMutation represents an operation that mutate the Provinces
// nodes in the graph.
type ProvinceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	prov_regi        *int
	clearedprov_regi bool
	prov_dist        *int
	clearedprov_dist bool
	prov_stud        map[int]struct{}
	removedprov_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Province, error)
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows to manage the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for $n.Name.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the id field of the mutation.
func withProvinceID(id int) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProvinceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Province.
// If the Province object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// SetProvRegiID sets the prov_regi edge to Region by id.
func (m *ProvinceMutation) SetProvRegiID(id int) {
	m.prov_regi = &id
}

// ClearProvRegi clears the prov_regi edge to Region.
func (m *ProvinceMutation) ClearProvRegi() {
	m.clearedprov_regi = true
}

// ProvRegiCleared returns if the edge prov_regi was cleared.
func (m *ProvinceMutation) ProvRegiCleared() bool {
	return m.clearedprov_regi
}

// ProvRegiID returns the prov_regi id in the mutation.
func (m *ProvinceMutation) ProvRegiID() (id int, exists bool) {
	if m.prov_regi != nil {
		return *m.prov_regi, true
	}
	return
}

// ProvRegiIDs returns the prov_regi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProvRegiID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) ProvRegiIDs() (ids []int) {
	if id := m.prov_regi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvRegi reset all changes of the "prov_regi" edge.
func (m *ProvinceMutation) ResetProvRegi() {
	m.prov_regi = nil
	m.clearedprov_regi = false
}

// SetProvDistID sets the prov_dist edge to District by id.
func (m *ProvinceMutation) SetProvDistID(id int) {
	m.prov_dist = &id
}

// ClearProvDist clears the prov_dist edge to District.
func (m *ProvinceMutation) ClearProvDist() {
	m.clearedprov_dist = true
}

// ProvDistCleared returns if the edge prov_dist was cleared.
func (m *ProvinceMutation) ProvDistCleared() bool {
	return m.clearedprov_dist
}

// ProvDistID returns the prov_dist id in the mutation.
func (m *ProvinceMutation) ProvDistID() (id int, exists bool) {
	if m.prov_dist != nil {
		return *m.prov_dist, true
	}
	return
}

// ProvDistIDs returns the prov_dist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProvDistID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) ProvDistIDs() (ids []int) {
	if id := m.prov_dist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvDist reset all changes of the "prov_dist" edge.
func (m *ProvinceMutation) ResetProvDist() {
	m.prov_dist = nil
	m.clearedprov_dist = false
}

// AddProvStudIDs adds the prov_stud edge to Student by ids.
func (m *ProvinceMutation) AddProvStudIDs(ids ...int) {
	if m.prov_stud == nil {
		m.prov_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.prov_stud[ids[i]] = struct{}{}
	}
}

// RemoveProvStudIDs removes the prov_stud edge to Student by ids.
func (m *ProvinceMutation) RemoveProvStudIDs(ids ...int) {
	if m.removedprov_stud == nil {
		m.removedprov_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprov_stud[ids[i]] = struct{}{}
	}
}

// RemovedProvStud returns the removed ids of prov_stud.
func (m *ProvinceMutation) RemovedProvStudIDs() (ids []int) {
	for id := range m.removedprov_stud {
		ids = append(ids, id)
	}
	return
}

// ProvStudIDs returns the prov_stud ids in the mutation.
func (m *ProvinceMutation) ProvStudIDs() (ids []int) {
	for id := range m.prov_stud {
		ids = append(ids, id)
	}
	return
}

// ResetProvStud reset all changes of the "prov_stud" edge.
func (m *ProvinceMutation) ResetProvStud() {
	m.prov_stud = nil
	m.removedprov_stud = nil
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prov_regi != nil {
		edges = append(edges, province.EdgeProvRegi)
	}
	if m.prov_dist != nil {
		edges = append(edges, province.EdgeProvDist)
	}
	if m.prov_stud != nil {
		edges = append(edges, province.EdgeProvStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeProvRegi:
		if id := m.prov_regi; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeProvDist:
		if id := m.prov_dist; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeProvStud:
		ids := make([]ent.Value, 0, len(m.prov_stud))
		for id := range m.prov_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprov_stud != nil {
		edges = append(edges, province.EdgeProvStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeProvStud:
		ids := make([]ent.Value, 0, len(m.removedprov_stud))
		for id := range m.removedprov_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprov_regi {
		edges = append(edges, province.EdgeProvRegi)
	}
	if m.clearedprov_dist {
		edges = append(edges, province.EdgeProvDist)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeProvRegi:
		return m.clearedprov_regi
	case province.EdgeProvDist:
		return m.clearedprov_dist
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	case province.EdgeProvRegi:
		m.ClearProvRegi()
		return nil
	case province.EdgeProvDist:
		m.ClearProvDist()
		return nil
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeProvRegi:
		m.ResetProvRegi()
		return nil
	case province.EdgeProvDist:
		m.ResetProvDist()
		return nil
	case province.EdgeProvStud:
		m.ResetProvStud()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// RegionMutation represents an operation that mutate the Regions
// nodes in the graph.
type RegionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	regi_prov        map[int]struct{}
	removedregi_prov map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Region, error)
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows to manage the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for $n.Name.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the id field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Region.
// If the Region object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// AddRegiProvIDs adds the regi_prov edge to Province by ids.
func (m *RegionMutation) AddRegiProvIDs(ids ...int) {
	if m.regi_prov == nil {
		m.regi_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.regi_prov[ids[i]] = struct{}{}
	}
}

// RemoveRegiProvIDs removes the regi_prov edge to Province by ids.
func (m *RegionMutation) RemoveRegiProvIDs(ids ...int) {
	if m.removedregi_prov == nil {
		m.removedregi_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.removedregi_prov[ids[i]] = struct{}{}
	}
}

// RemovedRegiProv returns the removed ids of regi_prov.
func (m *RegionMutation) RemovedRegiProvIDs() (ids []int) {
	for id := range m.removedregi_prov {
		ids = append(ids, id)
	}
	return
}

// RegiProvIDs returns the regi_prov ids in the mutation.
func (m *RegionMutation) RegiProvIDs() (ids []int) {
	for id := range m.regi_prov {
		ids = append(ids, id)
	}
	return
}

// ResetRegiProv reset all changes of the "regi_prov" edge.
func (m *RegionMutation) ResetRegiProv() {
	m.regi_prov = nil
	m.removedregi_prov = nil
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.regi_prov != nil {
		edges = append(edges, region.EdgeRegiProv)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeRegiProv:
		ids := make([]ent.Value, 0, len(m.regi_prov))
		for id := range m.regi_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedregi_prov != nil {
		edges = append(edges, region.EdgeRegiProv)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeRegiProv:
		ids := make([]ent.Value, 0, len(m.removedregi_prov))
		for id := range m.removedregi_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeRegiProv:
		m.ResetRegiProv()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// ResultsMutation represents an operation that mutate the ResultsSlice
// nodes in the graph.
type ResultsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	grade            *float64
	addgrade         *float64
	clearedFields    map[string]struct{}
	resu_year        *int
	clearedresu_year bool
	resu_subj        *int
	clearedresu_subj bool
	resu_stud        *int
	clearedresu_stud bool
	done             bool
	oldValue         func(context.Context) (*Results, error)
}

var _ ent.Mutation = (*ResultsMutation)(nil)

// resultsOption allows to manage the mutation configuration using functional options.
type resultsOption func(*ResultsMutation)

// newResultsMutation creates new mutation for $n.Name.
func newResultsMutation(c config, op Op, opts ...resultsOption) *ResultsMutation {
	m := &ResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResultsID sets the id field of the mutation.
func withResultsID(id int) resultsOption {
	return func(m *ResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *Results
		)
		m.oldValue = func(ctx context.Context) (*Results, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Results.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResults sets the old Results of the mutation.
func withResults(node *Results) resultsOption {
	return func(m *ResultsMutation) {
		m.oldValue = func(context.Context) (*Results, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGrade sets the grade field.
func (m *ResultsMutation) SetGrade(f float64) {
	m.grade = &f
	m.addgrade = nil
}

// Grade returns the grade value in the mutation.
func (m *ResultsMutation) Grade() (r float64, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old grade value of the Results.
// If the Results object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResultsMutation) OldGrade(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrade is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// AddGrade adds f to grade.
func (m *ResultsMutation) AddGrade(f float64) {
	if m.addgrade != nil {
		*m.addgrade += f
	} else {
		m.addgrade = &f
	}
}

// AddedGrade returns the value that was added to the grade field in this mutation.
func (m *ResultsMutation) AddedGrade() (r float64, exists bool) {
	v := m.addgrade
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrade reset all changes of the "grade" field.
func (m *ResultsMutation) ResetGrade() {
	m.grade = nil
	m.addgrade = nil
}

// SetResuYearID sets the resu_year edge to Year by id.
func (m *ResultsMutation) SetResuYearID(id int) {
	m.resu_year = &id
}

// ClearResuYear clears the resu_year edge to Year.
func (m *ResultsMutation) ClearResuYear() {
	m.clearedresu_year = true
}

// ResuYearCleared returns if the edge resu_year was cleared.
func (m *ResultsMutation) ResuYearCleared() bool {
	return m.clearedresu_year
}

// ResuYearID returns the resu_year id in the mutation.
func (m *ResultsMutation) ResuYearID() (id int, exists bool) {
	if m.resu_year != nil {
		return *m.resu_year, true
	}
	return
}

// ResuYearIDs returns the resu_year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuYearID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuYearIDs() (ids []int) {
	if id := m.resu_year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuYear reset all changes of the "resu_year" edge.
func (m *ResultsMutation) ResetResuYear() {
	m.resu_year = nil
	m.clearedresu_year = false
}

// SetResuSubjID sets the resu_subj edge to Subject by id.
func (m *ResultsMutation) SetResuSubjID(id int) {
	m.resu_subj = &id
}

// ClearResuSubj clears the resu_subj edge to Subject.
func (m *ResultsMutation) ClearResuSubj() {
	m.clearedresu_subj = true
}

// ResuSubjCleared returns if the edge resu_subj was cleared.
func (m *ResultsMutation) ResuSubjCleared() bool {
	return m.clearedresu_subj
}

// ResuSubjID returns the resu_subj id in the mutation.
func (m *ResultsMutation) ResuSubjID() (id int, exists bool) {
	if m.resu_subj != nil {
		return *m.resu_subj, true
	}
	return
}

// ResuSubjIDs returns the resu_subj ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuSubjID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuSubjIDs() (ids []int) {
	if id := m.resu_subj; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuSubj reset all changes of the "resu_subj" edge.
func (m *ResultsMutation) ResetResuSubj() {
	m.resu_subj = nil
	m.clearedresu_subj = false
}

// SetResuStudID sets the resu_stud edge to Student by id.
func (m *ResultsMutation) SetResuStudID(id int) {
	m.resu_stud = &id
}

// ClearResuStud clears the resu_stud edge to Student.
func (m *ResultsMutation) ClearResuStud() {
	m.clearedresu_stud = true
}

// ResuStudCleared returns if the edge resu_stud was cleared.
func (m *ResultsMutation) ResuStudCleared() bool {
	return m.clearedresu_stud
}

// ResuStudID returns the resu_stud id in the mutation.
func (m *ResultsMutation) ResuStudID() (id int, exists bool) {
	if m.resu_stud != nil {
		return *m.resu_stud, true
	}
	return
}

// ResuStudIDs returns the resu_stud ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuStudID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuStudIDs() (ids []int) {
	if id := m.resu_stud; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuStud reset all changes of the "resu_stud" edge.
func (m *ResultsMutation) ResetResuStud() {
	m.resu_stud = nil
	m.clearedresu_stud = false
}

// Op returns the operation name.
func (m *ResultsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Results).
func (m *ResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResultsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.grade != nil {
		fields = append(fields, results.FieldGrade)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case results.FieldGrade:
		return m.Grade()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case results.FieldGrade:
		return m.OldGrade(ctx)
	}
	return nil, fmt.Errorf("unknown Results field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case results.FieldGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Results field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResultsMutation) AddedFields() []string {
	var fields []string
	if m.addgrade != nil {
		fields = append(fields, results.FieldGrade)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResultsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case results.FieldGrade:
		return m.AddedGrade()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case results.FieldGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Results numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResultsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResultsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Results nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResultsMutation) ResetField(name string) error {
	switch name {
	case results.FieldGrade:
		m.ResetGrade()
		return nil
	}
	return fmt.Errorf("unknown Results field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.resu_year != nil {
		edges = append(edges, results.EdgeResuYear)
	}
	if m.resu_subj != nil {
		edges = append(edges, results.EdgeResuSubj)
	}
	if m.resu_stud != nil {
		edges = append(edges, results.EdgeResuStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case results.EdgeResuYear:
		if id := m.resu_year; id != nil {
			return []ent.Value{*id}
		}
	case results.EdgeResuSubj:
		if id := m.resu_subj; id != nil {
			return []ent.Value{*id}
		}
	case results.EdgeResuStud:
		if id := m.resu_stud; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResultsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedresu_year {
		edges = append(edges, results.EdgeResuYear)
	}
	if m.clearedresu_subj {
		edges = append(edges, results.EdgeResuSubj)
	}
	if m.clearedresu_stud {
		edges = append(edges, results.EdgeResuStud)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case results.EdgeResuYear:
		return m.clearedresu_year
	case results.EdgeResuSubj:
		return m.clearedresu_subj
	case results.EdgeResuStud:
		return m.clearedresu_stud
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResultsMutation) ClearEdge(name string) error {
	switch name {
	case results.EdgeResuYear:
		m.ClearResuYear()
		return nil
	case results.EdgeResuSubj:
		m.ClearResuSubj()
		return nil
	case results.EdgeResuStud:
		m.ClearResuStud()
		return nil
	}
	return fmt.Errorf("unknown Results unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResultsMutation) ResetEdge(name string) error {
	switch name {
	case results.EdgeResuYear:
		m.ResetResuYear()
		return nil
	case results.EdgeResuSubj:
		m.ResetResuSubj()
		return nil
	case results.EdgeResuStud:
		m.ResetResuStud()
		return nil
	}
	return fmt.Errorf("unknown Results edge %s", name)
}

// StudentMutation represents an operation that mutate the Students
// nodes in the graph.
type StudentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	fname            *string
	lname            *string
	schoolname       *string
	recent_address   *string
	telephone        *int
	addtelephone     *int
	email            *string
	clearedFields    map[string]struct{}
	stud_gend        *int
	clearedstud_gend bool
	stud_acti        map[int]struct{}
	removedstud_acti map[int]struct{}
	stud_prov        *int
	clearedstud_prov bool
	stud_resu        map[int]struct{}
	removedstud_resu map[int]struct{}
	stud_pref        *int
	clearedstud_pref bool
	stud_degr        *int
	clearedstud_degr bool
	done             bool
	oldValue         func(context.Context) (*Student, error)
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows to manage the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for $n.Name.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the id field of the mutation.
func withStudentID(id int) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFname sets the fname field.
func (m *StudentMutation) SetFname(s string) {
	m.fname = &s
}

// Fname returns the fname value in the mutation.
func (m *StudentMutation) Fname() (r string, exists bool) {
	v := m.fname
	if v == nil {
		return
	}
	return *v, true
}

// OldFname returns the old fname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldFname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFname: %w", err)
	}
	return oldValue.Fname, nil
}

// ResetFname reset all changes of the "fname" field.
func (m *StudentMutation) ResetFname() {
	m.fname = nil
}

// SetLname sets the lname field.
func (m *StudentMutation) SetLname(s string) {
	m.lname = &s
}

// Lname returns the lname value in the mutation.
func (m *StudentMutation) Lname() (r string, exists bool) {
	v := m.lname
	if v == nil {
		return
	}
	return *v, true
}

// OldLname returns the old lname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldLname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLname: %w", err)
	}
	return oldValue.Lname, nil
}

// ResetLname reset all changes of the "lname" field.
func (m *StudentMutation) ResetLname() {
	m.lname = nil
}

// SetSchoolname sets the schoolname field.
func (m *StudentMutation) SetSchoolname(s string) {
	m.schoolname = &s
}

// Schoolname returns the schoolname value in the mutation.
func (m *StudentMutation) Schoolname() (r string, exists bool) {
	v := m.schoolname
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolname returns the old schoolname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldSchoolname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchoolname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchoolname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolname: %w", err)
	}
	return oldValue.Schoolname, nil
}

// ResetSchoolname reset all changes of the "schoolname" field.
func (m *StudentMutation) ResetSchoolname() {
	m.schoolname = nil
}

// SetRecentAddress sets the recent_address field.
func (m *StudentMutation) SetRecentAddress(s string) {
	m.recent_address = &s
}

// RecentAddress returns the recent_address value in the mutation.
func (m *StudentMutation) RecentAddress() (r string, exists bool) {
	v := m.recent_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentAddress returns the old recent_address value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldRecentAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecentAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecentAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentAddress: %w", err)
	}
	return oldValue.RecentAddress, nil
}

// ResetRecentAddress reset all changes of the "recent_address" field.
func (m *StudentMutation) ResetRecentAddress() {
	m.recent_address = nil
}

// SetTelephone sets the telephone field.
func (m *StudentMutation) SetTelephone(i int) {
	m.telephone = &i
	m.addtelephone = nil
}

// Telephone returns the telephone value in the mutation.
func (m *StudentMutation) Telephone() (r int, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old telephone value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldTelephone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// AddTelephone adds i to telephone.
func (m *StudentMutation) AddTelephone(i int) {
	if m.addtelephone != nil {
		*m.addtelephone += i
	} else {
		m.addtelephone = &i
	}
}

// AddedTelephone returns the value that was added to the telephone field in this mutation.
func (m *StudentMutation) AddedTelephone() (r int, exists bool) {
	v := m.addtelephone
	if v == nil {
		return
	}
	return *v, true
}

// ResetTelephone reset all changes of the "telephone" field.
func (m *StudentMutation) ResetTelephone() {
	m.telephone = nil
	m.addtelephone = nil
}

// SetEmail sets the email field.
func (m *StudentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *StudentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *StudentMutation) ResetEmail() {
	m.email = nil
}

// SetStudGendID sets the stud_gend edge to Gender by id.
func (m *StudentMutation) SetStudGendID(id int) {
	m.stud_gend = &id
}

// ClearStudGend clears the stud_gend edge to Gender.
func (m *StudentMutation) ClearStudGend() {
	m.clearedstud_gend = true
}

// StudGendCleared returns if the edge stud_gend was cleared.
func (m *StudentMutation) StudGendCleared() bool {
	return m.clearedstud_gend
}

// StudGendID returns the stud_gend id in the mutation.
func (m *StudentMutation) StudGendID() (id int, exists bool) {
	if m.stud_gend != nil {
		return *m.stud_gend, true
	}
	return
}

// StudGendIDs returns the stud_gend ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudGendID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudGendIDs() (ids []int) {
	if id := m.stud_gend; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudGend reset all changes of the "stud_gend" edge.
func (m *StudentMutation) ResetStudGend() {
	m.stud_gend = nil
	m.clearedstud_gend = false
}

// AddStudActiIDs adds the stud_acti edge to Activity by ids.
func (m *StudentMutation) AddStudActiIDs(ids ...int) {
	if m.stud_acti == nil {
		m.stud_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.stud_acti[ids[i]] = struct{}{}
	}
}

// RemoveStudActiIDs removes the stud_acti edge to Activity by ids.
func (m *StudentMutation) RemoveStudActiIDs(ids ...int) {
	if m.removedstud_acti == nil {
		m.removedstud_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstud_acti[ids[i]] = struct{}{}
	}
}

// RemovedStudActi returns the removed ids of stud_acti.
func (m *StudentMutation) RemovedStudActiIDs() (ids []int) {
	for id := range m.removedstud_acti {
		ids = append(ids, id)
	}
	return
}

// StudActiIDs returns the stud_acti ids in the mutation.
func (m *StudentMutation) StudActiIDs() (ids []int) {
	for id := range m.stud_acti {
		ids = append(ids, id)
	}
	return
}

// ResetStudActi reset all changes of the "stud_acti" edge.
func (m *StudentMutation) ResetStudActi() {
	m.stud_acti = nil
	m.removedstud_acti = nil
}

// SetStudProvID sets the stud_prov edge to Province by id.
func (m *StudentMutation) SetStudProvID(id int) {
	m.stud_prov = &id
}

// ClearStudProv clears the stud_prov edge to Province.
func (m *StudentMutation) ClearStudProv() {
	m.clearedstud_prov = true
}

// StudProvCleared returns if the edge stud_prov was cleared.
func (m *StudentMutation) StudProvCleared() bool {
	return m.clearedstud_prov
}

// StudProvID returns the stud_prov id in the mutation.
func (m *StudentMutation) StudProvID() (id int, exists bool) {
	if m.stud_prov != nil {
		return *m.stud_prov, true
	}
	return
}

// StudProvIDs returns the stud_prov ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudProvID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudProvIDs() (ids []int) {
	if id := m.stud_prov; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudProv reset all changes of the "stud_prov" edge.
func (m *StudentMutation) ResetStudProv() {
	m.stud_prov = nil
	m.clearedstud_prov = false
}

// AddStudResuIDs adds the stud_resu edge to Results by ids.
func (m *StudentMutation) AddStudResuIDs(ids ...int) {
	if m.stud_resu == nil {
		m.stud_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.stud_resu[ids[i]] = struct{}{}
	}
}

// RemoveStudResuIDs removes the stud_resu edge to Results by ids.
func (m *StudentMutation) RemoveStudResuIDs(ids ...int) {
	if m.removedstud_resu == nil {
		m.removedstud_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstud_resu[ids[i]] = struct{}{}
	}
}

// RemovedStudResu returns the removed ids of stud_resu.
func (m *StudentMutation) RemovedStudResuIDs() (ids []int) {
	for id := range m.removedstud_resu {
		ids = append(ids, id)
	}
	return
}

// StudResuIDs returns the stud_resu ids in the mutation.
func (m *StudentMutation) StudResuIDs() (ids []int) {
	for id := range m.stud_resu {
		ids = append(ids, id)
	}
	return
}

// ResetStudResu reset all changes of the "stud_resu" edge.
func (m *StudentMutation) ResetStudResu() {
	m.stud_resu = nil
	m.removedstud_resu = nil
}

// SetStudPrefID sets the stud_pref edge to Prefix by id.
func (m *StudentMutation) SetStudPrefID(id int) {
	m.stud_pref = &id
}

// ClearStudPref clears the stud_pref edge to Prefix.
func (m *StudentMutation) ClearStudPref() {
	m.clearedstud_pref = true
}

// StudPrefCleared returns if the edge stud_pref was cleared.
func (m *StudentMutation) StudPrefCleared() bool {
	return m.clearedstud_pref
}

// StudPrefID returns the stud_pref id in the mutation.
func (m *StudentMutation) StudPrefID() (id int, exists bool) {
	if m.stud_pref != nil {
		return *m.stud_pref, true
	}
	return
}

// StudPrefIDs returns the stud_pref ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudPrefID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudPrefIDs() (ids []int) {
	if id := m.stud_pref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudPref reset all changes of the "stud_pref" edge.
func (m *StudentMutation) ResetStudPref() {
	m.stud_pref = nil
	m.clearedstud_pref = false
}

// SetStudDegrID sets the stud_degr edge to Degree by id.
func (m *StudentMutation) SetStudDegrID(id int) {
	m.stud_degr = &id
}

// ClearStudDegr clears the stud_degr edge to Degree.
func (m *StudentMutation) ClearStudDegr() {
	m.clearedstud_degr = true
}

// StudDegrCleared returns if the edge stud_degr was cleared.
func (m *StudentMutation) StudDegrCleared() bool {
	return m.clearedstud_degr
}

// StudDegrID returns the stud_degr id in the mutation.
func (m *StudentMutation) StudDegrID() (id int, exists bool) {
	if m.stud_degr != nil {
		return *m.stud_degr, true
	}
	return
}

// StudDegrIDs returns the stud_degr ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudDegrID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudDegrIDs() (ids []int) {
	if id := m.stud_degr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudDegr reset all changes of the "stud_degr" edge.
func (m *StudentMutation) ResetStudDegr() {
	m.stud_degr = nil
	m.clearedstud_degr = false
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.fname != nil {
		fields = append(fields, student.FieldFname)
	}
	if m.lname != nil {
		fields = append(fields, student.FieldLname)
	}
	if m.schoolname != nil {
		fields = append(fields, student.FieldSchoolname)
	}
	if m.recent_address != nil {
		fields = append(fields, student.FieldRecentAddress)
	}
	if m.telephone != nil {
		fields = append(fields, student.FieldTelephone)
	}
	if m.email != nil {
		fields = append(fields, student.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldFname:
		return m.Fname()
	case student.FieldLname:
		return m.Lname()
	case student.FieldSchoolname:
		return m.Schoolname()
	case student.FieldRecentAddress:
		return m.RecentAddress()
	case student.FieldTelephone:
		return m.Telephone()
	case student.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldFname:
		return m.OldFname(ctx)
	case student.FieldLname:
		return m.OldLname(ctx)
	case student.FieldSchoolname:
		return m.OldSchoolname(ctx)
	case student.FieldRecentAddress:
		return m.OldRecentAddress(ctx)
	case student.FieldTelephone:
		return m.OldTelephone(ctx)
	case student.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldFname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFname(v)
		return nil
	case student.FieldLname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLname(v)
		return nil
	case student.FieldSchoolname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolname(v)
		return nil
	case student.FieldRecentAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentAddress(v)
		return nil
	case student.FieldTelephone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case student.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StudentMutation) AddedFields() []string {
	var fields []string
	if m.addtelephone != nil {
		fields = append(fields, student.FieldTelephone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case student.FieldTelephone:
		return m.AddedTelephone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case student.FieldTelephone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTelephone(v)
		return nil
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldFname:
		m.ResetFname()
		return nil
	case student.FieldLname:
		m.ResetLname()
		return nil
	case student.FieldSchoolname:
		m.ResetSchoolname()
		return nil
	case student.FieldRecentAddress:
		m.ResetRecentAddress()
		return nil
	case student.FieldTelephone:
		m.ResetTelephone()
		return nil
	case student.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.stud_gend != nil {
		edges = append(edges, student.EdgeStudGend)
	}
	if m.stud_acti != nil {
		edges = append(edges, student.EdgeStudActi)
	}
	if m.stud_prov != nil {
		edges = append(edges, student.EdgeStudProv)
	}
	if m.stud_resu != nil {
		edges = append(edges, student.EdgeStudResu)
	}
	if m.stud_pref != nil {
		edges = append(edges, student.EdgeStudPref)
	}
	if m.stud_degr != nil {
		edges = append(edges, student.EdgeStudDegr)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeStudGend:
		if id := m.stud_gend; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudActi:
		ids := make([]ent.Value, 0, len(m.stud_acti))
		for id := range m.stud_acti {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudProv:
		if id := m.stud_prov; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudResu:
		ids := make([]ent.Value, 0, len(m.stud_resu))
		for id := range m.stud_resu {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudPref:
		if id := m.stud_pref; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudDegr:
		if id := m.stud_degr; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedstud_acti != nil {
		edges = append(edges, student.EdgeStudActi)
	}
	if m.removedstud_resu != nil {
		edges = append(edges, student.EdgeStudResu)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeStudActi:
		ids := make([]ent.Value, 0, len(m.removedstud_acti))
		for id := range m.removedstud_acti {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudResu:
		ids := make([]ent.Value, 0, len(m.removedstud_resu))
		for id := range m.removedstud_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstud_gend {
		edges = append(edges, student.EdgeStudGend)
	}
	if m.clearedstud_prov {
		edges = append(edges, student.EdgeStudProv)
	}
	if m.clearedstud_pref {
		edges = append(edges, student.EdgeStudPref)
	}
	if m.clearedstud_degr {
		edges = append(edges, student.EdgeStudDegr)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeStudGend:
		return m.clearedstud_gend
	case student.EdgeStudProv:
		return m.clearedstud_prov
	case student.EdgeStudPref:
		return m.clearedstud_pref
	case student.EdgeStudDegr:
		return m.clearedstud_degr
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeStudGend:
		m.ClearStudGend()
		return nil
	case student.EdgeStudProv:
		m.ClearStudProv()
		return nil
	case student.EdgeStudPref:
		m.ClearStudPref()
		return nil
	case student.EdgeStudDegr:
		m.ClearStudDegr()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeStudGend:
		m.ResetStudGend()
		return nil
	case student.EdgeStudActi:
		m.ResetStudActi()
		return nil
	case student.EdgeStudProv:
		m.ResetStudProv()
		return nil
	case student.EdgeStudResu:
		m.ResetStudResu()
		return nil
	case student.EdgeStudPref:
		m.ResetStudPref()
		return nil
	case student.EdgeStudDegr:
		m.ResetStudDegr()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// SubdistrictMutation represents an operation that mutate the Subdistricts
// nodes in the graph.
type SubdistrictMutation struct {
	config
	op               Op
	typ              string
	id               *int
	subdistrict      *string
	clearedFields    map[string]struct{}
	subd_dist        map[int]struct{}
	removedsubd_dist map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Subdistrict, error)
}

var _ ent.Mutation = (*SubdistrictMutation)(nil)

// subdistrictOption allows to manage the mutation configuration using functional options.
type subdistrictOption func(*SubdistrictMutation)

// newSubdistrictMutation creates new mutation for $n.Name.
func newSubdistrictMutation(c config, op Op, opts ...subdistrictOption) *SubdistrictMutation {
	m := &SubdistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeSubdistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubdistrictID sets the id field of the mutation.
func withSubdistrictID(id int) subdistrictOption {
	return func(m *SubdistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *Subdistrict
		)
		m.oldValue = func(ctx context.Context) (*Subdistrict, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subdistrict.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubdistrict sets the old Subdistrict of the mutation.
func withSubdistrict(node *Subdistrict) subdistrictOption {
	return func(m *SubdistrictMutation) {
		m.oldValue = func(context.Context) (*Subdistrict, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubdistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubdistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubdistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubdistrict sets the subdistrict field.
func (m *SubdistrictMutation) SetSubdistrict(s string) {
	m.subdistrict = &s
}

// Subdistrict returns the subdistrict value in the mutation.
func (m *SubdistrictMutation) Subdistrict() (r string, exists bool) {
	v := m.subdistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubdistrict returns the old subdistrict value of the Subdistrict.
// If the Subdistrict object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubdistrictMutation) OldSubdistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubdistrict is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubdistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubdistrict: %w", err)
	}
	return oldValue.Subdistrict, nil
}

// ResetSubdistrict reset all changes of the "subdistrict" field.
func (m *SubdistrictMutation) ResetSubdistrict() {
	m.subdistrict = nil
}

// AddSubdDistIDs adds the subd_dist edge to District by ids.
func (m *SubdistrictMutation) AddSubdDistIDs(ids ...int) {
	if m.subd_dist == nil {
		m.subd_dist = make(map[int]struct{})
	}
	for i := range ids {
		m.subd_dist[ids[i]] = struct{}{}
	}
}

// RemoveSubdDistIDs removes the subd_dist edge to District by ids.
func (m *SubdistrictMutation) RemoveSubdDistIDs(ids ...int) {
	if m.removedsubd_dist == nil {
		m.removedsubd_dist = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubd_dist[ids[i]] = struct{}{}
	}
}

// RemovedSubdDist returns the removed ids of subd_dist.
func (m *SubdistrictMutation) RemovedSubdDistIDs() (ids []int) {
	for id := range m.removedsubd_dist {
		ids = append(ids, id)
	}
	return
}

// SubdDistIDs returns the subd_dist ids in the mutation.
func (m *SubdistrictMutation) SubdDistIDs() (ids []int) {
	for id := range m.subd_dist {
		ids = append(ids, id)
	}
	return
}

// ResetSubdDist reset all changes of the "subd_dist" edge.
func (m *SubdistrictMutation) ResetSubdDist() {
	m.subd_dist = nil
	m.removedsubd_dist = nil
}

// Op returns the operation name.
func (m *SubdistrictMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subdistrict).
func (m *SubdistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubdistrictMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.subdistrict != nil {
		fields = append(fields, subdistrict.FieldSubdistrict)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubdistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subdistrict.FieldSubdistrict:
		return m.Subdistrict()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubdistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subdistrict.FieldSubdistrict:
		return m.OldSubdistrict(ctx)
	}
	return nil, fmt.Errorf("unknown Subdistrict field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubdistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subdistrict.FieldSubdistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubdistrict(v)
		return nil
	}
	return fmt.Errorf("unknown Subdistrict field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubdistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubdistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubdistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subdistrict numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubdistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubdistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubdistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subdistrict nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubdistrictMutation) ResetField(name string) error {
	switch name {
	case subdistrict.FieldSubdistrict:
		m.ResetSubdistrict()
		return nil
	}
	return fmt.Errorf("unknown Subdistrict field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubdistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subd_dist != nil {
		edges = append(edges, subdistrict.EdgeSubdDist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubdistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subdistrict.EdgeSubdDist:
		ids := make([]ent.Value, 0, len(m.subd_dist))
		for id := range m.subd_dist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubdistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubd_dist != nil {
		edges = append(edges, subdistrict.EdgeSubdDist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubdistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subdistrict.EdgeSubdDist:
		ids := make([]ent.Value, 0, len(m.removedsubd_dist))
		for id := range m.removedsubd_dist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubdistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubdistrictMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubdistrictMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subdistrict unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubdistrictMutation) ResetEdge(name string) error {
	switch name {
	case subdistrict.EdgeSubdDist:
		m.ResetSubdDist()
		return nil
	}
	return fmt.Errorf("unknown Subdistrict edge %s", name)
}

// SubjectMutation represents an operation that mutate the Subjects
// nodes in the graph.
type SubjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	code             *int
	addcode          *int
	subjects         *string
	creditpiont      *int
	addcreditpiont   *int
	clearedFields    map[string]struct{}
	subj_resu        map[int]struct{}
	removedsubj_resu map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Subject, error)
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows to manage the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for $n.Name.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the id field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCode sets the code field.
func (m *SubjectMutation) SetCode(i int) {
	m.code = &i
	m.addcode = nil
}

// Code returns the code value in the mutation.
func (m *SubjectMutation) Code() (r int, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to code.
func (m *SubjectMutation) AddCode(i int) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the code field in this mutation.
func (m *SubjectMutation) AddedCode() (r int, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode reset all changes of the "code" field.
func (m *SubjectMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
}

// SetSubjects sets the subjects field.
func (m *SubjectMutation) SetSubjects(s string) {
	m.subjects = &s
}

// Subjects returns the subjects value in the mutation.
func (m *SubjectMutation) Subjects() (r string, exists bool) {
	v := m.subjects
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjects returns the old subjects value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldSubjects(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjects is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjects: %w", err)
	}
	return oldValue.Subjects, nil
}

// ResetSubjects reset all changes of the "subjects" field.
func (m *SubjectMutation) ResetSubjects() {
	m.subjects = nil
}

// SetCreditpiont sets the creditpiont field.
func (m *SubjectMutation) SetCreditpiont(i int) {
	m.creditpiont = &i
	m.addcreditpiont = nil
}

// Creditpiont returns the creditpiont value in the mutation.
func (m *SubjectMutation) Creditpiont() (r int, exists bool) {
	v := m.creditpiont
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditpiont returns the old creditpiont value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldCreditpiont(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreditpiont is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreditpiont requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditpiont: %w", err)
	}
	return oldValue.Creditpiont, nil
}

// AddCreditpiont adds i to creditpiont.
func (m *SubjectMutation) AddCreditpiont(i int) {
	if m.addcreditpiont != nil {
		*m.addcreditpiont += i
	} else {
		m.addcreditpiont = &i
	}
}

// AddedCreditpiont returns the value that was added to the creditpiont field in this mutation.
func (m *SubjectMutation) AddedCreditpiont() (r int, exists bool) {
	v := m.addcreditpiont
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditpiont reset all changes of the "creditpiont" field.
func (m *SubjectMutation) ResetCreditpiont() {
	m.creditpiont = nil
	m.addcreditpiont = nil
}

// AddSubjResuIDs adds the subj_resu edge to Results by ids.
func (m *SubjectMutation) AddSubjResuIDs(ids ...int) {
	if m.subj_resu == nil {
		m.subj_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.subj_resu[ids[i]] = struct{}{}
	}
}

// RemoveSubjResuIDs removes the subj_resu edge to Results by ids.
func (m *SubjectMutation) RemoveSubjResuIDs(ids ...int) {
	if m.removedsubj_resu == nil {
		m.removedsubj_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubj_resu[ids[i]] = struct{}{}
	}
}

// RemovedSubjResu returns the removed ids of subj_resu.
func (m *SubjectMutation) RemovedSubjResuIDs() (ids []int) {
	for id := range m.removedsubj_resu {
		ids = append(ids, id)
	}
	return
}

// SubjResuIDs returns the subj_resu ids in the mutation.
func (m *SubjectMutation) SubjResuIDs() (ids []int) {
	for id := range m.subj_resu {
		ids = append(ids, id)
	}
	return
}

// ResetSubjResu reset all changes of the "subj_resu" edge.
func (m *SubjectMutation) ResetSubjResu() {
	m.subj_resu = nil
	m.removedsubj_resu = nil
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, subject.FieldCode)
	}
	if m.subjects != nil {
		fields = append(fields, subject.FieldSubjects)
	}
	if m.creditpiont != nil {
		fields = append(fields, subject.FieldCreditpiont)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCode:
		return m.Code()
	case subject.FieldSubjects:
		return m.Subjects()
	case subject.FieldCreditpiont:
		return m.Creditpiont()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCode:
		return m.OldCode(ctx)
	case subject.FieldSubjects:
		return m.OldSubjects(ctx)
	case subject.FieldCreditpiont:
		return m.OldCreditpiont(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case subject.FieldSubjects:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjects(v)
		return nil
	case subject.FieldCreditpiont:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditpiont(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectMutation) AddedFields() []string {
	var fields []string
	if m.addcode != nil {
		fields = append(fields, subject.FieldCode)
	}
	if m.addcreditpiont != nil {
		fields = append(fields, subject.FieldCreditpiont)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCode:
		return m.AddedCode()
	case subject.FieldCreditpiont:
		return m.AddedCreditpiont()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	case subject.FieldCreditpiont:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditpiont(v)
		return nil
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCode:
		m.ResetCode()
		return nil
	case subject.FieldSubjects:
		m.ResetSubjects()
		return nil
	case subject.FieldCreditpiont:
		m.ResetCreditpiont()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subj_resu != nil {
		edges = append(edges, subject.EdgeSubjResu)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubjResu:
		ids := make([]ent.Value, 0, len(m.subj_resu))
		for id := range m.subj_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubj_resu != nil {
		edges = append(edges, subject.EdgeSubjResu)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubjResu:
		ids := make([]ent.Value, 0, len(m.removedsubj_resu))
		for id := range m.removedsubj_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeSubjResu:
		m.ResetSubjResu()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// TermMutation represents an operation that mutate the Terms
// nodes in the graph.
type TermMutation struct {
	config
	op               Op
	typ              string
	id               *int
	semester         *int
	addsemester      *int
	clearedFields    map[string]struct{}
	term_year        *int
	clearedterm_year bool
	done             bool
	oldValue         func(context.Context) (*Term, error)
}

var _ ent.Mutation = (*TermMutation)(nil)

// termOption allows to manage the mutation configuration using functional options.
type termOption func(*TermMutation)

// newTermMutation creates new mutation for $n.Name.
func newTermMutation(c config, op Op, opts ...termOption) *TermMutation {
	m := &TermMutation{
		config:        c,
		op:            op,
		typ:           TypeTerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTermID sets the id field of the mutation.
func withTermID(id int) termOption {
	return func(m *TermMutation) {
		var (
			err   error
			once  sync.Once
			value *Term
		)
		m.oldValue = func(ctx context.Context) (*Term, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Term.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTerm sets the old Term of the mutation.
func withTerm(node *Term) termOption {
	return func(m *TermMutation) {
		m.oldValue = func(context.Context) (*Term, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TermMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSemester sets the semester field.
func (m *TermMutation) SetSemester(i int) {
	m.semester = &i
	m.addsemester = nil
}

// Semester returns the semester value in the mutation.
func (m *TermMutation) Semester() (r int, exists bool) {
	v := m.semester
	if v == nil {
		return
	}
	return *v, true
}

// OldSemester returns the old semester value of the Term.
// If the Term object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TermMutation) OldSemester(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemester is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemester requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemester: %w", err)
	}
	return oldValue.Semester, nil
}

// AddSemester adds i to semester.
func (m *TermMutation) AddSemester(i int) {
	if m.addsemester != nil {
		*m.addsemester += i
	} else {
		m.addsemester = &i
	}
}

// AddedSemester returns the value that was added to the semester field in this mutation.
func (m *TermMutation) AddedSemester() (r int, exists bool) {
	v := m.addsemester
	if v == nil {
		return
	}
	return *v, true
}

// ResetSemester reset all changes of the "semester" field.
func (m *TermMutation) ResetSemester() {
	m.semester = nil
	m.addsemester = nil
}

// SetTermYearID sets the term_year edge to Year by id.
func (m *TermMutation) SetTermYearID(id int) {
	m.term_year = &id
}

// ClearTermYear clears the term_year edge to Year.
func (m *TermMutation) ClearTermYear() {
	m.clearedterm_year = true
}

// TermYearCleared returns if the edge term_year was cleared.
func (m *TermMutation) TermYearCleared() bool {
	return m.clearedterm_year
}

// TermYearID returns the term_year id in the mutation.
func (m *TermMutation) TermYearID() (id int, exists bool) {
	if m.term_year != nil {
		return *m.term_year, true
	}
	return
}

// TermYearIDs returns the term_year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TermYearID instead. It exists only for internal usage by the builders.
func (m *TermMutation) TermYearIDs() (ids []int) {
	if id := m.term_year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTermYear reset all changes of the "term_year" edge.
func (m *TermMutation) ResetTermYear() {
	m.term_year = nil
	m.clearedterm_year = false
}

// Op returns the operation name.
func (m *TermMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Term).
func (m *TermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TermMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.semester != nil {
		fields = append(fields, term.FieldSemester)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case term.FieldSemester:
		return m.Semester()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case term.FieldSemester:
		return m.OldSemester(ctx)
	}
	return nil, fmt.Errorf("unknown Term field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case term.FieldSemester:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemester(v)
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TermMutation) AddedFields() []string {
	var fields []string
	if m.addsemester != nil {
		fields = append(fields, term.FieldSemester)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TermMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case term.FieldSemester:
		return m.AddedSemester()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) AddField(name string, value ent.Value) error {
	switch name {
	case term.FieldSemester:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSemester(v)
		return nil
	}
	return fmt.Errorf("unknown Term numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TermMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TermMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Term nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TermMutation) ResetField(name string) error {
	switch name {
	case term.FieldSemester:
		m.ResetSemester()
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TermMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.term_year != nil {
		edges = append(edges, term.EdgeTermYear)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case term.EdgeTermYear:
		if id := m.term_year; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TermMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedterm_year {
		edges = append(edges, term.EdgeTermYear)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TermMutation) EdgeCleared(name string) bool {
	switch name {
	case term.EdgeTermYear:
		return m.clearedterm_year
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TermMutation) ClearEdge(name string) error {
	switch name {
	case term.EdgeTermYear:
		m.ClearTermYear()
		return nil
	}
	return fmt.Errorf("unknown Term unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TermMutation) ResetEdge(name string) error {
	switch name {
	case term.EdgeTermYear:
		m.ResetTermYear()
		return nil
	}
	return fmt.Errorf("unknown Term edge %s", name)
}

// YearMutation represents an operation that mutate the Years
// nodes in the graph.
type YearMutation struct {
	config
	op               Op
	typ              string
	id               *int
	years            *int
	addyears         *int
	clearedFields    map[string]struct{}
	year_term        map[int]struct{}
	removedyear_term map[int]struct{}
	year_resu        map[int]struct{}
	removedyear_resu map[int]struct{}
	year_acti        map[int]struct{}
	removedyear_acti map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Year, error)
}

var _ ent.Mutation = (*YearMutation)(nil)

// yearOption allows to manage the mutation configuration using functional options.
type yearOption func(*YearMutation)

// newYearMutation creates new mutation for $n.Name.
func newYearMutation(c config, op Op, opts ...yearOption) *YearMutation {
	m := &YearMutation{
		config:        c,
		op:            op,
		typ:           TypeYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withYearID sets the id field of the mutation.
func withYearID(id int) yearOption {
	return func(m *YearMutation) {
		var (
			err   error
			once  sync.Once
			value *Year
		)
		m.oldValue = func(ctx context.Context) (*Year, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Year.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withYear sets the old Year of the mutation.
func withYear(node *Year) yearOption {
	return func(m *YearMutation) {
		m.oldValue = func(context.Context) (*Year, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m YearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m YearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *YearMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetYears sets the years field.
func (m *YearMutation) SetYears(i int) {
	m.years = &i
	m.addyears = nil
}

// Years returns the years value in the mutation.
func (m *YearMutation) Years() (r int, exists bool) {
	v := m.years
	if v == nil {
		return
	}
	return *v, true
}

// OldYears returns the old years value of the Year.
// If the Year object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *YearMutation) OldYears(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYears is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYears: %w", err)
	}
	return oldValue.Years, nil
}

// AddYears adds i to years.
func (m *YearMutation) AddYears(i int) {
	if m.addyears != nil {
		*m.addyears += i
	} else {
		m.addyears = &i
	}
}

// AddedYears returns the value that was added to the years field in this mutation.
func (m *YearMutation) AddedYears() (r int, exists bool) {
	v := m.addyears
	if v == nil {
		return
	}
	return *v, true
}

// ResetYears reset all changes of the "years" field.
func (m *YearMutation) ResetYears() {
	m.years = nil
	m.addyears = nil
}

// AddYearTermIDs adds the year_term edge to Term by ids.
func (m *YearMutation) AddYearTermIDs(ids ...int) {
	if m.year_term == nil {
		m.year_term = make(map[int]struct{})
	}
	for i := range ids {
		m.year_term[ids[i]] = struct{}{}
	}
}

// RemoveYearTermIDs removes the year_term edge to Term by ids.
func (m *YearMutation) RemoveYearTermIDs(ids ...int) {
	if m.removedyear_term == nil {
		m.removedyear_term = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_term[ids[i]] = struct{}{}
	}
}

// RemovedYearTerm returns the removed ids of year_term.
func (m *YearMutation) RemovedYearTermIDs() (ids []int) {
	for id := range m.removedyear_term {
		ids = append(ids, id)
	}
	return
}

// YearTermIDs returns the year_term ids in the mutation.
func (m *YearMutation) YearTermIDs() (ids []int) {
	for id := range m.year_term {
		ids = append(ids, id)
	}
	return
}

// ResetYearTerm reset all changes of the "year_term" edge.
func (m *YearMutation) ResetYearTerm() {
	m.year_term = nil
	m.removedyear_term = nil
}

// AddYearResuIDs adds the year_resu edge to Results by ids.
func (m *YearMutation) AddYearResuIDs(ids ...int) {
	if m.year_resu == nil {
		m.year_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.year_resu[ids[i]] = struct{}{}
	}
}

// RemoveYearResuIDs removes the year_resu edge to Results by ids.
func (m *YearMutation) RemoveYearResuIDs(ids ...int) {
	if m.removedyear_resu == nil {
		m.removedyear_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_resu[ids[i]] = struct{}{}
	}
}

// RemovedYearResu returns the removed ids of year_resu.
func (m *YearMutation) RemovedYearResuIDs() (ids []int) {
	for id := range m.removedyear_resu {
		ids = append(ids, id)
	}
	return
}

// YearResuIDs returns the year_resu ids in the mutation.
func (m *YearMutation) YearResuIDs() (ids []int) {
	for id := range m.year_resu {
		ids = append(ids, id)
	}
	return
}

// ResetYearResu reset all changes of the "year_resu" edge.
func (m *YearMutation) ResetYearResu() {
	m.year_resu = nil
	m.removedyear_resu = nil
}

// AddYearActiIDs adds the year_acti edge to Activity by ids.
func (m *YearMutation) AddYearActiIDs(ids ...int) {
	if m.year_acti == nil {
		m.year_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.year_acti[ids[i]] = struct{}{}
	}
}

// RemoveYearActiIDs removes the year_acti edge to Activity by ids.
func (m *YearMutation) RemoveYearActiIDs(ids ...int) {
	if m.removedyear_acti == nil {
		m.removedyear_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_acti[ids[i]] = struct{}{}
	}
}

// RemovedYearActi returns the removed ids of year_acti.
func (m *YearMutation) RemovedYearActiIDs() (ids []int) {
	for id := range m.removedyear_acti {
		ids = append(ids, id)
	}
	return
}

// YearActiIDs returns the year_acti ids in the mutation.
func (m *YearMutation) YearActiIDs() (ids []int) {
	for id := range m.year_acti {
		ids = append(ids, id)
	}
	return
}

// ResetYearActi reset all changes of the "year_acti" edge.
func (m *YearMutation) ResetYearActi() {
	m.year_acti = nil
	m.removedyear_acti = nil
}

// Op returns the operation name.
func (m *YearMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Year).
func (m *YearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *YearMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.years != nil {
		fields = append(fields, year.FieldYears)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *YearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYears:
		return m.Years()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *YearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case year.FieldYears:
		return m.OldYears(ctx)
	}
	return nil, fmt.Errorf("unknown Year field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case year.FieldYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYears(v)
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *YearMutation) AddedFields() []string {
	var fields []string
	if m.addyears != nil {
		fields = append(fields, year.FieldYears)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *YearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYears:
		return m.AddedYears()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case year.FieldYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYears(v)
		return nil
	}
	return fmt.Errorf("unknown Year numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *YearMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *YearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *YearMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Year nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *YearMutation) ResetField(name string) error {
	switch name {
	case year.FieldYears:
		m.ResetYears()
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *YearMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.year_term != nil {
		edges = append(edges, year.EdgeYearTerm)
	}
	if m.year_resu != nil {
		edges = append(edges, year.EdgeYearResu)
	}
	if m.year_acti != nil {
		edges = append(edges, year.EdgeYearActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *YearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeYearTerm:
		ids := make([]ent.Value, 0, len(m.year_term))
		for id := range m.year_term {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearResu:
		ids := make([]ent.Value, 0, len(m.year_resu))
		for id := range m.year_resu {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearActi:
		ids := make([]ent.Value, 0, len(m.year_acti))
		for id := range m.year_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *YearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedyear_term != nil {
		edges = append(edges, year.EdgeYearTerm)
	}
	if m.removedyear_resu != nil {
		edges = append(edges, year.EdgeYearResu)
	}
	if m.removedyear_acti != nil {
		edges = append(edges, year.EdgeYearActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *YearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeYearTerm:
		ids := make([]ent.Value, 0, len(m.removedyear_term))
		for id := range m.removedyear_term {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearResu:
		ids := make([]ent.Value, 0, len(m.removedyear_resu))
		for id := range m.removedyear_resu {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearActi:
		ids := make([]ent.Value, 0, len(m.removedyear_acti))
		for id := range m.removedyear_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *YearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *YearMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *YearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Year unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *YearMutation) ResetEdge(name string) error {
	switch name {
	case year.EdgeYearTerm:
		m.ResetYearTerm()
		return nil
	case year.EdgeYearResu:
		m.ResetYearResu()
		return nil
	case year.EdgeYearActi:
		m.ResetYearActi()
		return nil
	}
	return fmt.Errorf("unknown Year edge %s", name)
}
