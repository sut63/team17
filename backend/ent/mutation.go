// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/sut63/team17/app/ent/activity"
	"github.com/sut63/team17/app/ent/agency"
	"github.com/sut63/team17/app/ent/continent"
	"github.com/sut63/team17/app/ent/country"
	"github.com/sut63/team17/app/ent/course"
	"github.com/sut63/team17/app/ent/degree"
	"github.com/sut63/team17/app/ent/emp"
	"github.com/sut63/team17/app/ent/faculty"
	"github.com/sut63/team17/app/ent/gender"
	"github.com/sut63/team17/app/ent/institution"
	"github.com/sut63/team17/app/ent/place"
	"github.com/sut63/team17/app/ent/prefix"
	"github.com/sut63/team17/app/ent/professor"
	"github.com/sut63/team17/app/ent/professorship"
	"github.com/sut63/team17/app/ent/province"
	"github.com/sut63/team17/app/ent/region"
	"github.com/sut63/team17/app/ent/results"
	"github.com/sut63/team17/app/ent/student"
	"github.com/sut63/team17/app/ent/subject"
	"github.com/sut63/team17/app/ent/term"
	"github.com/sut63/team17/app/ent/year"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity      = "Activity"
	TypeAgency        = "Agency"
	TypeContinent     = "Continent"
	TypeCountry       = "Country"
	TypeCourse        = "Course"
	TypeDegree        = "Degree"
	TypeEmp           = "Emp"
	TypeFaculty       = "Faculty"
	TypeGender        = "Gender"
	TypeInstitution   = "Institution"
	TypePlace         = "Place"
	TypePrefix        = "Prefix"
	TypeProfessor     = "Professor"
	TypeProfessorship = "Professorship"
	TypeProvince      = "Province"
	TypeRegion        = "Region"
	TypeResults       = "Results"
	TypeStudent       = "Student"
	TypeSubject       = "Subject"
	TypeTerm          = "Term"
	TypeYear          = "Year"
)

// ActivityMutation represents an operation that mutate the Activities
// nodes in the graph.
type ActivityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_ACTIVITYNAME     *string
	added             *time.Time
	hours             *string
	clearedFields     map[string]struct{}
	acti_stud         *int
	clearedacti_stud  bool
	acti_place        *int
	clearedacti_place bool
	acti_agen         *int
	clearedacti_agen  bool
	acti_year         *int
	clearedacti_year  bool
	acti_term         *int
	clearedacti_term  bool
	done              bool
	oldValue          func(context.Context) (*Activity, error)
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows to manage the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for $n.Name.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the id field of the mutation.
func withActivityID(id int) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetACTIVITYNAME sets the ACTIVITYNAME field.
func (m *ActivityMutation) SetACTIVITYNAME(s string) {
	m._ACTIVITYNAME = &s
}

// ACTIVITYNAME returns the ACTIVITYNAME value in the mutation.
func (m *ActivityMutation) ACTIVITYNAME() (r string, exists bool) {
	v := m._ACTIVITYNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldACTIVITYNAME returns the old ACTIVITYNAME value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldACTIVITYNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldACTIVITYNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldACTIVITYNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldACTIVITYNAME: %w", err)
	}
	return oldValue.ACTIVITYNAME, nil
}

// ResetACTIVITYNAME reset all changes of the "ACTIVITYNAME" field.
func (m *ActivityMutation) ResetACTIVITYNAME() {
	m._ACTIVITYNAME = nil
}

// SetAdded sets the added field.
func (m *ActivityMutation) SetAdded(t time.Time) {
	m.added = &t
}

// Added returns the added value in the mutation.
func (m *ActivityMutation) Added() (r time.Time, exists bool) {
	v := m.added
	if v == nil {
		return
	}
	return *v, true
}

// OldAdded returns the old added value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldAdded(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdded is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdded: %w", err)
	}
	return oldValue.Added, nil
}

// ResetAdded reset all changes of the "added" field.
func (m *ActivityMutation) ResetAdded() {
	m.added = nil
}

// SetHours sets the hours field.
func (m *ActivityMutation) SetHours(s string) {
	m.hours = &s
}

// Hours returns the hours value in the mutation.
func (m *ActivityMutation) Hours() (r string, exists bool) {
	v := m.hours
	if v == nil {
		return
	}
	return *v, true
}

// OldHours returns the old hours value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldHours(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHours is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHours: %w", err)
	}
	return oldValue.Hours, nil
}

// ResetHours reset all changes of the "hours" field.
func (m *ActivityMutation) ResetHours() {
	m.hours = nil
}

// SetActiStudID sets the acti_stud edge to Student by id.
func (m *ActivityMutation) SetActiStudID(id int) {
	m.acti_stud = &id
}

// ClearActiStud clears the acti_stud edge to Student.
func (m *ActivityMutation) ClearActiStud() {
	m.clearedacti_stud = true
}

// ActiStudCleared returns if the edge acti_stud was cleared.
func (m *ActivityMutation) ActiStudCleared() bool {
	return m.clearedacti_stud
}

// ActiStudID returns the acti_stud id in the mutation.
func (m *ActivityMutation) ActiStudID() (id int, exists bool) {
	if m.acti_stud != nil {
		return *m.acti_stud, true
	}
	return
}

// ActiStudIDs returns the acti_stud ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiStudID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiStudIDs() (ids []int) {
	if id := m.acti_stud; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiStud reset all changes of the "acti_stud" edge.
func (m *ActivityMutation) ResetActiStud() {
	m.acti_stud = nil
	m.clearedacti_stud = false
}

// SetActiPlaceID sets the acti_place edge to Place by id.
func (m *ActivityMutation) SetActiPlaceID(id int) {
	m.acti_place = &id
}

// ClearActiPlace clears the acti_place edge to Place.
func (m *ActivityMutation) ClearActiPlace() {
	m.clearedacti_place = true
}

// ActiPlaceCleared returns if the edge acti_place was cleared.
func (m *ActivityMutation) ActiPlaceCleared() bool {
	return m.clearedacti_place
}

// ActiPlaceID returns the acti_place id in the mutation.
func (m *ActivityMutation) ActiPlaceID() (id int, exists bool) {
	if m.acti_place != nil {
		return *m.acti_place, true
	}
	return
}

// ActiPlaceIDs returns the acti_place ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiPlaceID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiPlaceIDs() (ids []int) {
	if id := m.acti_place; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiPlace reset all changes of the "acti_place" edge.
func (m *ActivityMutation) ResetActiPlace() {
	m.acti_place = nil
	m.clearedacti_place = false
}

// SetActiAgenID sets the acti_agen edge to Agency by id.
func (m *ActivityMutation) SetActiAgenID(id int) {
	m.acti_agen = &id
}

// ClearActiAgen clears the acti_agen edge to Agency.
func (m *ActivityMutation) ClearActiAgen() {
	m.clearedacti_agen = true
}

// ActiAgenCleared returns if the edge acti_agen was cleared.
func (m *ActivityMutation) ActiAgenCleared() bool {
	return m.clearedacti_agen
}

// ActiAgenID returns the acti_agen id in the mutation.
func (m *ActivityMutation) ActiAgenID() (id int, exists bool) {
	if m.acti_agen != nil {
		return *m.acti_agen, true
	}
	return
}

// ActiAgenIDs returns the acti_agen ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiAgenID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiAgenIDs() (ids []int) {
	if id := m.acti_agen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiAgen reset all changes of the "acti_agen" edge.
func (m *ActivityMutation) ResetActiAgen() {
	m.acti_agen = nil
	m.clearedacti_agen = false
}

// SetActiYearID sets the acti_year edge to Year by id.
func (m *ActivityMutation) SetActiYearID(id int) {
	m.acti_year = &id
}

// ClearActiYear clears the acti_year edge to Year.
func (m *ActivityMutation) ClearActiYear() {
	m.clearedacti_year = true
}

// ActiYearCleared returns if the edge acti_year was cleared.
func (m *ActivityMutation) ActiYearCleared() bool {
	return m.clearedacti_year
}

// ActiYearID returns the acti_year id in the mutation.
func (m *ActivityMutation) ActiYearID() (id int, exists bool) {
	if m.acti_year != nil {
		return *m.acti_year, true
	}
	return
}

// ActiYearIDs returns the acti_year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiYearID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiYearIDs() (ids []int) {
	if id := m.acti_year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiYear reset all changes of the "acti_year" edge.
func (m *ActivityMutation) ResetActiYear() {
	m.acti_year = nil
	m.clearedacti_year = false
}

// SetActiTermID sets the acti_term edge to Term by id.
func (m *ActivityMutation) SetActiTermID(id int) {
	m.acti_term = &id
}

// ClearActiTerm clears the acti_term edge to Term.
func (m *ActivityMutation) ClearActiTerm() {
	m.clearedacti_term = true
}

// ActiTermCleared returns if the edge acti_term was cleared.
func (m *ActivityMutation) ActiTermCleared() bool {
	return m.clearedacti_term
}

// ActiTermID returns the acti_term id in the mutation.
func (m *ActivityMutation) ActiTermID() (id int, exists bool) {
	if m.acti_term != nil {
		return *m.acti_term, true
	}
	return
}

// ActiTermIDs returns the acti_term ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiTermID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActiTermIDs() (ids []int) {
	if id := m.acti_term; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiTerm reset all changes of the "acti_term" edge.
func (m *ActivityMutation) ResetActiTerm() {
	m.acti_term = nil
	m.clearedacti_term = false
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._ACTIVITYNAME != nil {
		fields = append(fields, activity.FieldACTIVITYNAME)
	}
	if m.added != nil {
		fields = append(fields, activity.FieldAdded)
	}
	if m.hours != nil {
		fields = append(fields, activity.FieldHours)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldACTIVITYNAME:
		return m.ACTIVITYNAME()
	case activity.FieldAdded:
		return m.Added()
	case activity.FieldHours:
		return m.Hours()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldACTIVITYNAME:
		return m.OldACTIVITYNAME(ctx)
	case activity.FieldAdded:
		return m.OldAdded(ctx)
	case activity.FieldHours:
		return m.OldHours(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldACTIVITYNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetACTIVITYNAME(v)
		return nil
	case activity.FieldAdded:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdded(v)
		return nil
	case activity.FieldHours:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHours(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldACTIVITYNAME:
		m.ResetACTIVITYNAME()
		return nil
	case activity.FieldAdded:
		m.ResetAdded()
		return nil
	case activity.FieldHours:
		m.ResetHours()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.acti_stud != nil {
		edges = append(edges, activity.EdgeActiStud)
	}
	if m.acti_place != nil {
		edges = append(edges, activity.EdgeActiPlace)
	}
	if m.acti_agen != nil {
		edges = append(edges, activity.EdgeActiAgen)
	}
	if m.acti_year != nil {
		edges = append(edges, activity.EdgeActiYear)
	}
	if m.acti_term != nil {
		edges = append(edges, activity.EdgeActiTerm)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeActiStud:
		if id := m.acti_stud; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiPlace:
		if id := m.acti_place; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiAgen:
		if id := m.acti_agen; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiYear:
		if id := m.acti_year; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeActiTerm:
		if id := m.acti_term; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedacti_stud {
		edges = append(edges, activity.EdgeActiStud)
	}
	if m.clearedacti_place {
		edges = append(edges, activity.EdgeActiPlace)
	}
	if m.clearedacti_agen {
		edges = append(edges, activity.EdgeActiAgen)
	}
	if m.clearedacti_year {
		edges = append(edges, activity.EdgeActiYear)
	}
	if m.clearedacti_term {
		edges = append(edges, activity.EdgeActiTerm)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeActiStud:
		return m.clearedacti_stud
	case activity.EdgeActiPlace:
		return m.clearedacti_place
	case activity.EdgeActiAgen:
		return m.clearedacti_agen
	case activity.EdgeActiYear:
		return m.clearedacti_year
	case activity.EdgeActiTerm:
		return m.clearedacti_term
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeActiStud:
		m.ClearActiStud()
		return nil
	case activity.EdgeActiPlace:
		m.ClearActiPlace()
		return nil
	case activity.EdgeActiAgen:
		m.ClearActiAgen()
		return nil
	case activity.EdgeActiYear:
		m.ClearActiYear()
		return nil
	case activity.EdgeActiTerm:
		m.ClearActiTerm()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeActiStud:
		m.ResetActiStud()
		return nil
	case activity.EdgeActiPlace:
		m.ResetActiPlace()
		return nil
	case activity.EdgeActiAgen:
		m.ResetActiAgen()
		return nil
	case activity.EdgeActiYear:
		m.ResetActiYear()
		return nil
	case activity.EdgeActiTerm:
		m.ResetActiTerm()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// AgencyMutation represents an operation that mutate the Agencies
// nodes in the graph.
type AgencyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_AGENCY          *string
	clearedFields    map[string]struct{}
	agen_acti        map[int]struct{}
	removedagen_acti map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Agency, error)
}

var _ ent.Mutation = (*AgencyMutation)(nil)

// agencyOption allows to manage the mutation configuration using functional options.
type agencyOption func(*AgencyMutation)

// newAgencyMutation creates new mutation for $n.Name.
func newAgencyMutation(c config, op Op, opts ...agencyOption) *AgencyMutation {
	m := &AgencyMutation{
		config:        c,
		op:            op,
		typ:           TypeAgency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgencyID sets the id field of the mutation.
func withAgencyID(id int) agencyOption {
	return func(m *AgencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Agency
		)
		m.oldValue = func(ctx context.Context) (*Agency, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgency sets the old Agency of the mutation.
func withAgency(node *Agency) agencyOption {
	return func(m *AgencyMutation) {
		m.oldValue = func(context.Context) (*Agency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AgencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAGENCY sets the AGENCY field.
func (m *AgencyMutation) SetAGENCY(s string) {
	m._AGENCY = &s
}

// AGENCY returns the AGENCY value in the mutation.
func (m *AgencyMutation) AGENCY() (r string, exists bool) {
	v := m._AGENCY
	if v == nil {
		return
	}
	return *v, true
}

// OldAGENCY returns the old AGENCY value of the Agency.
// If the Agency object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AgencyMutation) OldAGENCY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAGENCY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAGENCY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAGENCY: %w", err)
	}
	return oldValue.AGENCY, nil
}

// ResetAGENCY reset all changes of the "AGENCY" field.
func (m *AgencyMutation) ResetAGENCY() {
	m._AGENCY = nil
}

// AddAgenActiIDs adds the agen_acti edge to Activity by ids.
func (m *AgencyMutation) AddAgenActiIDs(ids ...int) {
	if m.agen_acti == nil {
		m.agen_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.agen_acti[ids[i]] = struct{}{}
	}
}

// RemoveAgenActiIDs removes the agen_acti edge to Activity by ids.
func (m *AgencyMutation) RemoveAgenActiIDs(ids ...int) {
	if m.removedagen_acti == nil {
		m.removedagen_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedagen_acti[ids[i]] = struct{}{}
	}
}

// RemovedAgenActi returns the removed ids of agen_acti.
func (m *AgencyMutation) RemovedAgenActiIDs() (ids []int) {
	for id := range m.removedagen_acti {
		ids = append(ids, id)
	}
	return
}

// AgenActiIDs returns the agen_acti ids in the mutation.
func (m *AgencyMutation) AgenActiIDs() (ids []int) {
	for id := range m.agen_acti {
		ids = append(ids, id)
	}
	return
}

// ResetAgenActi reset all changes of the "agen_acti" edge.
func (m *AgencyMutation) ResetAgenActi() {
	m.agen_acti = nil
	m.removedagen_acti = nil
}

// Op returns the operation name.
func (m *AgencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agency).
func (m *AgencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AgencyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AGENCY != nil {
		fields = append(fields, agency.FieldAGENCY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AgencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agency.FieldAGENCY:
		return m.AGENCY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AgencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agency.FieldAGENCY:
		return m.OldAGENCY(ctx)
	}
	return nil, fmt.Errorf("unknown Agency field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agency.FieldAGENCY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAGENCY(v)
		return nil
	}
	return fmt.Errorf("unknown Agency field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AgencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AgencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AgencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AgencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AgencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agency nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AgencyMutation) ResetField(name string) error {
	switch name {
	case agency.FieldAGENCY:
		m.ResetAGENCY()
		return nil
	}
	return fmt.Errorf("unknown Agency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AgencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agen_acti != nil {
		edges = append(edges, agency.EdgeAgenActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AgencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agency.EdgeAgenActi:
		ids := make([]ent.Value, 0, len(m.agen_acti))
		for id := range m.agen_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AgencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedagen_acti != nil {
		edges = append(edges, agency.EdgeAgenActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AgencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agency.EdgeAgenActi:
		ids := make([]ent.Value, 0, len(m.removedagen_acti))
		for id := range m.removedagen_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AgencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AgencyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AgencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Agency unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AgencyMutation) ResetEdge(name string) error {
	switch name {
	case agency.EdgeAgenActi:
		m.ResetAgenActi()
		return nil
	}
	return fmt.Errorf("unknown Agency edge %s", name)
}

// ContinentMutation represents an operation that mutate the Continents
// nodes in the graph.
type ContinentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	continent        *string
	clearedFields    map[string]struct{}
	cont_prov        map[int]struct{}
	removedcont_prov map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Continent, error)
}

var _ ent.Mutation = (*ContinentMutation)(nil)

// continentOption allows to manage the mutation configuration using functional options.
type continentOption func(*ContinentMutation)

// newContinentMutation creates new mutation for $n.Name.
func newContinentMutation(c config, op Op, opts ...continentOption) *ContinentMutation {
	m := &ContinentMutation{
		config:        c,
		op:            op,
		typ:           TypeContinent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContinentID sets the id field of the mutation.
func withContinentID(id int) continentOption {
	return func(m *ContinentMutation) {
		var (
			err   error
			once  sync.Once
			value *Continent
		)
		m.oldValue = func(ctx context.Context) (*Continent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Continent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContinent sets the old Continent of the mutation.
func withContinent(node *Continent) continentOption {
	return func(m *ContinentMutation) {
		m.oldValue = func(context.Context) (*Continent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContinentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContinentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ContinentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetContinent sets the continent field.
func (m *ContinentMutation) SetContinent(s string) {
	m.continent = &s
}

// Continent returns the continent value in the mutation.
func (m *ContinentMutation) Continent() (r string, exists bool) {
	v := m.continent
	if v == nil {
		return
	}
	return *v, true
}

// OldContinent returns the old continent value of the Continent.
// If the Continent object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ContinentMutation) OldContinent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContinent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContinent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinent: %w", err)
	}
	return oldValue.Continent, nil
}

// ResetContinent reset all changes of the "continent" field.
func (m *ContinentMutation) ResetContinent() {
	m.continent = nil
}

// AddContProvIDs adds the cont_prov edge to Province by ids.
func (m *ContinentMutation) AddContProvIDs(ids ...int) {
	if m.cont_prov == nil {
		m.cont_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.cont_prov[ids[i]] = struct{}{}
	}
}

// RemoveContProvIDs removes the cont_prov edge to Province by ids.
func (m *ContinentMutation) RemoveContProvIDs(ids ...int) {
	if m.removedcont_prov == nil {
		m.removedcont_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcont_prov[ids[i]] = struct{}{}
	}
}

// RemovedContProv returns the removed ids of cont_prov.
func (m *ContinentMutation) RemovedContProvIDs() (ids []int) {
	for id := range m.removedcont_prov {
		ids = append(ids, id)
	}
	return
}

// ContProvIDs returns the cont_prov ids in the mutation.
func (m *ContinentMutation) ContProvIDs() (ids []int) {
	for id := range m.cont_prov {
		ids = append(ids, id)
	}
	return
}

// ResetContProv reset all changes of the "cont_prov" edge.
func (m *ContinentMutation) ResetContProv() {
	m.cont_prov = nil
	m.removedcont_prov = nil
}

// Op returns the operation name.
func (m *ContinentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Continent).
func (m *ContinentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ContinentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.continent != nil {
		fields = append(fields, continent.FieldContinent)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ContinentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case continent.FieldContinent:
		return m.Continent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ContinentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case continent.FieldContinent:
		return m.OldContinent(ctx)
	}
	return nil, fmt.Errorf("unknown Continent field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ContinentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case continent.FieldContinent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinent(v)
		return nil
	}
	return fmt.Errorf("unknown Continent field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ContinentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ContinentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ContinentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Continent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ContinentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ContinentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContinentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Continent nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ContinentMutation) ResetField(name string) error {
	switch name {
	case continent.FieldContinent:
		m.ResetContinent()
		return nil
	}
	return fmt.Errorf("unknown Continent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ContinentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cont_prov != nil {
		edges = append(edges, continent.EdgeContProv)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ContinentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case continent.EdgeContProv:
		ids := make([]ent.Value, 0, len(m.cont_prov))
		for id := range m.cont_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ContinentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcont_prov != nil {
		edges = append(edges, continent.EdgeContProv)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ContinentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case continent.EdgeContProv:
		ids := make([]ent.Value, 0, len(m.removedcont_prov))
		for id := range m.removedcont_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ContinentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ContinentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ContinentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Continent unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ContinentMutation) ResetEdge(name string) error {
	switch name {
	case continent.EdgeContProv:
		m.ResetContProv()
		return nil
	}
	return fmt.Errorf("unknown Continent edge %s", name)
}

// CountryMutation represents an operation that mutate the Countries
// nodes in the graph.
type CountryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	country          *string
	clearedFields    map[string]struct{}
	coun_prov        map[int]struct{}
	removedcoun_prov map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Country, error)
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows to manage the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for $n.Name.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the id field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCountry sets the country field.
func (m *CountryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the country value in the mutation.
func (m *CountryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old country value of the Country.
// If the Country object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CountryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry reset all changes of the "country" field.
func (m *CountryMutation) ResetCountry() {
	m.country = nil
}

// AddCounProvIDs adds the coun_prov edge to Province by ids.
func (m *CountryMutation) AddCounProvIDs(ids ...int) {
	if m.coun_prov == nil {
		m.coun_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.coun_prov[ids[i]] = struct{}{}
	}
}

// RemoveCounProvIDs removes the coun_prov edge to Province by ids.
func (m *CountryMutation) RemoveCounProvIDs(ids ...int) {
	if m.removedcoun_prov == nil {
		m.removedcoun_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcoun_prov[ids[i]] = struct{}{}
	}
}

// RemovedCounProv returns the removed ids of coun_prov.
func (m *CountryMutation) RemovedCounProvIDs() (ids []int) {
	for id := range m.removedcoun_prov {
		ids = append(ids, id)
	}
	return
}

// CounProvIDs returns the coun_prov ids in the mutation.
func (m *CountryMutation) CounProvIDs() (ids []int) {
	for id := range m.coun_prov {
		ids = append(ids, id)
	}
	return
}

// ResetCounProv reset all changes of the "coun_prov" edge.
func (m *CountryMutation) ResetCounProv() {
	m.coun_prov = nil
	m.removedcoun_prov = nil
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.country != nil {
		fields = append(fields, country.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coun_prov != nil {
		edges = append(edges, country.EdgeCounProv)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeCounProv:
		ids := make([]ent.Value, 0, len(m.coun_prov))
		for id := range m.coun_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcoun_prov != nil {
		edges = append(edges, country.EdgeCounProv)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeCounProv:
		ids := make([]ent.Value, 0, len(m.removedcoun_prov))
		for id := range m.removedcoun_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeCounProv:
		m.ResetCounProv()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	course           *string
	clearedFields    map[string]struct{}
	cour_facu        *int
	clearedcour_facu bool
	cour_degr        *int
	clearedcour_degr bool
	cour_inst        *int
	clearedcour_inst bool
	done             bool
	oldValue         func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourse sets the course field.
func (m *CourseMutation) SetCourse(s string) {
	m.course = &s
}

// Course returns the course value in the mutation.
func (m *CourseMutation) Course() (r string, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourse returns the old course value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCourse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourse: %w", err)
	}
	return oldValue.Course, nil
}

// ResetCourse reset all changes of the "course" field.
func (m *CourseMutation) ResetCourse() {
	m.course = nil
}

// SetCourFacuID sets the cour_facu edge to Faculty by id.
func (m *CourseMutation) SetCourFacuID(id int) {
	m.cour_facu = &id
}

// ClearCourFacu clears the cour_facu edge to Faculty.
func (m *CourseMutation) ClearCourFacu() {
	m.clearedcour_facu = true
}

// CourFacuCleared returns if the edge cour_facu was cleared.
func (m *CourseMutation) CourFacuCleared() bool {
	return m.clearedcour_facu
}

// CourFacuID returns the cour_facu id in the mutation.
func (m *CourseMutation) CourFacuID() (id int, exists bool) {
	if m.cour_facu != nil {
		return *m.cour_facu, true
	}
	return
}

// CourFacuIDs returns the cour_facu ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourFacuID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourFacuIDs() (ids []int) {
	if id := m.cour_facu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourFacu reset all changes of the "cour_facu" edge.
func (m *CourseMutation) ResetCourFacu() {
	m.cour_facu = nil
	m.clearedcour_facu = false
}

// SetCourDegrID sets the cour_degr edge to Degree by id.
func (m *CourseMutation) SetCourDegrID(id int) {
	m.cour_degr = &id
}

// ClearCourDegr clears the cour_degr edge to Degree.
func (m *CourseMutation) ClearCourDegr() {
	m.clearedcour_degr = true
}

// CourDegrCleared returns if the edge cour_degr was cleared.
func (m *CourseMutation) CourDegrCleared() bool {
	return m.clearedcour_degr
}

// CourDegrID returns the cour_degr id in the mutation.
func (m *CourseMutation) CourDegrID() (id int, exists bool) {
	if m.cour_degr != nil {
		return *m.cour_degr, true
	}
	return
}

// CourDegrIDs returns the cour_degr ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourDegrID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourDegrIDs() (ids []int) {
	if id := m.cour_degr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourDegr reset all changes of the "cour_degr" edge.
func (m *CourseMutation) ResetCourDegr() {
	m.cour_degr = nil
	m.clearedcour_degr = false
}

// SetCourInstID sets the cour_inst edge to Institution by id.
func (m *CourseMutation) SetCourInstID(id int) {
	m.cour_inst = &id
}

// ClearCourInst clears the cour_inst edge to Institution.
func (m *CourseMutation) ClearCourInst() {
	m.clearedcour_inst = true
}

// CourInstCleared returns if the edge cour_inst was cleared.
func (m *CourseMutation) CourInstCleared() bool {
	return m.clearedcour_inst
}

// CourInstID returns the cour_inst id in the mutation.
func (m *CourseMutation) CourInstID() (id int, exists bool) {
	if m.cour_inst != nil {
		return *m.cour_inst, true
	}
	return
}

// CourInstIDs returns the cour_inst ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourInstID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CourInstIDs() (ids []int) {
	if id := m.cour_inst; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourInst reset all changes of the "cour_inst" edge.
func (m *CourseMutation) ResetCourInst() {
	m.cour_inst = nil
	m.clearedcour_inst = false
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.course != nil {
		fields = append(fields, course.FieldCourse)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCourse:
		return m.Course()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCourse:
		return m.OldCourse(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCourse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourse(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cour_facu != nil {
		edges = append(edges, course.EdgeCourFacu)
	}
	if m.cour_degr != nil {
		edges = append(edges, course.EdgeCourDegr)
	}
	if m.cour_inst != nil {
		edges = append(edges, course.EdgeCourInst)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourFacu:
		if id := m.cour_facu; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourDegr:
		if id := m.cour_degr; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourInst:
		if id := m.cour_inst; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcour_facu {
		edges = append(edges, course.EdgeCourFacu)
	}
	if m.clearedcour_degr {
		edges = append(edges, course.EdgeCourDegr)
	}
	if m.clearedcour_inst {
		edges = append(edges, course.EdgeCourInst)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeCourFacu:
		return m.clearedcour_facu
	case course.EdgeCourDegr:
		return m.clearedcour_degr
	case course.EdgeCourInst:
		return m.clearedcour_inst
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeCourFacu:
		m.ClearCourFacu()
		return nil
	case course.EdgeCourDegr:
		m.ClearCourDegr()
		return nil
	case course.EdgeCourInst:
		m.ClearCourInst()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeCourFacu:
		m.ResetCourFacu()
		return nil
	case course.EdgeCourDegr:
		m.ResetCourDegr()
		return nil
	case course.EdgeCourInst:
		m.ResetCourInst()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DegreeMutation represents an operation that mutate the Degrees
// nodes in the graph.
type DegreeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	degree           *string
	clearedFields    map[string]struct{}
	degr_stud        map[int]struct{}
	removeddegr_stud map[int]struct{}
	degr_cour        map[int]struct{}
	removeddegr_cour map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Degree, error)
}

var _ ent.Mutation = (*DegreeMutation)(nil)

// degreeOption allows to manage the mutation configuration using functional options.
type degreeOption func(*DegreeMutation)

// newDegreeMutation creates new mutation for $n.Name.
func newDegreeMutation(c config, op Op, opts ...degreeOption) *DegreeMutation {
	m := &DegreeMutation{
		config:        c,
		op:            op,
		typ:           TypeDegree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDegreeID sets the id field of the mutation.
func withDegreeID(id int) degreeOption {
	return func(m *DegreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Degree
		)
		m.oldValue = func(ctx context.Context) (*Degree, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Degree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDegree sets the old Degree of the mutation.
func withDegree(node *Degree) degreeOption {
	return func(m *DegreeMutation) {
		m.oldValue = func(context.Context) (*Degree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DegreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DegreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DegreeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDegree sets the degree field.
func (m *DegreeMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the degree value in the mutation.
func (m *DegreeMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old degree value of the Degree.
// If the Degree object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DegreeMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDegree is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ResetDegree reset all changes of the "degree" field.
func (m *DegreeMutation) ResetDegree() {
	m.degree = nil
}

// AddDegrStudIDs adds the degr_stud edge to Student by ids.
func (m *DegreeMutation) AddDegrStudIDs(ids ...int) {
	if m.degr_stud == nil {
		m.degr_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.degr_stud[ids[i]] = struct{}{}
	}
}

// RemoveDegrStudIDs removes the degr_stud edge to Student by ids.
func (m *DegreeMutation) RemoveDegrStudIDs(ids ...int) {
	if m.removeddegr_stud == nil {
		m.removeddegr_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegr_stud[ids[i]] = struct{}{}
	}
}

// RemovedDegrStud returns the removed ids of degr_stud.
func (m *DegreeMutation) RemovedDegrStudIDs() (ids []int) {
	for id := range m.removeddegr_stud {
		ids = append(ids, id)
	}
	return
}

// DegrStudIDs returns the degr_stud ids in the mutation.
func (m *DegreeMutation) DegrStudIDs() (ids []int) {
	for id := range m.degr_stud {
		ids = append(ids, id)
	}
	return
}

// ResetDegrStud reset all changes of the "degr_stud" edge.
func (m *DegreeMutation) ResetDegrStud() {
	m.degr_stud = nil
	m.removeddegr_stud = nil
}

// AddDegrCourIDs adds the degr_cour edge to Course by ids.
func (m *DegreeMutation) AddDegrCourIDs(ids ...int) {
	if m.degr_cour == nil {
		m.degr_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.degr_cour[ids[i]] = struct{}{}
	}
}

// RemoveDegrCourIDs removes the degr_cour edge to Course by ids.
func (m *DegreeMutation) RemoveDegrCourIDs(ids ...int) {
	if m.removeddegr_cour == nil {
		m.removeddegr_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegr_cour[ids[i]] = struct{}{}
	}
}

// RemovedDegrCour returns the removed ids of degr_cour.
func (m *DegreeMutation) RemovedDegrCourIDs() (ids []int) {
	for id := range m.removeddegr_cour {
		ids = append(ids, id)
	}
	return
}

// DegrCourIDs returns the degr_cour ids in the mutation.
func (m *DegreeMutation) DegrCourIDs() (ids []int) {
	for id := range m.degr_cour {
		ids = append(ids, id)
	}
	return
}

// ResetDegrCour reset all changes of the "degr_cour" edge.
func (m *DegreeMutation) ResetDegrCour() {
	m.degr_cour = nil
	m.removeddegr_cour = nil
}

// Op returns the operation name.
func (m *DegreeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Degree).
func (m *DegreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DegreeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.degree != nil {
		fields = append(fields, degree.FieldDegree)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DegreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case degree.FieldDegree:
		return m.Degree()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DegreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case degree.FieldDegree:
		return m.OldDegree(ctx)
	}
	return nil, fmt.Errorf("unknown Degree field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case degree.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DegreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DegreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DegreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DegreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DegreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Degree nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DegreeMutation) ResetField(name string) error {
	switch name {
	case degree.FieldDegree:
		m.ResetDegree()
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DegreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.degr_stud != nil {
		edges = append(edges, degree.EdgeDegrStud)
	}
	if m.degr_cour != nil {
		edges = append(edges, degree.EdgeDegrCour)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DegreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegrStud:
		ids := make([]ent.Value, 0, len(m.degr_stud))
		for id := range m.degr_stud {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeDegrCour:
		ids := make([]ent.Value, 0, len(m.degr_cour))
		for id := range m.degr_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DegreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddegr_stud != nil {
		edges = append(edges, degree.EdgeDegrStud)
	}
	if m.removeddegr_cour != nil {
		edges = append(edges, degree.EdgeDegrCour)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DegreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegrStud:
		ids := make([]ent.Value, 0, len(m.removeddegr_stud))
		for id := range m.removeddegr_stud {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeDegrCour:
		ids := make([]ent.Value, 0, len(m.removeddegr_cour))
		for id := range m.removeddegr_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DegreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DegreeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DegreeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DegreeMutation) ResetEdge(name string) error {
	switch name {
	case degree.EdgeDegrStud:
		m.ResetDegrStud()
		return nil
	case degree.EdgeDegrCour:
		m.ResetDegrCour()
		return nil
	}
	return fmt.Errorf("unknown Degree edge %s", name)
}

// EmpMutation represents an operation that mutate the Emps
// nodes in the graph.
type EmpMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user          *string
	pass          *string
	role          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Emp, error)
}

var _ ent.Mutation = (*EmpMutation)(nil)

// empOption allows to manage the mutation configuration using functional options.
type empOption func(*EmpMutation)

// newEmpMutation creates new mutation for $n.Name.
func newEmpMutation(c config, op Op, opts ...empOption) *EmpMutation {
	m := &EmpMutation{
		config:        c,
		op:            op,
		typ:           TypeEmp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmpID sets the id field of the mutation.
func withEmpID(id int) empOption {
	return func(m *EmpMutation) {
		var (
			err   error
			once  sync.Once
			value *Emp
		)
		m.oldValue = func(ctx context.Context) (*Emp, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmp sets the old Emp of the mutation.
func withEmp(node *Emp) empOption {
	return func(m *EmpMutation) {
		m.oldValue = func(context.Context) (*Emp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmpMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUser sets the user field.
func (m *EmpMutation) SetUser(s string) {
	m.user = &s
}

// User returns the user value in the mutation.
func (m *EmpMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old user value of the Emp.
// If the Emp object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmpMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser reset all changes of the "user" field.
func (m *EmpMutation) ResetUser() {
	m.user = nil
}

// SetPass sets the pass field.
func (m *EmpMutation) SetPass(s string) {
	m.pass = &s
}

// Pass returns the pass value in the mutation.
func (m *EmpMutation) Pass() (r string, exists bool) {
	v := m.pass
	if v == nil {
		return
	}
	return *v, true
}

// OldPass returns the old pass value of the Emp.
// If the Emp object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmpMutation) OldPass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPass is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPass: %w", err)
	}
	return oldValue.Pass, nil
}

// ResetPass reset all changes of the "pass" field.
func (m *EmpMutation) ResetPass() {
	m.pass = nil
}

// SetRole sets the role field.
func (m *EmpMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the role value in the mutation.
func (m *EmpMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the Emp.
// If the Emp object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmpMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole reset all changes of the "role" field.
func (m *EmpMutation) ResetRole() {
	m.role = nil
}

// Op returns the operation name.
func (m *EmpMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Emp).
func (m *EmpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmpMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, emp.FieldUser)
	}
	if m.pass != nil {
		fields = append(fields, emp.FieldPass)
	}
	if m.role != nil {
		fields = append(fields, emp.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emp.FieldUser:
		return m.User()
	case emp.FieldPass:
		return m.Pass()
	case emp.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emp.FieldUser:
		return m.OldUser(ctx)
	case emp.FieldPass:
		return m.OldPass(ctx)
	case emp.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown Emp field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emp.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case emp.FieldPass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPass(v)
		return nil
	case emp.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown Emp field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmpMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmpMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmpMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Emp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmpMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmpMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Emp nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmpMutation) ResetField(name string) error {
	switch name {
	case emp.FieldUser:
		m.ResetUser()
		return nil
	case emp.FieldPass:
		m.ResetPass()
		return nil
	case emp.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Emp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmpMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmpMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmpMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmpMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Emp unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmpMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Emp edge %s", name)
}

// FacultyMutation represents an operation that mutate the Faculties
// nodes in the graph.
type FacultyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	faculty          *string
	clearedFields    map[string]struct{}
	facu_cour        map[int]struct{}
	removedfacu_cour map[int]struct{}
	facu_prof        map[int]struct{}
	removedfacu_prof map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Faculty, error)
}

var _ ent.Mutation = (*FacultyMutation)(nil)

// facultyOption allows to manage the mutation configuration using functional options.
type facultyOption func(*FacultyMutation)

// newFacultyMutation creates new mutation for $n.Name.
func newFacultyMutation(c config, op Op, opts ...facultyOption) *FacultyMutation {
	m := &FacultyMutation{
		config:        c,
		op:            op,
		typ:           TypeFaculty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacultyID sets the id field of the mutation.
func withFacultyID(id int) facultyOption {
	return func(m *FacultyMutation) {
		var (
			err   error
			once  sync.Once
			value *Faculty
		)
		m.oldValue = func(ctx context.Context) (*Faculty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faculty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaculty sets the old Faculty of the mutation.
func withFaculty(node *Faculty) facultyOption {
	return func(m *FacultyMutation) {
		m.oldValue = func(context.Context) (*Faculty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFaculty sets the faculty field.
func (m *FacultyMutation) SetFaculty(s string) {
	m.faculty = &s
}

// Faculty returns the faculty value in the mutation.
func (m *FacultyMutation) Faculty() (r string, exists bool) {
	v := m.faculty
	if v == nil {
		return
	}
	return *v, true
}

// OldFaculty returns the old faculty value of the Faculty.
// If the Faculty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacultyMutation) OldFaculty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFaculty is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFaculty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaculty: %w", err)
	}
	return oldValue.Faculty, nil
}

// ResetFaculty reset all changes of the "faculty" field.
func (m *FacultyMutation) ResetFaculty() {
	m.faculty = nil
}

// AddFacuCourIDs adds the facu_cour edge to Course by ids.
func (m *FacultyMutation) AddFacuCourIDs(ids ...int) {
	if m.facu_cour == nil {
		m.facu_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.facu_cour[ids[i]] = struct{}{}
	}
}

// RemoveFacuCourIDs removes the facu_cour edge to Course by ids.
func (m *FacultyMutation) RemoveFacuCourIDs(ids ...int) {
	if m.removedfacu_cour == nil {
		m.removedfacu_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfacu_cour[ids[i]] = struct{}{}
	}
}

// RemovedFacuCour returns the removed ids of facu_cour.
func (m *FacultyMutation) RemovedFacuCourIDs() (ids []int) {
	for id := range m.removedfacu_cour {
		ids = append(ids, id)
	}
	return
}

// FacuCourIDs returns the facu_cour ids in the mutation.
func (m *FacultyMutation) FacuCourIDs() (ids []int) {
	for id := range m.facu_cour {
		ids = append(ids, id)
	}
	return
}

// ResetFacuCour reset all changes of the "facu_cour" edge.
func (m *FacultyMutation) ResetFacuCour() {
	m.facu_cour = nil
	m.removedfacu_cour = nil
}

// AddFacuProfIDs adds the facu_prof edge to Professor by ids.
func (m *FacultyMutation) AddFacuProfIDs(ids ...int) {
	if m.facu_prof == nil {
		m.facu_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.facu_prof[ids[i]] = struct{}{}
	}
}

// RemoveFacuProfIDs removes the facu_prof edge to Professor by ids.
func (m *FacultyMutation) RemoveFacuProfIDs(ids ...int) {
	if m.removedfacu_prof == nil {
		m.removedfacu_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfacu_prof[ids[i]] = struct{}{}
	}
}

// RemovedFacuProf returns the removed ids of facu_prof.
func (m *FacultyMutation) RemovedFacuProfIDs() (ids []int) {
	for id := range m.removedfacu_prof {
		ids = append(ids, id)
	}
	return
}

// FacuProfIDs returns the facu_prof ids in the mutation.
func (m *FacultyMutation) FacuProfIDs() (ids []int) {
	for id := range m.facu_prof {
		ids = append(ids, id)
	}
	return
}

// ResetFacuProf reset all changes of the "facu_prof" edge.
func (m *FacultyMutation) ResetFacuProf() {
	m.facu_prof = nil
	m.removedfacu_prof = nil
}

// Op returns the operation name.
func (m *FacultyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Faculty).
func (m *FacultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacultyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.faculty != nil {
		fields = append(fields, faculty.FieldFaculty)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faculty.FieldFaculty:
		return m.Faculty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faculty.FieldFaculty:
		return m.OldFaculty(ctx)
	}
	return nil, fmt.Errorf("unknown Faculty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faculty.FieldFaculty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaculty(v)
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacultyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacultyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacultyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacultyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Faculty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacultyMutation) ResetField(name string) error {
	switch name {
	case faculty.FieldFaculty:
		m.ResetFaculty()
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.facu_cour != nil {
		edges = append(edges, faculty.EdgeFacuCour)
	}
	if m.facu_prof != nil {
		edges = append(edges, faculty.EdgeFacuProf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacultyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeFacuCour:
		ids := make([]ent.Value, 0, len(m.facu_cour))
		for id := range m.facu_cour {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeFacuProf:
		ids := make([]ent.Value, 0, len(m.facu_prof))
		for id := range m.facu_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfacu_cour != nil {
		edges = append(edges, faculty.EdgeFacuCour)
	}
	if m.removedfacu_prof != nil {
		edges = append(edges, faculty.EdgeFacuProf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacultyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeFacuCour:
		ids := make([]ent.Value, 0, len(m.removedfacu_cour))
		for id := range m.removedfacu_cour {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeFacuProf:
		ids := make([]ent.Value, 0, len(m.removedfacu_prof))
		for id := range m.removedfacu_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacultyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacultyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacultyMutation) ResetEdge(name string) error {
	switch name {
	case faculty.EdgeFacuCour:
		m.ResetFacuCour()
		return nil
	case faculty.EdgeFacuProf:
		m.ResetFacuProf()
		return nil
	}
	return fmt.Errorf("unknown Faculty edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op               Op
	typ              string
	id               *int
	gender           *string
	clearedFields    map[string]struct{}
	gend_stud        map[int]struct{}
	removedgend_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGender sets the gender field.
func (m *GenderMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *GenderMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *GenderMutation) ResetGender() {
	m.gender = nil
}

// AddGendStudIDs adds the gend_stud edge to Student by ids.
func (m *GenderMutation) AddGendStudIDs(ids ...int) {
	if m.gend_stud == nil {
		m.gend_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.gend_stud[ids[i]] = struct{}{}
	}
}

// RemoveGendStudIDs removes the gend_stud edge to Student by ids.
func (m *GenderMutation) RemoveGendStudIDs(ids ...int) {
	if m.removedgend_stud == nil {
		m.removedgend_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgend_stud[ids[i]] = struct{}{}
	}
}

// RemovedGendStud returns the removed ids of gend_stud.
func (m *GenderMutation) RemovedGendStudIDs() (ids []int) {
	for id := range m.removedgend_stud {
		ids = append(ids, id)
	}
	return
}

// GendStudIDs returns the gend_stud ids in the mutation.
func (m *GenderMutation) GendStudIDs() (ids []int) {
	for id := range m.gend_stud {
		ids = append(ids, id)
	}
	return
}

// ResetGendStud reset all changes of the "gend_stud" edge.
func (m *GenderMutation) ResetGendStud() {
	m.gend_stud = nil
	m.removedgend_stud = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender != nil {
		fields = append(fields, gender.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.gend_stud != nil {
		edges = append(edges, gender.EdgeGendStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGendStud:
		ids := make([]ent.Value, 0, len(m.gend_stud))
		for id := range m.gend_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgend_stud != nil {
		edges = append(edges, gender.EdgeGendStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeGendStud:
		ids := make([]ent.Value, 0, len(m.removedgend_stud))
		for id := range m.removedgend_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeGendStud:
		m.ResetGendStud()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// InstitutionMutation represents an operation that mutate the Institutions
// nodes in the graph.
type InstitutionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	institution      *string
	clearedFields    map[string]struct{}
	inst_cour        map[int]struct{}
	removedinst_cour map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Institution, error)
}

var _ ent.Mutation = (*InstitutionMutation)(nil)

// institutionOption allows to manage the mutation configuration using functional options.
type institutionOption func(*InstitutionMutation)

// newInstitutionMutation creates new mutation for $n.Name.
func newInstitutionMutation(c config, op Op, opts ...institutionOption) *InstitutionMutation {
	m := &InstitutionMutation{
		config:        c,
		op:            op,
		typ:           TypeInstitution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstitutionID sets the id field of the mutation.
func withInstitutionID(id int) institutionOption {
	return func(m *InstitutionMutation) {
		var (
			err   error
			once  sync.Once
			value *Institution
		)
		m.oldValue = func(ctx context.Context) (*Institution, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Institution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstitution sets the old Institution of the mutation.
func withInstitution(node *Institution) institutionOption {
	return func(m *InstitutionMutation) {
		m.oldValue = func(context.Context) (*Institution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstitutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstitutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstitutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInstitution sets the institution field.
func (m *InstitutionMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the institution value in the mutation.
func (m *InstitutionMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old institution value of the Institution.
// If the Institution object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstitutionMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstitution is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution reset all changes of the "institution" field.
func (m *InstitutionMutation) ResetInstitution() {
	m.institution = nil
}

// AddInstCourIDs adds the inst_cour edge to Course by ids.
func (m *InstitutionMutation) AddInstCourIDs(ids ...int) {
	if m.inst_cour == nil {
		m.inst_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.inst_cour[ids[i]] = struct{}{}
	}
}

// RemoveInstCourIDs removes the inst_cour edge to Course by ids.
func (m *InstitutionMutation) RemoveInstCourIDs(ids ...int) {
	if m.removedinst_cour == nil {
		m.removedinst_cour = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinst_cour[ids[i]] = struct{}{}
	}
}

// RemovedInstCour returns the removed ids of inst_cour.
func (m *InstitutionMutation) RemovedInstCourIDs() (ids []int) {
	for id := range m.removedinst_cour {
		ids = append(ids, id)
	}
	return
}

// InstCourIDs returns the inst_cour ids in the mutation.
func (m *InstitutionMutation) InstCourIDs() (ids []int) {
	for id := range m.inst_cour {
		ids = append(ids, id)
	}
	return
}

// ResetInstCour reset all changes of the "inst_cour" edge.
func (m *InstitutionMutation) ResetInstCour() {
	m.inst_cour = nil
	m.removedinst_cour = nil
}

// Op returns the operation name.
func (m *InstitutionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Institution).
func (m *InstitutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstitutionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.institution != nil {
		fields = append(fields, institution.FieldInstitution)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstitutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case institution.FieldInstitution:
		return m.Institution()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstitutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case institution.FieldInstitution:
		return m.OldInstitution(ctx)
	}
	return nil, fmt.Errorf("unknown Institution field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstitutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case institution.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	}
	return fmt.Errorf("unknown Institution field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstitutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstitutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstitutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Institution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstitutionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstitutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstitutionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Institution nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstitutionMutation) ResetField(name string) error {
	switch name {
	case institution.FieldInstitution:
		m.ResetInstitution()
		return nil
	}
	return fmt.Errorf("unknown Institution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstitutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.inst_cour != nil {
		edges = append(edges, institution.EdgeInstCour)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstitutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case institution.EdgeInstCour:
		ids := make([]ent.Value, 0, len(m.inst_cour))
		for id := range m.inst_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstitutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinst_cour != nil {
		edges = append(edges, institution.EdgeInstCour)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstitutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case institution.EdgeInstCour:
		ids := make([]ent.Value, 0, len(m.removedinst_cour))
		for id := range m.removedinst_cour {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstitutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstitutionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstitutionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Institution unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstitutionMutation) ResetEdge(name string) error {
	switch name {
	case institution.EdgeInstCour:
		m.ResetInstCour()
		return nil
	}
	return fmt.Errorf("unknown Institution edge %s", name)
}

// PlaceMutation represents an operation that mutate the Places
// nodes in the graph.
type PlaceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_PLACE            *string
	clearedFields     map[string]struct{}
	place_acti        map[int]struct{}
	removedplace_acti map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Place, error)
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows to manage the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for $n.Name.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the id field of the mutation.
func withPlaceID(id int) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPLACE sets the PLACE field.
func (m *PlaceMutation) SetPLACE(s string) {
	m._PLACE = &s
}

// PLACE returns the PLACE value in the mutation.
func (m *PlaceMutation) PLACE() (r string, exists bool) {
	v := m._PLACE
	if v == nil {
		return
	}
	return *v, true
}

// OldPLACE returns the old PLACE value of the Place.
// If the Place object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlaceMutation) OldPLACE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPLACE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPLACE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPLACE: %w", err)
	}
	return oldValue.PLACE, nil
}

// ResetPLACE reset all changes of the "PLACE" field.
func (m *PlaceMutation) ResetPLACE() {
	m._PLACE = nil
}

// AddPlaceActiIDs adds the place_acti edge to Activity by ids.
func (m *PlaceMutation) AddPlaceActiIDs(ids ...int) {
	if m.place_acti == nil {
		m.place_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.place_acti[ids[i]] = struct{}{}
	}
}

// RemovePlaceActiIDs removes the place_acti edge to Activity by ids.
func (m *PlaceMutation) RemovePlaceActiIDs(ids ...int) {
	if m.removedplace_acti == nil {
		m.removedplace_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplace_acti[ids[i]] = struct{}{}
	}
}

// RemovedPlaceActi returns the removed ids of place_acti.
func (m *PlaceMutation) RemovedPlaceActiIDs() (ids []int) {
	for id := range m.removedplace_acti {
		ids = append(ids, id)
	}
	return
}

// PlaceActiIDs returns the place_acti ids in the mutation.
func (m *PlaceMutation) PlaceActiIDs() (ids []int) {
	for id := range m.place_acti {
		ids = append(ids, id)
	}
	return
}

// ResetPlaceActi reset all changes of the "place_acti" edge.
func (m *PlaceMutation) ResetPlaceActi() {
	m.place_acti = nil
	m.removedplace_acti = nil
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PLACE != nil {
		fields = append(fields, place.FieldPLACE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldPLACE:
		return m.PLACE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldPLACE:
		return m.OldPLACE(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldPLACE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPLACE(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldPLACE:
		m.ResetPLACE()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.place_acti != nil {
		edges = append(edges, place.EdgePlaceActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgePlaceActi:
		ids := make([]ent.Value, 0, len(m.place_acti))
		for id := range m.place_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplace_acti != nil {
		edges = append(edges, place.EdgePlaceActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case place.EdgePlaceActi:
		ids := make([]ent.Value, 0, len(m.removedplace_acti))
		for id := range m.removedplace_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgePlaceActi:
		m.ResetPlaceActi()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// PrefixMutation represents an operation that mutate the Prefixes
// nodes in the graph.
type PrefixMutation struct {
	config
	op               Op
	typ              string
	id               *int
	prefix           *string
	clearedFields    map[string]struct{}
	pre_prof         map[int]struct{}
	removedpre_prof  map[int]struct{}
	pref_stud        map[int]struct{}
	removedpref_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Prefix, error)
}

var _ ent.Mutation = (*PrefixMutation)(nil)

// prefixOption allows to manage the mutation configuration using functional options.
type prefixOption func(*PrefixMutation)

// newPrefixMutation creates new mutation for $n.Name.
func newPrefixMutation(c config, op Op, opts ...prefixOption) *PrefixMutation {
	m := &PrefixMutation{
		config:        c,
		op:            op,
		typ:           TypePrefix,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefixID sets the id field of the mutation.
func withPrefixID(id int) prefixOption {
	return func(m *PrefixMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefix
		)
		m.oldValue = func(ctx context.Context) (*Prefix, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefix.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefix sets the old Prefix of the mutation.
func withPrefix(node *Prefix) prefixOption {
	return func(m *PrefixMutation) {
		m.oldValue = func(context.Context) (*Prefix, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefixMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefixMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrefixMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrefix sets the prefix field.
func (m *PrefixMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the prefix value in the mutation.
func (m *PrefixMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old prefix value of the Prefix.
// If the Prefix object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrefixMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefix is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix reset all changes of the "prefix" field.
func (m *PrefixMutation) ResetPrefix() {
	m.prefix = nil
}

// AddPreProfIDs adds the pre_prof edge to Professor by ids.
func (m *PrefixMutation) AddPreProfIDs(ids ...int) {
	if m.pre_prof == nil {
		m.pre_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.pre_prof[ids[i]] = struct{}{}
	}
}

// RemovePreProfIDs removes the pre_prof edge to Professor by ids.
func (m *PrefixMutation) RemovePreProfIDs(ids ...int) {
	if m.removedpre_prof == nil {
		m.removedpre_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpre_prof[ids[i]] = struct{}{}
	}
}

// RemovedPreProf returns the removed ids of pre_prof.
func (m *PrefixMutation) RemovedPreProfIDs() (ids []int) {
	for id := range m.removedpre_prof {
		ids = append(ids, id)
	}
	return
}

// PreProfIDs returns the pre_prof ids in the mutation.
func (m *PrefixMutation) PreProfIDs() (ids []int) {
	for id := range m.pre_prof {
		ids = append(ids, id)
	}
	return
}

// ResetPreProf reset all changes of the "pre_prof" edge.
func (m *PrefixMutation) ResetPreProf() {
	m.pre_prof = nil
	m.removedpre_prof = nil
}

// AddPrefStudIDs adds the pref_stud edge to Student by ids.
func (m *PrefixMutation) AddPrefStudIDs(ids ...int) {
	if m.pref_stud == nil {
		m.pref_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.pref_stud[ids[i]] = struct{}{}
	}
}

// RemovePrefStudIDs removes the pref_stud edge to Student by ids.
func (m *PrefixMutation) RemovePrefStudIDs(ids ...int) {
	if m.removedpref_stud == nil {
		m.removedpref_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpref_stud[ids[i]] = struct{}{}
	}
}

// RemovedPrefStud returns the removed ids of pref_stud.
func (m *PrefixMutation) RemovedPrefStudIDs() (ids []int) {
	for id := range m.removedpref_stud {
		ids = append(ids, id)
	}
	return
}

// PrefStudIDs returns the pref_stud ids in the mutation.
func (m *PrefixMutation) PrefStudIDs() (ids []int) {
	for id := range m.pref_stud {
		ids = append(ids, id)
	}
	return
}

// ResetPrefStud reset all changes of the "pref_stud" edge.
func (m *PrefixMutation) ResetPrefStud() {
	m.pref_stud = nil
	m.removedpref_stud = nil
}

// Op returns the operation name.
func (m *PrefixMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefix).
func (m *PrefixMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrefixMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.prefix != nil {
		fields = append(fields, prefix.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrefixMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefix.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrefixMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefix.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Prefix field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefix.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrefixMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrefixMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrefixMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrefixMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefixMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefix nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrefixMutation) ResetField(name string) error {
	switch name {
	case prefix.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrefixMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pre_prof != nil {
		edges = append(edges, prefix.EdgePreProf)
	}
	if m.pref_stud != nil {
		edges = append(edges, prefix.EdgePrefStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrefixMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePreProf:
		ids := make([]ent.Value, 0, len(m.pre_prof))
		for id := range m.pre_prof {
			ids = append(ids, id)
		}
		return ids
	case prefix.EdgePrefStud:
		ids := make([]ent.Value, 0, len(m.pref_stud))
		for id := range m.pref_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrefixMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpre_prof != nil {
		edges = append(edges, prefix.EdgePreProf)
	}
	if m.removedpref_stud != nil {
		edges = append(edges, prefix.EdgePrefStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrefixMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgePreProf:
		ids := make([]ent.Value, 0, len(m.removedpre_prof))
		for id := range m.removedpre_prof {
			ids = append(ids, id)
		}
		return ids
	case prefix.EdgePrefStud:
		ids := make([]ent.Value, 0, len(m.removedpref_stud))
		for id := range m.removedpref_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrefixMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrefixMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrefixMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrefixMutation) ResetEdge(name string) error {
	switch name {
	case prefix.EdgePreProf:
		m.ResetPreProf()
		return nil
	case prefix.EdgePrefStud:
		m.ResetPrefStud()
		return nil
	}
	return fmt.Errorf("unknown Prefix edge %s", name)
}

// ProfessorMutation represents an operation that mutate the Professors
// nodes in the graph.
type ProfessorMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	tel              *string
	email            *string
	clearedFields    map[string]struct{}
	prof_pre         *int
	clearedprof_pre  bool
	prof_facu        *int
	clearedprof_facu bool
	prof_pros        *int
	clearedprof_pros bool
	done             bool
	oldValue         func(context.Context) (*Professor, error)
}

var _ ent.Mutation = (*ProfessorMutation)(nil)

// professorOption allows to manage the mutation configuration using functional options.
type professorOption func(*ProfessorMutation)

// newProfessorMutation creates new mutation for $n.Name.
func newProfessorMutation(c config, op Op, opts ...professorOption) *ProfessorMutation {
	m := &ProfessorMutation{
		config:        c,
		op:            op,
		typ:           TypeProfessor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfessorID sets the id field of the mutation.
func withProfessorID(id int) professorOption {
	return func(m *ProfessorMutation) {
		var (
			err   error
			once  sync.Once
			value *Professor
		)
		m.oldValue = func(ctx context.Context) (*Professor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Professor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfessor sets the old Professor of the mutation.
func withProfessor(node *Professor) professorOption {
	return func(m *ProfessorMutation) {
		m.oldValue = func(context.Context) (*Professor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfessorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfessorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProfessorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ProfessorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProfessorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProfessorMutation) ResetName() {
	m.name = nil
}

// SetTel sets the tel field.
func (m *ProfessorMutation) SetTel(s string) {
	m.tel = &s
}

// Tel returns the tel value in the mutation.
func (m *ProfessorMutation) Tel() (r string, exists bool) {
	v := m.tel
	if v == nil {
		return
	}
	return *v, true
}

// OldTel returns the old tel value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTel: %w", err)
	}
	return oldValue.Tel, nil
}

// ResetTel reset all changes of the "tel" field.
func (m *ProfessorMutation) ResetTel() {
	m.tel = nil
}

// SetEmail sets the email field.
func (m *ProfessorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *ProfessorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Professor.
// If the Professor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *ProfessorMutation) ResetEmail() {
	m.email = nil
}

// SetProfPreID sets the prof_pre edge to Prefix by id.
func (m *ProfessorMutation) SetProfPreID(id int) {
	m.prof_pre = &id
}

// ClearProfPre clears the prof_pre edge to Prefix.
func (m *ProfessorMutation) ClearProfPre() {
	m.clearedprof_pre = true
}

// ProfPreCleared returns if the edge prof_pre was cleared.
func (m *ProfessorMutation) ProfPreCleared() bool {
	return m.clearedprof_pre
}

// ProfPreID returns the prof_pre id in the mutation.
func (m *ProfessorMutation) ProfPreID() (id int, exists bool) {
	if m.prof_pre != nil {
		return *m.prof_pre, true
	}
	return
}

// ProfPreIDs returns the prof_pre ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfPreID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfPreIDs() (ids []int) {
	if id := m.prof_pre; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfPre reset all changes of the "prof_pre" edge.
func (m *ProfessorMutation) ResetProfPre() {
	m.prof_pre = nil
	m.clearedprof_pre = false
}

// SetProfFacuID sets the prof_facu edge to Faculty by id.
func (m *ProfessorMutation) SetProfFacuID(id int) {
	m.prof_facu = &id
}

// ClearProfFacu clears the prof_facu edge to Faculty.
func (m *ProfessorMutation) ClearProfFacu() {
	m.clearedprof_facu = true
}

// ProfFacuCleared returns if the edge prof_facu was cleared.
func (m *ProfessorMutation) ProfFacuCleared() bool {
	return m.clearedprof_facu
}

// ProfFacuID returns the prof_facu id in the mutation.
func (m *ProfessorMutation) ProfFacuID() (id int, exists bool) {
	if m.prof_facu != nil {
		return *m.prof_facu, true
	}
	return
}

// ProfFacuIDs returns the prof_facu ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfFacuID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfFacuIDs() (ids []int) {
	if id := m.prof_facu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfFacu reset all changes of the "prof_facu" edge.
func (m *ProfessorMutation) ResetProfFacu() {
	m.prof_facu = nil
	m.clearedprof_facu = false
}

// SetProfProsID sets the prof_pros edge to Professorship by id.
func (m *ProfessorMutation) SetProfProsID(id int) {
	m.prof_pros = &id
}

// ClearProfPros clears the prof_pros edge to Professorship.
func (m *ProfessorMutation) ClearProfPros() {
	m.clearedprof_pros = true
}

// ProfProsCleared returns if the edge prof_pros was cleared.
func (m *ProfessorMutation) ProfProsCleared() bool {
	return m.clearedprof_pros
}

// ProfProsID returns the prof_pros id in the mutation.
func (m *ProfessorMutation) ProfProsID() (id int, exists bool) {
	if m.prof_pros != nil {
		return *m.prof_pros, true
	}
	return
}

// ProfProsIDs returns the prof_pros ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfProsID instead. It exists only for internal usage by the builders.
func (m *ProfessorMutation) ProfProsIDs() (ids []int) {
	if id := m.prof_pros; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfPros reset all changes of the "prof_pros" edge.
func (m *ProfessorMutation) ResetProfPros() {
	m.prof_pros = nil
	m.clearedprof_pros = false
}

// Op returns the operation name.
func (m *ProfessorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Professor).
func (m *ProfessorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProfessorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, professor.FieldName)
	}
	if m.tel != nil {
		fields = append(fields, professor.FieldTel)
	}
	if m.email != nil {
		fields = append(fields, professor.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProfessorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case professor.FieldName:
		return m.Name()
	case professor.FieldTel:
		return m.Tel()
	case professor.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProfessorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case professor.FieldName:
		return m.OldName(ctx)
	case professor.FieldTel:
		return m.OldTel(ctx)
	case professor.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Professor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case professor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case professor.FieldTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTel(v)
		return nil
	case professor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Professor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProfessorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProfessorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Professor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProfessorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProfessorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfessorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Professor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProfessorMutation) ResetField(name string) error {
	switch name {
	case professor.FieldName:
		m.ResetName()
		return nil
	case professor.FieldTel:
		m.ResetTel()
		return nil
	case professor.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Professor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProfessorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prof_pre != nil {
		edges = append(edges, professor.EdgeProfPre)
	}
	if m.prof_facu != nil {
		edges = append(edges, professor.EdgeProfFacu)
	}
	if m.prof_pros != nil {
		edges = append(edges, professor.EdgeProfPros)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProfessorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case professor.EdgeProfPre:
		if id := m.prof_pre; id != nil {
			return []ent.Value{*id}
		}
	case professor.EdgeProfFacu:
		if id := m.prof_facu; id != nil {
			return []ent.Value{*id}
		}
	case professor.EdgeProfPros:
		if id := m.prof_pros; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProfessorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProfessorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProfessorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprof_pre {
		edges = append(edges, professor.EdgeProfPre)
	}
	if m.clearedprof_facu {
		edges = append(edges, professor.EdgeProfFacu)
	}
	if m.clearedprof_pros {
		edges = append(edges, professor.EdgeProfPros)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProfessorMutation) EdgeCleared(name string) bool {
	switch name {
	case professor.EdgeProfPre:
		return m.clearedprof_pre
	case professor.EdgeProfFacu:
		return m.clearedprof_facu
	case professor.EdgeProfPros:
		return m.clearedprof_pros
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProfessorMutation) ClearEdge(name string) error {
	switch name {
	case professor.EdgeProfPre:
		m.ClearProfPre()
		return nil
	case professor.EdgeProfFacu:
		m.ClearProfFacu()
		return nil
	case professor.EdgeProfPros:
		m.ClearProfPros()
		return nil
	}
	return fmt.Errorf("unknown Professor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProfessorMutation) ResetEdge(name string) error {
	switch name {
	case professor.EdgeProfPre:
		m.ResetProfPre()
		return nil
	case professor.EdgeProfFacu:
		m.ResetProfFacu()
		return nil
	case professor.EdgeProfPros:
		m.ResetProfPros()
		return nil
	}
	return fmt.Errorf("unknown Professor edge %s", name)
}

// ProfessorshipMutation represents an operation that mutate the Professorships
// nodes in the graph.
type ProfessorshipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	professorship    *string
	clearedFields    map[string]struct{}
	pros_prof        map[int]struct{}
	removedpros_prof map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Professorship, error)
}

var _ ent.Mutation = (*ProfessorshipMutation)(nil)

// professorshipOption allows to manage the mutation configuration using functional options.
type professorshipOption func(*ProfessorshipMutation)

// newProfessorshipMutation creates new mutation for $n.Name.
func newProfessorshipMutation(c config, op Op, opts ...professorshipOption) *ProfessorshipMutation {
	m := &ProfessorshipMutation{
		config:        c,
		op:            op,
		typ:           TypeProfessorship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfessorshipID sets the id field of the mutation.
func withProfessorshipID(id int) professorshipOption {
	return func(m *ProfessorshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Professorship
		)
		m.oldValue = func(ctx context.Context) (*Professorship, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Professorship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfessorship sets the old Professorship of the mutation.
func withProfessorship(node *Professorship) professorshipOption {
	return func(m *ProfessorshipMutation) {
		m.oldValue = func(context.Context) (*Professorship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfessorshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfessorshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProfessorshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProfessorship sets the professorship field.
func (m *ProfessorshipMutation) SetProfessorship(s string) {
	m.professorship = &s
}

// Professorship returns the professorship value in the mutation.
func (m *ProfessorshipMutation) Professorship() (r string, exists bool) {
	v := m.professorship
	if v == nil {
		return
	}
	return *v, true
}

// OldProfessorship returns the old professorship value of the Professorship.
// If the Professorship object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProfessorshipMutation) OldProfessorship(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfessorship is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfessorship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfessorship: %w", err)
	}
	return oldValue.Professorship, nil
}

// ResetProfessorship reset all changes of the "professorship" field.
func (m *ProfessorshipMutation) ResetProfessorship() {
	m.professorship = nil
}

// AddProsProfIDs adds the pros_prof edge to Professor by ids.
func (m *ProfessorshipMutation) AddProsProfIDs(ids ...int) {
	if m.pros_prof == nil {
		m.pros_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.pros_prof[ids[i]] = struct{}{}
	}
}

// RemoveProsProfIDs removes the pros_prof edge to Professor by ids.
func (m *ProfessorshipMutation) RemoveProsProfIDs(ids ...int) {
	if m.removedpros_prof == nil {
		m.removedpros_prof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpros_prof[ids[i]] = struct{}{}
	}
}

// RemovedProsProf returns the removed ids of pros_prof.
func (m *ProfessorshipMutation) RemovedProsProfIDs() (ids []int) {
	for id := range m.removedpros_prof {
		ids = append(ids, id)
	}
	return
}

// ProsProfIDs returns the pros_prof ids in the mutation.
func (m *ProfessorshipMutation) ProsProfIDs() (ids []int) {
	for id := range m.pros_prof {
		ids = append(ids, id)
	}
	return
}

// ResetProsProf reset all changes of the "pros_prof" edge.
func (m *ProfessorshipMutation) ResetProsProf() {
	m.pros_prof = nil
	m.removedpros_prof = nil
}

// Op returns the operation name.
func (m *ProfessorshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Professorship).
func (m *ProfessorshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProfessorshipMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.professorship != nil {
		fields = append(fields, professorship.FieldProfessorship)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProfessorshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case professorship.FieldProfessorship:
		return m.Professorship()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProfessorshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case professorship.FieldProfessorship:
		return m.OldProfessorship(ctx)
	}
	return nil, fmt.Errorf("unknown Professorship field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case professorship.FieldProfessorship:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfessorship(v)
		return nil
	}
	return fmt.Errorf("unknown Professorship field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProfessorshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProfessorshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProfessorshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Professorship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProfessorshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProfessorshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfessorshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Professorship nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProfessorshipMutation) ResetField(name string) error {
	switch name {
	case professorship.FieldProfessorship:
		m.ResetProfessorship()
		return nil
	}
	return fmt.Errorf("unknown Professorship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProfessorshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pros_prof != nil {
		edges = append(edges, professorship.EdgeProsProf)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProfessorshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case professorship.EdgeProsProf:
		ids := make([]ent.Value, 0, len(m.pros_prof))
		for id := range m.pros_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProfessorshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpros_prof != nil {
		edges = append(edges, professorship.EdgeProsProf)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProfessorshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case professorship.EdgeProsProf:
		ids := make([]ent.Value, 0, len(m.removedpros_prof))
		for id := range m.removedpros_prof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProfessorshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProfessorshipMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProfessorshipMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Professorship unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProfessorshipMutation) ResetEdge(name string) error {
	switch name {
	case professorship.EdgeProsProf:
		m.ResetProsProf()
		return nil
	}
	return fmt.Errorf("unknown Professorship edge %s", name)
}

// ProvinceMutation represents an operation that mutate the Provinces
// nodes in the graph.
type ProvinceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	province         *string
	district         *string
	subdistrict      *string
	postal           *int
	addpostal        *int
	clearedFields    map[string]struct{}
	prov_regi        *int
	clearedprov_regi bool
	prov_coun        *int
	clearedprov_coun bool
	prov_cont        *int
	clearedprov_cont bool
	prov_stud        map[int]struct{}
	removedprov_stud map[int]struct{}
	dist_stud        map[int]struct{}
	removeddist_stud map[int]struct{}
	subd_stud        map[int]struct{}
	removedsubd_stud map[int]struct{}
	post_stud        map[int]struct{}
	removedpost_stud map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Province, error)
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows to manage the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for $n.Name.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the id field of the mutation.
func withProvinceID(id int) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProvinceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvince sets the province field.
func (m *ProvinceMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the province value in the mutation.
func (m *ProvinceMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old province value of the Province.
// If the Province object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvinceMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince reset all changes of the "province" field.
func (m *ProvinceMutation) ResetProvince() {
	m.province = nil
}

// SetDistrict sets the district field.
func (m *ProvinceMutation) SetDistrict(s string) {
	m.district = &s
}

// District returns the district value in the mutation.
func (m *ProvinceMutation) District() (r string, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old district value of the Province.
// If the Province object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvinceMutation) OldDistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrict is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ResetDistrict reset all changes of the "district" field.
func (m *ProvinceMutation) ResetDistrict() {
	m.district = nil
}

// SetSubdistrict sets the subdistrict field.
func (m *ProvinceMutation) SetSubdistrict(s string) {
	m.subdistrict = &s
}

// Subdistrict returns the subdistrict value in the mutation.
func (m *ProvinceMutation) Subdistrict() (r string, exists bool) {
	v := m.subdistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubdistrict returns the old subdistrict value of the Province.
// If the Province object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvinceMutation) OldSubdistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubdistrict is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubdistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubdistrict: %w", err)
	}
	return oldValue.Subdistrict, nil
}

// ResetSubdistrict reset all changes of the "subdistrict" field.
func (m *ProvinceMutation) ResetSubdistrict() {
	m.subdistrict = nil
}

// SetPostal sets the postal field.
func (m *ProvinceMutation) SetPostal(i int) {
	m.postal = &i
	m.addpostal = nil
}

// Postal returns the postal value in the mutation.
func (m *ProvinceMutation) Postal() (r int, exists bool) {
	v := m.postal
	if v == nil {
		return
	}
	return *v, true
}

// OldPostal returns the old postal value of the Province.
// If the Province object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvinceMutation) OldPostal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostal: %w", err)
	}
	return oldValue.Postal, nil
}

// AddPostal adds i to postal.
func (m *ProvinceMutation) AddPostal(i int) {
	if m.addpostal != nil {
		*m.addpostal += i
	} else {
		m.addpostal = &i
	}
}

// AddedPostal returns the value that was added to the postal field in this mutation.
func (m *ProvinceMutation) AddedPostal() (r int, exists bool) {
	v := m.addpostal
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostal reset all changes of the "postal" field.
func (m *ProvinceMutation) ResetPostal() {
	m.postal = nil
	m.addpostal = nil
}

// SetProvRegiID sets the prov_regi edge to Region by id.
func (m *ProvinceMutation) SetProvRegiID(id int) {
	m.prov_regi = &id
}

// ClearProvRegi clears the prov_regi edge to Region.
func (m *ProvinceMutation) ClearProvRegi() {
	m.clearedprov_regi = true
}

// ProvRegiCleared returns if the edge prov_regi was cleared.
func (m *ProvinceMutation) ProvRegiCleared() bool {
	return m.clearedprov_regi
}

// ProvRegiID returns the prov_regi id in the mutation.
func (m *ProvinceMutation) ProvRegiID() (id int, exists bool) {
	if m.prov_regi != nil {
		return *m.prov_regi, true
	}
	return
}

// ProvRegiIDs returns the prov_regi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProvRegiID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) ProvRegiIDs() (ids []int) {
	if id := m.prov_regi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvRegi reset all changes of the "prov_regi" edge.
func (m *ProvinceMutation) ResetProvRegi() {
	m.prov_regi = nil
	m.clearedprov_regi = false
}

// SetProvCounID sets the prov_coun edge to Country by id.
func (m *ProvinceMutation) SetProvCounID(id int) {
	m.prov_coun = &id
}

// ClearProvCoun clears the prov_coun edge to Country.
func (m *ProvinceMutation) ClearProvCoun() {
	m.clearedprov_coun = true
}

// ProvCounCleared returns if the edge prov_coun was cleared.
func (m *ProvinceMutation) ProvCounCleared() bool {
	return m.clearedprov_coun
}

// ProvCounID returns the prov_coun id in the mutation.
func (m *ProvinceMutation) ProvCounID() (id int, exists bool) {
	if m.prov_coun != nil {
		return *m.prov_coun, true
	}
	return
}

// ProvCounIDs returns the prov_coun ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProvCounID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) ProvCounIDs() (ids []int) {
	if id := m.prov_coun; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvCoun reset all changes of the "prov_coun" edge.
func (m *ProvinceMutation) ResetProvCoun() {
	m.prov_coun = nil
	m.clearedprov_coun = false
}

// SetProvContID sets the prov_cont edge to Continent by id.
func (m *ProvinceMutation) SetProvContID(id int) {
	m.prov_cont = &id
}

// ClearProvCont clears the prov_cont edge to Continent.
func (m *ProvinceMutation) ClearProvCont() {
	m.clearedprov_cont = true
}

// ProvContCleared returns if the edge prov_cont was cleared.
func (m *ProvinceMutation) ProvContCleared() bool {
	return m.clearedprov_cont
}

// ProvContID returns the prov_cont id in the mutation.
func (m *ProvinceMutation) ProvContID() (id int, exists bool) {
	if m.prov_cont != nil {
		return *m.prov_cont, true
	}
	return
}

// ProvContIDs returns the prov_cont ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProvContID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) ProvContIDs() (ids []int) {
	if id := m.prov_cont; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvCont reset all changes of the "prov_cont" edge.
func (m *ProvinceMutation) ResetProvCont() {
	m.prov_cont = nil
	m.clearedprov_cont = false
}

// AddProvStudIDs adds the prov_stud edge to Student by ids.
func (m *ProvinceMutation) AddProvStudIDs(ids ...int) {
	if m.prov_stud == nil {
		m.prov_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.prov_stud[ids[i]] = struct{}{}
	}
}

// RemoveProvStudIDs removes the prov_stud edge to Student by ids.
func (m *ProvinceMutation) RemoveProvStudIDs(ids ...int) {
	if m.removedprov_stud == nil {
		m.removedprov_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprov_stud[ids[i]] = struct{}{}
	}
}

// RemovedProvStud returns the removed ids of prov_stud.
func (m *ProvinceMutation) RemovedProvStudIDs() (ids []int) {
	for id := range m.removedprov_stud {
		ids = append(ids, id)
	}
	return
}

// ProvStudIDs returns the prov_stud ids in the mutation.
func (m *ProvinceMutation) ProvStudIDs() (ids []int) {
	for id := range m.prov_stud {
		ids = append(ids, id)
	}
	return
}

// ResetProvStud reset all changes of the "prov_stud" edge.
func (m *ProvinceMutation) ResetProvStud() {
	m.prov_stud = nil
	m.removedprov_stud = nil
}

// AddDistStudIDs adds the dist_stud edge to Student by ids.
func (m *ProvinceMutation) AddDistStudIDs(ids ...int) {
	if m.dist_stud == nil {
		m.dist_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.dist_stud[ids[i]] = struct{}{}
	}
}

// RemoveDistStudIDs removes the dist_stud edge to Student by ids.
func (m *ProvinceMutation) RemoveDistStudIDs(ids ...int) {
	if m.removeddist_stud == nil {
		m.removeddist_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddist_stud[ids[i]] = struct{}{}
	}
}

// RemovedDistStud returns the removed ids of dist_stud.
func (m *ProvinceMutation) RemovedDistStudIDs() (ids []int) {
	for id := range m.removeddist_stud {
		ids = append(ids, id)
	}
	return
}

// DistStudIDs returns the dist_stud ids in the mutation.
func (m *ProvinceMutation) DistStudIDs() (ids []int) {
	for id := range m.dist_stud {
		ids = append(ids, id)
	}
	return
}

// ResetDistStud reset all changes of the "dist_stud" edge.
func (m *ProvinceMutation) ResetDistStud() {
	m.dist_stud = nil
	m.removeddist_stud = nil
}

// AddSubdStudIDs adds the subd_stud edge to Student by ids.
func (m *ProvinceMutation) AddSubdStudIDs(ids ...int) {
	if m.subd_stud == nil {
		m.subd_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.subd_stud[ids[i]] = struct{}{}
	}
}

// RemoveSubdStudIDs removes the subd_stud edge to Student by ids.
func (m *ProvinceMutation) RemoveSubdStudIDs(ids ...int) {
	if m.removedsubd_stud == nil {
		m.removedsubd_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubd_stud[ids[i]] = struct{}{}
	}
}

// RemovedSubdStud returns the removed ids of subd_stud.
func (m *ProvinceMutation) RemovedSubdStudIDs() (ids []int) {
	for id := range m.removedsubd_stud {
		ids = append(ids, id)
	}
	return
}

// SubdStudIDs returns the subd_stud ids in the mutation.
func (m *ProvinceMutation) SubdStudIDs() (ids []int) {
	for id := range m.subd_stud {
		ids = append(ids, id)
	}
	return
}

// ResetSubdStud reset all changes of the "subd_stud" edge.
func (m *ProvinceMutation) ResetSubdStud() {
	m.subd_stud = nil
	m.removedsubd_stud = nil
}

// AddPostStudIDs adds the post_stud edge to Student by ids.
func (m *ProvinceMutation) AddPostStudIDs(ids ...int) {
	if m.post_stud == nil {
		m.post_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.post_stud[ids[i]] = struct{}{}
	}
}

// RemovePostStudIDs removes the post_stud edge to Student by ids.
func (m *ProvinceMutation) RemovePostStudIDs(ids ...int) {
	if m.removedpost_stud == nil {
		m.removedpost_stud = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpost_stud[ids[i]] = struct{}{}
	}
}

// RemovedPostStud returns the removed ids of post_stud.
func (m *ProvinceMutation) RemovedPostStudIDs() (ids []int) {
	for id := range m.removedpost_stud {
		ids = append(ids, id)
	}
	return
}

// PostStudIDs returns the post_stud ids in the mutation.
func (m *ProvinceMutation) PostStudIDs() (ids []int) {
	for id := range m.post_stud {
		ids = append(ids, id)
	}
	return
}

// ResetPostStud reset all changes of the "post_stud" edge.
func (m *ProvinceMutation) ResetPostStud() {
	m.post_stud = nil
	m.removedpost_stud = nil
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.province != nil {
		fields = append(fields, province.FieldProvince)
	}
	if m.district != nil {
		fields = append(fields, province.FieldDistrict)
	}
	if m.subdistrict != nil {
		fields = append(fields, province.FieldSubdistrict)
	}
	if m.postal != nil {
		fields = append(fields, province.FieldPostal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldProvince:
		return m.Province()
	case province.FieldDistrict:
		return m.District()
	case province.FieldSubdistrict:
		return m.Subdistrict()
	case province.FieldPostal:
		return m.Postal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldProvince:
		return m.OldProvince(ctx)
	case province.FieldDistrict:
		return m.OldDistrict(ctx)
	case province.FieldSubdistrict:
		return m.OldSubdistrict(ctx)
	case province.FieldPostal:
		return m.OldPostal(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case province.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case province.FieldSubdistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubdistrict(v)
		return nil
	case province.FieldPostal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostal(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	var fields []string
	if m.addpostal != nil {
		fields = append(fields, province.FieldPostal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case province.FieldPostal:
		return m.AddedPostal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case province.FieldPostal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostal(v)
		return nil
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldProvince:
		m.ResetProvince()
		return nil
	case province.FieldDistrict:
		m.ResetDistrict()
		return nil
	case province.FieldSubdistrict:
		m.ResetSubdistrict()
		return nil
	case province.FieldPostal:
		m.ResetPostal()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.prov_regi != nil {
		edges = append(edges, province.EdgeProvRegi)
	}
	if m.prov_coun != nil {
		edges = append(edges, province.EdgeProvCoun)
	}
	if m.prov_cont != nil {
		edges = append(edges, province.EdgeProvCont)
	}
	if m.prov_stud != nil {
		edges = append(edges, province.EdgeProvStud)
	}
	if m.dist_stud != nil {
		edges = append(edges, province.EdgeDistStud)
	}
	if m.subd_stud != nil {
		edges = append(edges, province.EdgeSubdStud)
	}
	if m.post_stud != nil {
		edges = append(edges, province.EdgePostStud)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeProvRegi:
		if id := m.prov_regi; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeProvCoun:
		if id := m.prov_coun; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeProvCont:
		if id := m.prov_cont; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeProvStud:
		ids := make([]ent.Value, 0, len(m.prov_stud))
		for id := range m.prov_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistStud:
		ids := make([]ent.Value, 0, len(m.dist_stud))
		for id := range m.dist_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeSubdStud:
		ids := make([]ent.Value, 0, len(m.subd_stud))
		for id := range m.subd_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgePostStud:
		ids := make([]ent.Value, 0, len(m.post_stud))
		for id := range m.post_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedprov_stud != nil {
		edges = append(edges, province.EdgeProvStud)
	}
	if m.removeddist_stud != nil {
		edges = append(edges, province.EdgeDistStud)
	}
	if m.removedsubd_stud != nil {
		edges = append(edges, province.EdgeSubdStud)
	}
	if m.removedpost_stud != nil {
		edges = append(edges, province.EdgePostStud)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeProvStud:
		ids := make([]ent.Value, 0, len(m.removedprov_stud))
		for id := range m.removedprov_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeDistStud:
		ids := make([]ent.Value, 0, len(m.removeddist_stud))
		for id := range m.removeddist_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeSubdStud:
		ids := make([]ent.Value, 0, len(m.removedsubd_stud))
		for id := range m.removedsubd_stud {
			ids = append(ids, id)
		}
		return ids
	case province.EdgePostStud:
		ids := make([]ent.Value, 0, len(m.removedpost_stud))
		for id := range m.removedpost_stud {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedprov_regi {
		edges = append(edges, province.EdgeProvRegi)
	}
	if m.clearedprov_coun {
		edges = append(edges, province.EdgeProvCoun)
	}
	if m.clearedprov_cont {
		edges = append(edges, province.EdgeProvCont)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeProvRegi:
		return m.clearedprov_regi
	case province.EdgeProvCoun:
		return m.clearedprov_coun
	case province.EdgeProvCont:
		return m.clearedprov_cont
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	case province.EdgeProvRegi:
		m.ClearProvRegi()
		return nil
	case province.EdgeProvCoun:
		m.ClearProvCoun()
		return nil
	case province.EdgeProvCont:
		m.ClearProvCont()
		return nil
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeProvRegi:
		m.ResetProvRegi()
		return nil
	case province.EdgeProvCoun:
		m.ResetProvCoun()
		return nil
	case province.EdgeProvCont:
		m.ResetProvCont()
		return nil
	case province.EdgeProvStud:
		m.ResetProvStud()
		return nil
	case province.EdgeDistStud:
		m.ResetDistStud()
		return nil
	case province.EdgeSubdStud:
		m.ResetSubdStud()
		return nil
	case province.EdgePostStud:
		m.ResetPostStud()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// RegionMutation represents an operation that mutate the Regions
// nodes in the graph.
type RegionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	regi_prov        map[int]struct{}
	removedregi_prov map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Region, error)
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows to manage the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for $n.Name.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the id field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Region.
// If the Region object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// AddRegiProvIDs adds the regi_prov edge to Province by ids.
func (m *RegionMutation) AddRegiProvIDs(ids ...int) {
	if m.regi_prov == nil {
		m.regi_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.regi_prov[ids[i]] = struct{}{}
	}
}

// RemoveRegiProvIDs removes the regi_prov edge to Province by ids.
func (m *RegionMutation) RemoveRegiProvIDs(ids ...int) {
	if m.removedregi_prov == nil {
		m.removedregi_prov = make(map[int]struct{})
	}
	for i := range ids {
		m.removedregi_prov[ids[i]] = struct{}{}
	}
}

// RemovedRegiProv returns the removed ids of regi_prov.
func (m *RegionMutation) RemovedRegiProvIDs() (ids []int) {
	for id := range m.removedregi_prov {
		ids = append(ids, id)
	}
	return
}

// RegiProvIDs returns the regi_prov ids in the mutation.
func (m *RegionMutation) RegiProvIDs() (ids []int) {
	for id := range m.regi_prov {
		ids = append(ids, id)
	}
	return
}

// ResetRegiProv reset all changes of the "regi_prov" edge.
func (m *RegionMutation) ResetRegiProv() {
	m.regi_prov = nil
	m.removedregi_prov = nil
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.regi_prov != nil {
		edges = append(edges, region.EdgeRegiProv)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeRegiProv:
		ids := make([]ent.Value, 0, len(m.regi_prov))
		for id := range m.regi_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedregi_prov != nil {
		edges = append(edges, region.EdgeRegiProv)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeRegiProv:
		ids := make([]ent.Value, 0, len(m.removedregi_prov))
		for id := range m.removedregi_prov {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeRegiProv:
		m.ResetRegiProv()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// ResultsMutation represents an operation that mutate the ResultsSlice
// nodes in the graph.
type ResultsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	grade            *float64
	addgrade         *float64
	clearedFields    map[string]struct{}
	resu_year        *int
	clearedresu_year bool
	resu_subj        *int
	clearedresu_subj bool
	resu_stud        *int
	clearedresu_stud bool
	resu_term        *int
	clearedresu_term bool
	done             bool
	oldValue         func(context.Context) (*Results, error)
}

var _ ent.Mutation = (*ResultsMutation)(nil)

// resultsOption allows to manage the mutation configuration using functional options.
type resultsOption func(*ResultsMutation)

// newResultsMutation creates new mutation for $n.Name.
func newResultsMutation(c config, op Op, opts ...resultsOption) *ResultsMutation {
	m := &ResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResultsID sets the id field of the mutation.
func withResultsID(id int) resultsOption {
	return func(m *ResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *Results
		)
		m.oldValue = func(ctx context.Context) (*Results, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Results.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResults sets the old Results of the mutation.
func withResults(node *Results) resultsOption {
	return func(m *ResultsMutation) {
		m.oldValue = func(context.Context) (*Results, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGrade sets the grade field.
func (m *ResultsMutation) SetGrade(f float64) {
	m.grade = &f
	m.addgrade = nil
}

// Grade returns the grade value in the mutation.
func (m *ResultsMutation) Grade() (r float64, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old grade value of the Results.
// If the Results object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResultsMutation) OldGrade(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrade is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// AddGrade adds f to grade.
func (m *ResultsMutation) AddGrade(f float64) {
	if m.addgrade != nil {
		*m.addgrade += f
	} else {
		m.addgrade = &f
	}
}

// AddedGrade returns the value that was added to the grade field in this mutation.
func (m *ResultsMutation) AddedGrade() (r float64, exists bool) {
	v := m.addgrade
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrade reset all changes of the "grade" field.
func (m *ResultsMutation) ResetGrade() {
	m.grade = nil
	m.addgrade = nil
}

// SetResuYearID sets the resu_year edge to Year by id.
func (m *ResultsMutation) SetResuYearID(id int) {
	m.resu_year = &id
}

// ClearResuYear clears the resu_year edge to Year.
func (m *ResultsMutation) ClearResuYear() {
	m.clearedresu_year = true
}

// ResuYearCleared returns if the edge resu_year was cleared.
func (m *ResultsMutation) ResuYearCleared() bool {
	return m.clearedresu_year
}

// ResuYearID returns the resu_year id in the mutation.
func (m *ResultsMutation) ResuYearID() (id int, exists bool) {
	if m.resu_year != nil {
		return *m.resu_year, true
	}
	return
}

// ResuYearIDs returns the resu_year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuYearID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuYearIDs() (ids []int) {
	if id := m.resu_year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuYear reset all changes of the "resu_year" edge.
func (m *ResultsMutation) ResetResuYear() {
	m.resu_year = nil
	m.clearedresu_year = false
}

// SetResuSubjID sets the resu_subj edge to Subject by id.
func (m *ResultsMutation) SetResuSubjID(id int) {
	m.resu_subj = &id
}

// ClearResuSubj clears the resu_subj edge to Subject.
func (m *ResultsMutation) ClearResuSubj() {
	m.clearedresu_subj = true
}

// ResuSubjCleared returns if the edge resu_subj was cleared.
func (m *ResultsMutation) ResuSubjCleared() bool {
	return m.clearedresu_subj
}

// ResuSubjID returns the resu_subj id in the mutation.
func (m *ResultsMutation) ResuSubjID() (id int, exists bool) {
	if m.resu_subj != nil {
		return *m.resu_subj, true
	}
	return
}

// ResuSubjIDs returns the resu_subj ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuSubjID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuSubjIDs() (ids []int) {
	if id := m.resu_subj; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuSubj reset all changes of the "resu_subj" edge.
func (m *ResultsMutation) ResetResuSubj() {
	m.resu_subj = nil
	m.clearedresu_subj = false
}

// SetResuStudID sets the resu_stud edge to Student by id.
func (m *ResultsMutation) SetResuStudID(id int) {
	m.resu_stud = &id
}

// ClearResuStud clears the resu_stud edge to Student.
func (m *ResultsMutation) ClearResuStud() {
	m.clearedresu_stud = true
}

// ResuStudCleared returns if the edge resu_stud was cleared.
func (m *ResultsMutation) ResuStudCleared() bool {
	return m.clearedresu_stud
}

// ResuStudID returns the resu_stud id in the mutation.
func (m *ResultsMutation) ResuStudID() (id int, exists bool) {
	if m.resu_stud != nil {
		return *m.resu_stud, true
	}
	return
}

// ResuStudIDs returns the resu_stud ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuStudID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuStudIDs() (ids []int) {
	if id := m.resu_stud; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuStud reset all changes of the "resu_stud" edge.
func (m *ResultsMutation) ResetResuStud() {
	m.resu_stud = nil
	m.clearedresu_stud = false
}

// SetResuTermID sets the resu_term edge to Term by id.
func (m *ResultsMutation) SetResuTermID(id int) {
	m.resu_term = &id
}

// ClearResuTerm clears the resu_term edge to Term.
func (m *ResultsMutation) ClearResuTerm() {
	m.clearedresu_term = true
}

// ResuTermCleared returns if the edge resu_term was cleared.
func (m *ResultsMutation) ResuTermCleared() bool {
	return m.clearedresu_term
}

// ResuTermID returns the resu_term id in the mutation.
func (m *ResultsMutation) ResuTermID() (id int, exists bool) {
	if m.resu_term != nil {
		return *m.resu_term, true
	}
	return
}

// ResuTermIDs returns the resu_term ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResuTermID instead. It exists only for internal usage by the builders.
func (m *ResultsMutation) ResuTermIDs() (ids []int) {
	if id := m.resu_term; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResuTerm reset all changes of the "resu_term" edge.
func (m *ResultsMutation) ResetResuTerm() {
	m.resu_term = nil
	m.clearedresu_term = false
}

// Op returns the operation name.
func (m *ResultsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Results).
func (m *ResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResultsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.grade != nil {
		fields = append(fields, results.FieldGrade)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case results.FieldGrade:
		return m.Grade()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case results.FieldGrade:
		return m.OldGrade(ctx)
	}
	return nil, fmt.Errorf("unknown Results field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case results.FieldGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Results field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResultsMutation) AddedFields() []string {
	var fields []string
	if m.addgrade != nil {
		fields = append(fields, results.FieldGrade)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResultsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case results.FieldGrade:
		return m.AddedGrade()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case results.FieldGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Results numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResultsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResultsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Results nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResultsMutation) ResetField(name string) error {
	switch name {
	case results.FieldGrade:
		m.ResetGrade()
		return nil
	}
	return fmt.Errorf("unknown Results field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.resu_year != nil {
		edges = append(edges, results.EdgeResuYear)
	}
	if m.resu_subj != nil {
		edges = append(edges, results.EdgeResuSubj)
	}
	if m.resu_stud != nil {
		edges = append(edges, results.EdgeResuStud)
	}
	if m.resu_term != nil {
		edges = append(edges, results.EdgeResuTerm)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case results.EdgeResuYear:
		if id := m.resu_year; id != nil {
			return []ent.Value{*id}
		}
	case results.EdgeResuSubj:
		if id := m.resu_subj; id != nil {
			return []ent.Value{*id}
		}
	case results.EdgeResuStud:
		if id := m.resu_stud; id != nil {
			return []ent.Value{*id}
		}
	case results.EdgeResuTerm:
		if id := m.resu_term; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResultsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedresu_year {
		edges = append(edges, results.EdgeResuYear)
	}
	if m.clearedresu_subj {
		edges = append(edges, results.EdgeResuSubj)
	}
	if m.clearedresu_stud {
		edges = append(edges, results.EdgeResuStud)
	}
	if m.clearedresu_term {
		edges = append(edges, results.EdgeResuTerm)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case results.EdgeResuYear:
		return m.clearedresu_year
	case results.EdgeResuSubj:
		return m.clearedresu_subj
	case results.EdgeResuStud:
		return m.clearedresu_stud
	case results.EdgeResuTerm:
		return m.clearedresu_term
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResultsMutation) ClearEdge(name string) error {
	switch name {
	case results.EdgeResuYear:
		m.ClearResuYear()
		return nil
	case results.EdgeResuSubj:
		m.ClearResuSubj()
		return nil
	case results.EdgeResuStud:
		m.ClearResuStud()
		return nil
	case results.EdgeResuTerm:
		m.ClearResuTerm()
		return nil
	}
	return fmt.Errorf("unknown Results unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResultsMutation) ResetEdge(name string) error {
	switch name {
	case results.EdgeResuYear:
		m.ResetResuYear()
		return nil
	case results.EdgeResuSubj:
		m.ResetResuSubj()
		return nil
	case results.EdgeResuStud:
		m.ResetResuStud()
		return nil
	case results.EdgeResuTerm:
		m.ResetResuTerm()
		return nil
	}
	return fmt.Errorf("unknown Results edge %s", name)
}

// StudentMutation represents an operation that mutate the Students
// nodes in the graph.
type StudentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	fname            *string
	lname            *string
	schoolname       *string
	recent_address   *string
	telephone        *int
	addtelephone     *int
	email            *string
	clearedFields    map[string]struct{}
	stud_gend        *int
	clearedstud_gend bool
	stud_acti        map[int]struct{}
	removedstud_acti map[int]struct{}
	stud_resu        map[int]struct{}
	removedstud_resu map[int]struct{}
	stud_prov        *int
	clearedstud_prov bool
	stud_dist        *int
	clearedstud_dist bool
	stud_subd        *int
	clearedstud_subd bool
	stud_post        *int
	clearedstud_post bool
	stud_pref        *int
	clearedstud_pref bool
	stud_degr        *int
	clearedstud_degr bool
	done             bool
	oldValue         func(context.Context) (*Student, error)
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows to manage the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for $n.Name.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the id field of the mutation.
func withStudentID(id int) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFname sets the fname field.
func (m *StudentMutation) SetFname(s string) {
	m.fname = &s
}

// Fname returns the fname value in the mutation.
func (m *StudentMutation) Fname() (r string, exists bool) {
	v := m.fname
	if v == nil {
		return
	}
	return *v, true
}

// OldFname returns the old fname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldFname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFname: %w", err)
	}
	return oldValue.Fname, nil
}

// ResetFname reset all changes of the "fname" field.
func (m *StudentMutation) ResetFname() {
	m.fname = nil
}

// SetLname sets the lname field.
func (m *StudentMutation) SetLname(s string) {
	m.lname = &s
}

// Lname returns the lname value in the mutation.
func (m *StudentMutation) Lname() (r string, exists bool) {
	v := m.lname
	if v == nil {
		return
	}
	return *v, true
}

// OldLname returns the old lname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldLname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLname: %w", err)
	}
	return oldValue.Lname, nil
}

// ResetLname reset all changes of the "lname" field.
func (m *StudentMutation) ResetLname() {
	m.lname = nil
}

// SetSchoolname sets the schoolname field.
func (m *StudentMutation) SetSchoolname(s string) {
	m.schoolname = &s
}

// Schoolname returns the schoolname value in the mutation.
func (m *StudentMutation) Schoolname() (r string, exists bool) {
	v := m.schoolname
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolname returns the old schoolname value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldSchoolname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchoolname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchoolname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolname: %w", err)
	}
	return oldValue.Schoolname, nil
}

// ResetSchoolname reset all changes of the "schoolname" field.
func (m *StudentMutation) ResetSchoolname() {
	m.schoolname = nil
}

// SetRecentAddress sets the recent_address field.
func (m *StudentMutation) SetRecentAddress(s string) {
	m.recent_address = &s
}

// RecentAddress returns the recent_address value in the mutation.
func (m *StudentMutation) RecentAddress() (r string, exists bool) {
	v := m.recent_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentAddress returns the old recent_address value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldRecentAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecentAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecentAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentAddress: %w", err)
	}
	return oldValue.RecentAddress, nil
}

// ResetRecentAddress reset all changes of the "recent_address" field.
func (m *StudentMutation) ResetRecentAddress() {
	m.recent_address = nil
}

// SetTelephone sets the telephone field.
func (m *StudentMutation) SetTelephone(i int) {
	m.telephone = &i
	m.addtelephone = nil
}

// Telephone returns the telephone value in the mutation.
func (m *StudentMutation) Telephone() (r int, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old telephone value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldTelephone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// AddTelephone adds i to telephone.
func (m *StudentMutation) AddTelephone(i int) {
	if m.addtelephone != nil {
		*m.addtelephone += i
	} else {
		m.addtelephone = &i
	}
}

// AddedTelephone returns the value that was added to the telephone field in this mutation.
func (m *StudentMutation) AddedTelephone() (r int, exists bool) {
	v := m.addtelephone
	if v == nil {
		return
	}
	return *v, true
}

// ResetTelephone reset all changes of the "telephone" field.
func (m *StudentMutation) ResetTelephone() {
	m.telephone = nil
	m.addtelephone = nil
}

// SetEmail sets the email field.
func (m *StudentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *StudentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Student.
// If the Student object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudentMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *StudentMutation) ResetEmail() {
	m.email = nil
}

// SetStudGendID sets the stud_gend edge to Gender by id.
func (m *StudentMutation) SetStudGendID(id int) {
	m.stud_gend = &id
}

// ClearStudGend clears the stud_gend edge to Gender.
func (m *StudentMutation) ClearStudGend() {
	m.clearedstud_gend = true
}

// StudGendCleared returns if the edge stud_gend was cleared.
func (m *StudentMutation) StudGendCleared() bool {
	return m.clearedstud_gend
}

// StudGendID returns the stud_gend id in the mutation.
func (m *StudentMutation) StudGendID() (id int, exists bool) {
	if m.stud_gend != nil {
		return *m.stud_gend, true
	}
	return
}

// StudGendIDs returns the stud_gend ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudGendID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudGendIDs() (ids []int) {
	if id := m.stud_gend; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudGend reset all changes of the "stud_gend" edge.
func (m *StudentMutation) ResetStudGend() {
	m.stud_gend = nil
	m.clearedstud_gend = false
}

// AddStudActiIDs adds the stud_acti edge to Activity by ids.
func (m *StudentMutation) AddStudActiIDs(ids ...int) {
	if m.stud_acti == nil {
		m.stud_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.stud_acti[ids[i]] = struct{}{}
	}
}

// RemoveStudActiIDs removes the stud_acti edge to Activity by ids.
func (m *StudentMutation) RemoveStudActiIDs(ids ...int) {
	if m.removedstud_acti == nil {
		m.removedstud_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstud_acti[ids[i]] = struct{}{}
	}
}

// RemovedStudActi returns the removed ids of stud_acti.
func (m *StudentMutation) RemovedStudActiIDs() (ids []int) {
	for id := range m.removedstud_acti {
		ids = append(ids, id)
	}
	return
}

// StudActiIDs returns the stud_acti ids in the mutation.
func (m *StudentMutation) StudActiIDs() (ids []int) {
	for id := range m.stud_acti {
		ids = append(ids, id)
	}
	return
}

// ResetStudActi reset all changes of the "stud_acti" edge.
func (m *StudentMutation) ResetStudActi() {
	m.stud_acti = nil
	m.removedstud_acti = nil
}

// AddStudResuIDs adds the stud_resu edge to Results by ids.
func (m *StudentMutation) AddStudResuIDs(ids ...int) {
	if m.stud_resu == nil {
		m.stud_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.stud_resu[ids[i]] = struct{}{}
	}
}

// RemoveStudResuIDs removes the stud_resu edge to Results by ids.
func (m *StudentMutation) RemoveStudResuIDs(ids ...int) {
	if m.removedstud_resu == nil {
		m.removedstud_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstud_resu[ids[i]] = struct{}{}
	}
}

// RemovedStudResu returns the removed ids of stud_resu.
func (m *StudentMutation) RemovedStudResuIDs() (ids []int) {
	for id := range m.removedstud_resu {
		ids = append(ids, id)
	}
	return
}

// StudResuIDs returns the stud_resu ids in the mutation.
func (m *StudentMutation) StudResuIDs() (ids []int) {
	for id := range m.stud_resu {
		ids = append(ids, id)
	}
	return
}

// ResetStudResu reset all changes of the "stud_resu" edge.
func (m *StudentMutation) ResetStudResu() {
	m.stud_resu = nil
	m.removedstud_resu = nil
}

// SetStudProvID sets the stud_prov edge to Province by id.
func (m *StudentMutation) SetStudProvID(id int) {
	m.stud_prov = &id
}

// ClearStudProv clears the stud_prov edge to Province.
func (m *StudentMutation) ClearStudProv() {
	m.clearedstud_prov = true
}

// StudProvCleared returns if the edge stud_prov was cleared.
func (m *StudentMutation) StudProvCleared() bool {
	return m.clearedstud_prov
}

// StudProvID returns the stud_prov id in the mutation.
func (m *StudentMutation) StudProvID() (id int, exists bool) {
	if m.stud_prov != nil {
		return *m.stud_prov, true
	}
	return
}

// StudProvIDs returns the stud_prov ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudProvID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudProvIDs() (ids []int) {
	if id := m.stud_prov; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudProv reset all changes of the "stud_prov" edge.
func (m *StudentMutation) ResetStudProv() {
	m.stud_prov = nil
	m.clearedstud_prov = false
}

// SetStudDistID sets the stud_dist edge to Province by id.
func (m *StudentMutation) SetStudDistID(id int) {
	m.stud_dist = &id
}

// ClearStudDist clears the stud_dist edge to Province.
func (m *StudentMutation) ClearStudDist() {
	m.clearedstud_dist = true
}

// StudDistCleared returns if the edge stud_dist was cleared.
func (m *StudentMutation) StudDistCleared() bool {
	return m.clearedstud_dist
}

// StudDistID returns the stud_dist id in the mutation.
func (m *StudentMutation) StudDistID() (id int, exists bool) {
	if m.stud_dist != nil {
		return *m.stud_dist, true
	}
	return
}

// StudDistIDs returns the stud_dist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudDistID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudDistIDs() (ids []int) {
	if id := m.stud_dist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudDist reset all changes of the "stud_dist" edge.
func (m *StudentMutation) ResetStudDist() {
	m.stud_dist = nil
	m.clearedstud_dist = false
}

// SetStudSubdID sets the stud_subd edge to Province by id.
func (m *StudentMutation) SetStudSubdID(id int) {
	m.stud_subd = &id
}

// ClearStudSubd clears the stud_subd edge to Province.
func (m *StudentMutation) ClearStudSubd() {
	m.clearedstud_subd = true
}

// StudSubdCleared returns if the edge stud_subd was cleared.
func (m *StudentMutation) StudSubdCleared() bool {
	return m.clearedstud_subd
}

// StudSubdID returns the stud_subd id in the mutation.
func (m *StudentMutation) StudSubdID() (id int, exists bool) {
	if m.stud_subd != nil {
		return *m.stud_subd, true
	}
	return
}

// StudSubdIDs returns the stud_subd ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudSubdID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudSubdIDs() (ids []int) {
	if id := m.stud_subd; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudSubd reset all changes of the "stud_subd" edge.
func (m *StudentMutation) ResetStudSubd() {
	m.stud_subd = nil
	m.clearedstud_subd = false
}

// SetStudPostID sets the stud_post edge to Province by id.
func (m *StudentMutation) SetStudPostID(id int) {
	m.stud_post = &id
}

// ClearStudPost clears the stud_post edge to Province.
func (m *StudentMutation) ClearStudPost() {
	m.clearedstud_post = true
}

// StudPostCleared returns if the edge stud_post was cleared.
func (m *StudentMutation) StudPostCleared() bool {
	return m.clearedstud_post
}

// StudPostID returns the stud_post id in the mutation.
func (m *StudentMutation) StudPostID() (id int, exists bool) {
	if m.stud_post != nil {
		return *m.stud_post, true
	}
	return
}

// StudPostIDs returns the stud_post ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudPostID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudPostIDs() (ids []int) {
	if id := m.stud_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudPost reset all changes of the "stud_post" edge.
func (m *StudentMutation) ResetStudPost() {
	m.stud_post = nil
	m.clearedstud_post = false
}

// SetStudPrefID sets the stud_pref edge to Prefix by id.
func (m *StudentMutation) SetStudPrefID(id int) {
	m.stud_pref = &id
}

// ClearStudPref clears the stud_pref edge to Prefix.
func (m *StudentMutation) ClearStudPref() {
	m.clearedstud_pref = true
}

// StudPrefCleared returns if the edge stud_pref was cleared.
func (m *StudentMutation) StudPrefCleared() bool {
	return m.clearedstud_pref
}

// StudPrefID returns the stud_pref id in the mutation.
func (m *StudentMutation) StudPrefID() (id int, exists bool) {
	if m.stud_pref != nil {
		return *m.stud_pref, true
	}
	return
}

// StudPrefIDs returns the stud_pref ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudPrefID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudPrefIDs() (ids []int) {
	if id := m.stud_pref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudPref reset all changes of the "stud_pref" edge.
func (m *StudentMutation) ResetStudPref() {
	m.stud_pref = nil
	m.clearedstud_pref = false
}

// SetStudDegrID sets the stud_degr edge to Degree by id.
func (m *StudentMutation) SetStudDegrID(id int) {
	m.stud_degr = &id
}

// ClearStudDegr clears the stud_degr edge to Degree.
func (m *StudentMutation) ClearStudDegr() {
	m.clearedstud_degr = true
}

// StudDegrCleared returns if the edge stud_degr was cleared.
func (m *StudentMutation) StudDegrCleared() bool {
	return m.clearedstud_degr
}

// StudDegrID returns the stud_degr id in the mutation.
func (m *StudentMutation) StudDegrID() (id int, exists bool) {
	if m.stud_degr != nil {
		return *m.stud_degr, true
	}
	return
}

// StudDegrIDs returns the stud_degr ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudDegrID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) StudDegrIDs() (ids []int) {
	if id := m.stud_degr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudDegr reset all changes of the "stud_degr" edge.
func (m *StudentMutation) ResetStudDegr() {
	m.stud_degr = nil
	m.clearedstud_degr = false
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.fname != nil {
		fields = append(fields, student.FieldFname)
	}
	if m.lname != nil {
		fields = append(fields, student.FieldLname)
	}
	if m.schoolname != nil {
		fields = append(fields, student.FieldSchoolname)
	}
	if m.recent_address != nil {
		fields = append(fields, student.FieldRecentAddress)
	}
	if m.telephone != nil {
		fields = append(fields, student.FieldTelephone)
	}
	if m.email != nil {
		fields = append(fields, student.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldFname:
		return m.Fname()
	case student.FieldLname:
		return m.Lname()
	case student.FieldSchoolname:
		return m.Schoolname()
	case student.FieldRecentAddress:
		return m.RecentAddress()
	case student.FieldTelephone:
		return m.Telephone()
	case student.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldFname:
		return m.OldFname(ctx)
	case student.FieldLname:
		return m.OldLname(ctx)
	case student.FieldSchoolname:
		return m.OldSchoolname(ctx)
	case student.FieldRecentAddress:
		return m.OldRecentAddress(ctx)
	case student.FieldTelephone:
		return m.OldTelephone(ctx)
	case student.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldFname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFname(v)
		return nil
	case student.FieldLname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLname(v)
		return nil
	case student.FieldSchoolname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolname(v)
		return nil
	case student.FieldRecentAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentAddress(v)
		return nil
	case student.FieldTelephone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case student.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StudentMutation) AddedFields() []string {
	var fields []string
	if m.addtelephone != nil {
		fields = append(fields, student.FieldTelephone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case student.FieldTelephone:
		return m.AddedTelephone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case student.FieldTelephone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTelephone(v)
		return nil
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldFname:
		m.ResetFname()
		return nil
	case student.FieldLname:
		m.ResetLname()
		return nil
	case student.FieldSchoolname:
		m.ResetSchoolname()
		return nil
	case student.FieldRecentAddress:
		m.ResetRecentAddress()
		return nil
	case student.FieldTelephone:
		m.ResetTelephone()
		return nil
	case student.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.stud_gend != nil {
		edges = append(edges, student.EdgeStudGend)
	}
	if m.stud_acti != nil {
		edges = append(edges, student.EdgeStudActi)
	}
	if m.stud_resu != nil {
		edges = append(edges, student.EdgeStudResu)
	}
	if m.stud_prov != nil {
		edges = append(edges, student.EdgeStudProv)
	}
	if m.stud_dist != nil {
		edges = append(edges, student.EdgeStudDist)
	}
	if m.stud_subd != nil {
		edges = append(edges, student.EdgeStudSubd)
	}
	if m.stud_post != nil {
		edges = append(edges, student.EdgeStudPost)
	}
	if m.stud_pref != nil {
		edges = append(edges, student.EdgeStudPref)
	}
	if m.stud_degr != nil {
		edges = append(edges, student.EdgeStudDegr)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeStudGend:
		if id := m.stud_gend; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudActi:
		ids := make([]ent.Value, 0, len(m.stud_acti))
		for id := range m.stud_acti {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudResu:
		ids := make([]ent.Value, 0, len(m.stud_resu))
		for id := range m.stud_resu {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudProv:
		if id := m.stud_prov; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudDist:
		if id := m.stud_dist; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudSubd:
		if id := m.stud_subd; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudPost:
		if id := m.stud_post; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudPref:
		if id := m.stud_pref; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeStudDegr:
		if id := m.stud_degr; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedstud_acti != nil {
		edges = append(edges, student.EdgeStudActi)
	}
	if m.removedstud_resu != nil {
		edges = append(edges, student.EdgeStudResu)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeStudActi:
		ids := make([]ent.Value, 0, len(m.removedstud_acti))
		for id := range m.removedstud_acti {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeStudResu:
		ids := make([]ent.Value, 0, len(m.removedstud_resu))
		for id := range m.removedstud_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedstud_gend {
		edges = append(edges, student.EdgeStudGend)
	}
	if m.clearedstud_prov {
		edges = append(edges, student.EdgeStudProv)
	}
	if m.clearedstud_dist {
		edges = append(edges, student.EdgeStudDist)
	}
	if m.clearedstud_subd {
		edges = append(edges, student.EdgeStudSubd)
	}
	if m.clearedstud_post {
		edges = append(edges, student.EdgeStudPost)
	}
	if m.clearedstud_pref {
		edges = append(edges, student.EdgeStudPref)
	}
	if m.clearedstud_degr {
		edges = append(edges, student.EdgeStudDegr)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeStudGend:
		return m.clearedstud_gend
	case student.EdgeStudProv:
		return m.clearedstud_prov
	case student.EdgeStudDist:
		return m.clearedstud_dist
	case student.EdgeStudSubd:
		return m.clearedstud_subd
	case student.EdgeStudPost:
		return m.clearedstud_post
	case student.EdgeStudPref:
		return m.clearedstud_pref
	case student.EdgeStudDegr:
		return m.clearedstud_degr
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeStudGend:
		m.ClearStudGend()
		return nil
	case student.EdgeStudProv:
		m.ClearStudProv()
		return nil
	case student.EdgeStudDist:
		m.ClearStudDist()
		return nil
	case student.EdgeStudSubd:
		m.ClearStudSubd()
		return nil
	case student.EdgeStudPost:
		m.ClearStudPost()
		return nil
	case student.EdgeStudPref:
		m.ClearStudPref()
		return nil
	case student.EdgeStudDegr:
		m.ClearStudDegr()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeStudGend:
		m.ResetStudGend()
		return nil
	case student.EdgeStudActi:
		m.ResetStudActi()
		return nil
	case student.EdgeStudResu:
		m.ResetStudResu()
		return nil
	case student.EdgeStudProv:
		m.ResetStudProv()
		return nil
	case student.EdgeStudDist:
		m.ResetStudDist()
		return nil
	case student.EdgeStudSubd:
		m.ResetStudSubd()
		return nil
	case student.EdgeStudPost:
		m.ResetStudPost()
		return nil
	case student.EdgeStudPref:
		m.ResetStudPref()
		return nil
	case student.EdgeStudDegr:
		m.ResetStudDegr()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// SubjectMutation represents an operation that mutate the Subjects
// nodes in the graph.
type SubjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	code             *int
	addcode          *int
	subjects         *string
	creditpiont      *int
	addcreditpiont   *int
	clearedFields    map[string]struct{}
	subj_resu        map[int]struct{}
	removedsubj_resu map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Subject, error)
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows to manage the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for $n.Name.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the id field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCode sets the code field.
func (m *SubjectMutation) SetCode(i int) {
	m.code = &i
	m.addcode = nil
}

// Code returns the code value in the mutation.
func (m *SubjectMutation) Code() (r int, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to code.
func (m *SubjectMutation) AddCode(i int) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the code field in this mutation.
func (m *SubjectMutation) AddedCode() (r int, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode reset all changes of the "code" field.
func (m *SubjectMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
}

// SetSubjects sets the subjects field.
func (m *SubjectMutation) SetSubjects(s string) {
	m.subjects = &s
}

// Subjects returns the subjects value in the mutation.
func (m *SubjectMutation) Subjects() (r string, exists bool) {
	v := m.subjects
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjects returns the old subjects value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldSubjects(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjects is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjects: %w", err)
	}
	return oldValue.Subjects, nil
}

// ResetSubjects reset all changes of the "subjects" field.
func (m *SubjectMutation) ResetSubjects() {
	m.subjects = nil
}

// SetCreditpiont sets the creditpiont field.
func (m *SubjectMutation) SetCreditpiont(i int) {
	m.creditpiont = &i
	m.addcreditpiont = nil
}

// Creditpiont returns the creditpiont value in the mutation.
func (m *SubjectMutation) Creditpiont() (r int, exists bool) {
	v := m.creditpiont
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditpiont returns the old creditpiont value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldCreditpiont(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreditpiont is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreditpiont requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditpiont: %w", err)
	}
	return oldValue.Creditpiont, nil
}

// AddCreditpiont adds i to creditpiont.
func (m *SubjectMutation) AddCreditpiont(i int) {
	if m.addcreditpiont != nil {
		*m.addcreditpiont += i
	} else {
		m.addcreditpiont = &i
	}
}

// AddedCreditpiont returns the value that was added to the creditpiont field in this mutation.
func (m *SubjectMutation) AddedCreditpiont() (r int, exists bool) {
	v := m.addcreditpiont
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditpiont reset all changes of the "creditpiont" field.
func (m *SubjectMutation) ResetCreditpiont() {
	m.creditpiont = nil
	m.addcreditpiont = nil
}

// AddSubjResuIDs adds the subj_resu edge to Results by ids.
func (m *SubjectMutation) AddSubjResuIDs(ids ...int) {
	if m.subj_resu == nil {
		m.subj_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.subj_resu[ids[i]] = struct{}{}
	}
}

// RemoveSubjResuIDs removes the subj_resu edge to Results by ids.
func (m *SubjectMutation) RemoveSubjResuIDs(ids ...int) {
	if m.removedsubj_resu == nil {
		m.removedsubj_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubj_resu[ids[i]] = struct{}{}
	}
}

// RemovedSubjResu returns the removed ids of subj_resu.
func (m *SubjectMutation) RemovedSubjResuIDs() (ids []int) {
	for id := range m.removedsubj_resu {
		ids = append(ids, id)
	}
	return
}

// SubjResuIDs returns the subj_resu ids in the mutation.
func (m *SubjectMutation) SubjResuIDs() (ids []int) {
	for id := range m.subj_resu {
		ids = append(ids, id)
	}
	return
}

// ResetSubjResu reset all changes of the "subj_resu" edge.
func (m *SubjectMutation) ResetSubjResu() {
	m.subj_resu = nil
	m.removedsubj_resu = nil
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, subject.FieldCode)
	}
	if m.subjects != nil {
		fields = append(fields, subject.FieldSubjects)
	}
	if m.creditpiont != nil {
		fields = append(fields, subject.FieldCreditpiont)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCode:
		return m.Code()
	case subject.FieldSubjects:
		return m.Subjects()
	case subject.FieldCreditpiont:
		return m.Creditpiont()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCode:
		return m.OldCode(ctx)
	case subject.FieldSubjects:
		return m.OldSubjects(ctx)
	case subject.FieldCreditpiont:
		return m.OldCreditpiont(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case subject.FieldSubjects:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjects(v)
		return nil
	case subject.FieldCreditpiont:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditpiont(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectMutation) AddedFields() []string {
	var fields []string
	if m.addcode != nil {
		fields = append(fields, subject.FieldCode)
	}
	if m.addcreditpiont != nil {
		fields = append(fields, subject.FieldCreditpiont)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCode:
		return m.AddedCode()
	case subject.FieldCreditpiont:
		return m.AddedCreditpiont()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	case subject.FieldCreditpiont:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditpiont(v)
		return nil
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCode:
		m.ResetCode()
		return nil
	case subject.FieldSubjects:
		m.ResetSubjects()
		return nil
	case subject.FieldCreditpiont:
		m.ResetCreditpiont()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subj_resu != nil {
		edges = append(edges, subject.EdgeSubjResu)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubjResu:
		ids := make([]ent.Value, 0, len(m.subj_resu))
		for id := range m.subj_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubj_resu != nil {
		edges = append(edges, subject.EdgeSubjResu)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubjResu:
		ids := make([]ent.Value, 0, len(m.removedsubj_resu))
		for id := range m.removedsubj_resu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeSubjResu:
		m.ResetSubjResu()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// TermMutation represents an operation that mutate the Terms
// nodes in the graph.
type TermMutation struct {
	config
	op               Op
	typ              string
	id               *int
	semester         *int
	addsemester      *int
	clearedFields    map[string]struct{}
	term_resu        map[int]struct{}
	removedterm_resu map[int]struct{}
	term_acti        map[int]struct{}
	removedterm_acti map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Term, error)
}

var _ ent.Mutation = (*TermMutation)(nil)

// termOption allows to manage the mutation configuration using functional options.
type termOption func(*TermMutation)

// newTermMutation creates new mutation for $n.Name.
func newTermMutation(c config, op Op, opts ...termOption) *TermMutation {
	m := &TermMutation{
		config:        c,
		op:            op,
		typ:           TypeTerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTermID sets the id field of the mutation.
func withTermID(id int) termOption {
	return func(m *TermMutation) {
		var (
			err   error
			once  sync.Once
			value *Term
		)
		m.oldValue = func(ctx context.Context) (*Term, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Term.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTerm sets the old Term of the mutation.
func withTerm(node *Term) termOption {
	return func(m *TermMutation) {
		m.oldValue = func(context.Context) (*Term, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TermMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSemester sets the semester field.
func (m *TermMutation) SetSemester(i int) {
	m.semester = &i
	m.addsemester = nil
}

// Semester returns the semester value in the mutation.
func (m *TermMutation) Semester() (r int, exists bool) {
	v := m.semester
	if v == nil {
		return
	}
	return *v, true
}

// OldSemester returns the old semester value of the Term.
// If the Term object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TermMutation) OldSemester(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemester is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemester requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemester: %w", err)
	}
	return oldValue.Semester, nil
}

// AddSemester adds i to semester.
func (m *TermMutation) AddSemester(i int) {
	if m.addsemester != nil {
		*m.addsemester += i
	} else {
		m.addsemester = &i
	}
}

// AddedSemester returns the value that was added to the semester field in this mutation.
func (m *TermMutation) AddedSemester() (r int, exists bool) {
	v := m.addsemester
	if v == nil {
		return
	}
	return *v, true
}

// ResetSemester reset all changes of the "semester" field.
func (m *TermMutation) ResetSemester() {
	m.semester = nil
	m.addsemester = nil
}

// AddTermResuIDs adds the term_resu edge to Results by ids.
func (m *TermMutation) AddTermResuIDs(ids ...int) {
	if m.term_resu == nil {
		m.term_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.term_resu[ids[i]] = struct{}{}
	}
}

// RemoveTermResuIDs removes the term_resu edge to Results by ids.
func (m *TermMutation) RemoveTermResuIDs(ids ...int) {
	if m.removedterm_resu == nil {
		m.removedterm_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedterm_resu[ids[i]] = struct{}{}
	}
}

// RemovedTermResu returns the removed ids of term_resu.
func (m *TermMutation) RemovedTermResuIDs() (ids []int) {
	for id := range m.removedterm_resu {
		ids = append(ids, id)
	}
	return
}

// TermResuIDs returns the term_resu ids in the mutation.
func (m *TermMutation) TermResuIDs() (ids []int) {
	for id := range m.term_resu {
		ids = append(ids, id)
	}
	return
}

// ResetTermResu reset all changes of the "term_resu" edge.
func (m *TermMutation) ResetTermResu() {
	m.term_resu = nil
	m.removedterm_resu = nil
}

// AddTermActiIDs adds the term_acti edge to Activity by ids.
func (m *TermMutation) AddTermActiIDs(ids ...int) {
	if m.term_acti == nil {
		m.term_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.term_acti[ids[i]] = struct{}{}
	}
}

// RemoveTermActiIDs removes the term_acti edge to Activity by ids.
func (m *TermMutation) RemoveTermActiIDs(ids ...int) {
	if m.removedterm_acti == nil {
		m.removedterm_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedterm_acti[ids[i]] = struct{}{}
	}
}

// RemovedTermActi returns the removed ids of term_acti.
func (m *TermMutation) RemovedTermActiIDs() (ids []int) {
	for id := range m.removedterm_acti {
		ids = append(ids, id)
	}
	return
}

// TermActiIDs returns the term_acti ids in the mutation.
func (m *TermMutation) TermActiIDs() (ids []int) {
	for id := range m.term_acti {
		ids = append(ids, id)
	}
	return
}

// ResetTermActi reset all changes of the "term_acti" edge.
func (m *TermMutation) ResetTermActi() {
	m.term_acti = nil
	m.removedterm_acti = nil
}

// Op returns the operation name.
func (m *TermMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Term).
func (m *TermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TermMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.semester != nil {
		fields = append(fields, term.FieldSemester)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case term.FieldSemester:
		return m.Semester()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case term.FieldSemester:
		return m.OldSemester(ctx)
	}
	return nil, fmt.Errorf("unknown Term field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case term.FieldSemester:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemester(v)
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TermMutation) AddedFields() []string {
	var fields []string
	if m.addsemester != nil {
		fields = append(fields, term.FieldSemester)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TermMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case term.FieldSemester:
		return m.AddedSemester()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) AddField(name string, value ent.Value) error {
	switch name {
	case term.FieldSemester:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSemester(v)
		return nil
	}
	return fmt.Errorf("unknown Term numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TermMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TermMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Term nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TermMutation) ResetField(name string) error {
	switch name {
	case term.FieldSemester:
		m.ResetSemester()
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TermMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.term_resu != nil {
		edges = append(edges, term.EdgeTermResu)
	}
	if m.term_acti != nil {
		edges = append(edges, term.EdgeTermActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case term.EdgeTermResu:
		ids := make([]ent.Value, 0, len(m.term_resu))
		for id := range m.term_resu {
			ids = append(ids, id)
		}
		return ids
	case term.EdgeTermActi:
		ids := make([]ent.Value, 0, len(m.term_acti))
		for id := range m.term_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedterm_resu != nil {
		edges = append(edges, term.EdgeTermResu)
	}
	if m.removedterm_acti != nil {
		edges = append(edges, term.EdgeTermActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TermMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case term.EdgeTermResu:
		ids := make([]ent.Value, 0, len(m.removedterm_resu))
		for id := range m.removedterm_resu {
			ids = append(ids, id)
		}
		return ids
	case term.EdgeTermActi:
		ids := make([]ent.Value, 0, len(m.removedterm_acti))
		for id := range m.removedterm_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TermMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TermMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Term unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TermMutation) ResetEdge(name string) error {
	switch name {
	case term.EdgeTermResu:
		m.ResetTermResu()
		return nil
	case term.EdgeTermActi:
		m.ResetTermActi()
		return nil
	}
	return fmt.Errorf("unknown Term edge %s", name)
}

// YearMutation represents an operation that mutate the Years
// nodes in the graph.
type YearMutation struct {
	config
	op               Op
	typ              string
	id               *int
	years            *int
	addyears         *int
	clearedFields    map[string]struct{}
	year_term        map[int]struct{}
	removedyear_term map[int]struct{}
	year_resu        map[int]struct{}
	removedyear_resu map[int]struct{}
	year_acti        map[int]struct{}
	removedyear_acti map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Year, error)
}

var _ ent.Mutation = (*YearMutation)(nil)

// yearOption allows to manage the mutation configuration using functional options.
type yearOption func(*YearMutation)

// newYearMutation creates new mutation for $n.Name.
func newYearMutation(c config, op Op, opts ...yearOption) *YearMutation {
	m := &YearMutation{
		config:        c,
		op:            op,
		typ:           TypeYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withYearID sets the id field of the mutation.
func withYearID(id int) yearOption {
	return func(m *YearMutation) {
		var (
			err   error
			once  sync.Once
			value *Year
		)
		m.oldValue = func(ctx context.Context) (*Year, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Year.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withYear sets the old Year of the mutation.
func withYear(node *Year) yearOption {
	return func(m *YearMutation) {
		m.oldValue = func(context.Context) (*Year, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m YearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m YearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *YearMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetYears sets the years field.
func (m *YearMutation) SetYears(i int) {
	m.years = &i
	m.addyears = nil
}

// Years returns the years value in the mutation.
func (m *YearMutation) Years() (r int, exists bool) {
	v := m.years
	if v == nil {
		return
	}
	return *v, true
}

// OldYears returns the old years value of the Year.
// If the Year object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *YearMutation) OldYears(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYears is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYears: %w", err)
	}
	return oldValue.Years, nil
}

// AddYears adds i to years.
func (m *YearMutation) AddYears(i int) {
	if m.addyears != nil {
		*m.addyears += i
	} else {
		m.addyears = &i
	}
}

// AddedYears returns the value that was added to the years field in this mutation.
func (m *YearMutation) AddedYears() (r int, exists bool) {
	v := m.addyears
	if v == nil {
		return
	}
	return *v, true
}

// ResetYears reset all changes of the "years" field.
func (m *YearMutation) ResetYears() {
	m.years = nil
	m.addyears = nil
}

// AddYearTermIDs adds the year_term edge to Term by ids.
func (m *YearMutation) AddYearTermIDs(ids ...int) {
	if m.year_term == nil {
		m.year_term = make(map[int]struct{})
	}
	for i := range ids {
		m.year_term[ids[i]] = struct{}{}
	}
}

// RemoveYearTermIDs removes the year_term edge to Term by ids.
func (m *YearMutation) RemoveYearTermIDs(ids ...int) {
	if m.removedyear_term == nil {
		m.removedyear_term = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_term[ids[i]] = struct{}{}
	}
}

// RemovedYearTerm returns the removed ids of year_term.
func (m *YearMutation) RemovedYearTermIDs() (ids []int) {
	for id := range m.removedyear_term {
		ids = append(ids, id)
	}
	return
}

// YearTermIDs returns the year_term ids in the mutation.
func (m *YearMutation) YearTermIDs() (ids []int) {
	for id := range m.year_term {
		ids = append(ids, id)
	}
	return
}

// ResetYearTerm reset all changes of the "year_term" edge.
func (m *YearMutation) ResetYearTerm() {
	m.year_term = nil
	m.removedyear_term = nil
}

// AddYearResuIDs adds the year_resu edge to Results by ids.
func (m *YearMutation) AddYearResuIDs(ids ...int) {
	if m.year_resu == nil {
		m.year_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.year_resu[ids[i]] = struct{}{}
	}
}

// RemoveYearResuIDs removes the year_resu edge to Results by ids.
func (m *YearMutation) RemoveYearResuIDs(ids ...int) {
	if m.removedyear_resu == nil {
		m.removedyear_resu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_resu[ids[i]] = struct{}{}
	}
}

// RemovedYearResu returns the removed ids of year_resu.
func (m *YearMutation) RemovedYearResuIDs() (ids []int) {
	for id := range m.removedyear_resu {
		ids = append(ids, id)
	}
	return
}

// YearResuIDs returns the year_resu ids in the mutation.
func (m *YearMutation) YearResuIDs() (ids []int) {
	for id := range m.year_resu {
		ids = append(ids, id)
	}
	return
}

// ResetYearResu reset all changes of the "year_resu" edge.
func (m *YearMutation) ResetYearResu() {
	m.year_resu = nil
	m.removedyear_resu = nil
}

// AddYearActiIDs adds the year_acti edge to Activity by ids.
func (m *YearMutation) AddYearActiIDs(ids ...int) {
	if m.year_acti == nil {
		m.year_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.year_acti[ids[i]] = struct{}{}
	}
}

// RemoveYearActiIDs removes the year_acti edge to Activity by ids.
func (m *YearMutation) RemoveYearActiIDs(ids ...int) {
	if m.removedyear_acti == nil {
		m.removedyear_acti = make(map[int]struct{})
	}
	for i := range ids {
		m.removedyear_acti[ids[i]] = struct{}{}
	}
}

// RemovedYearActi returns the removed ids of year_acti.
func (m *YearMutation) RemovedYearActiIDs() (ids []int) {
	for id := range m.removedyear_acti {
		ids = append(ids, id)
	}
	return
}

// YearActiIDs returns the year_acti ids in the mutation.
func (m *YearMutation) YearActiIDs() (ids []int) {
	for id := range m.year_acti {
		ids = append(ids, id)
	}
	return
}

// ResetYearActi reset all changes of the "year_acti" edge.
func (m *YearMutation) ResetYearActi() {
	m.year_acti = nil
	m.removedyear_acti = nil
}

// Op returns the operation name.
func (m *YearMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Year).
func (m *YearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *YearMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.years != nil {
		fields = append(fields, year.FieldYears)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *YearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYears:
		return m.Years()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *YearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case year.FieldYears:
		return m.OldYears(ctx)
	}
	return nil, fmt.Errorf("unknown Year field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case year.FieldYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYears(v)
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *YearMutation) AddedFields() []string {
	var fields []string
	if m.addyears != nil {
		fields = append(fields, year.FieldYears)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *YearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYears:
		return m.AddedYears()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case year.FieldYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYears(v)
		return nil
	}
	return fmt.Errorf("unknown Year numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *YearMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *YearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *YearMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Year nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *YearMutation) ResetField(name string) error {
	switch name {
	case year.FieldYears:
		m.ResetYears()
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *YearMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.year_term != nil {
		edges = append(edges, year.EdgeYearTerm)
	}
	if m.year_resu != nil {
		edges = append(edges, year.EdgeYearResu)
	}
	if m.year_acti != nil {
		edges = append(edges, year.EdgeYearActi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *YearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeYearTerm:
		ids := make([]ent.Value, 0, len(m.year_term))
		for id := range m.year_term {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearResu:
		ids := make([]ent.Value, 0, len(m.year_resu))
		for id := range m.year_resu {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearActi:
		ids := make([]ent.Value, 0, len(m.year_acti))
		for id := range m.year_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *YearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedyear_term != nil {
		edges = append(edges, year.EdgeYearTerm)
	}
	if m.removedyear_resu != nil {
		edges = append(edges, year.EdgeYearResu)
	}
	if m.removedyear_acti != nil {
		edges = append(edges, year.EdgeYearActi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *YearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeYearTerm:
		ids := make([]ent.Value, 0, len(m.removedyear_term))
		for id := range m.removedyear_term {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearResu:
		ids := make([]ent.Value, 0, len(m.removedyear_resu))
		for id := range m.removedyear_resu {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeYearActi:
		ids := make([]ent.Value, 0, len(m.removedyear_acti))
		for id := range m.removedyear_acti {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *YearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *YearMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *YearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Year unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *YearMutation) ResetEdge(name string) error {
	switch name {
	case year.EdgeYearTerm:
		m.ResetYearTerm()
		return nil
	case year.EdgeYearResu:
		m.ResetYearResu()
		return nil
	case year.EdgeYearActi:
		m.ResetYearActi()
		return nil
	}
	return fmt.Errorf("unknown Year edge %s", name)
}
