// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/sut63/team17/app/ent/migrate"

	"github.com/sut63/team17/app/ent/activity"
	"github.com/sut63/team17/app/ent/agency"
	"github.com/sut63/team17/app/ent/continent"
	"github.com/sut63/team17/app/ent/country"
	"github.com/sut63/team17/app/ent/course"
	"github.com/sut63/team17/app/ent/degree"
	"github.com/sut63/team17/app/ent/emp"
	"github.com/sut63/team17/app/ent/faculty"
	"github.com/sut63/team17/app/ent/gender"
	"github.com/sut63/team17/app/ent/institution"
	"github.com/sut63/team17/app/ent/place"
	"github.com/sut63/team17/app/ent/prefix"
	"github.com/sut63/team17/app/ent/professor"
	"github.com/sut63/team17/app/ent/professorship"
	"github.com/sut63/team17/app/ent/province"
	"github.com/sut63/team17/app/ent/region"
	"github.com/sut63/team17/app/ent/results"
	"github.com/sut63/team17/app/ent/student"
	"github.com/sut63/team17/app/ent/subject"
	"github.com/sut63/team17/app/ent/term"
	"github.com/sut63/team17/app/ent/year"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Activity is the client for interacting with the Activity builders.
	Activity *ActivityClient
	// Agency is the client for interacting with the Agency builders.
	Agency *AgencyClient
	// Continent is the client for interacting with the Continent builders.
	Continent *ContinentClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Course is the client for interacting with the Course builders.
	Course *CourseClient
	// Degree is the client for interacting with the Degree builders.
	Degree *DegreeClient
	// Emp is the client for interacting with the Emp builders.
	Emp *EmpClient
	// Faculty is the client for interacting with the Faculty builders.
	Faculty *FacultyClient
	// Gender is the client for interacting with the Gender builders.
	Gender *GenderClient
	// Institution is the client for interacting with the Institution builders.
	Institution *InstitutionClient
	// Place is the client for interacting with the Place builders.
	Place *PlaceClient
	// Prefix is the client for interacting with the Prefix builders.
	Prefix *PrefixClient
	// Professor is the client for interacting with the Professor builders.
	Professor *ProfessorClient
	// Professorship is the client for interacting with the Professorship builders.
	Professorship *ProfessorshipClient
	// Province is the client for interacting with the Province builders.
	Province *ProvinceClient
	// Region is the client for interacting with the Region builders.
	Region *RegionClient
	// Results is the client for interacting with the Results builders.
	Results *ResultsClient
	// Student is the client for interacting with the Student builders.
	Student *StudentClient
	// Subject is the client for interacting with the Subject builders.
	Subject *SubjectClient
	// Term is the client for interacting with the Term builders.
	Term *TermClient
	// Year is the client for interacting with the Year builders.
	Year *YearClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Activity = NewActivityClient(c.config)
	c.Agency = NewAgencyClient(c.config)
	c.Continent = NewContinentClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Course = NewCourseClient(c.config)
	c.Degree = NewDegreeClient(c.config)
	c.Emp = NewEmpClient(c.config)
	c.Faculty = NewFacultyClient(c.config)
	c.Gender = NewGenderClient(c.config)
	c.Institution = NewInstitutionClient(c.config)
	c.Place = NewPlaceClient(c.config)
	c.Prefix = NewPrefixClient(c.config)
	c.Professor = NewProfessorClient(c.config)
	c.Professorship = NewProfessorshipClient(c.config)
	c.Province = NewProvinceClient(c.config)
	c.Region = NewRegionClient(c.config)
	c.Results = NewResultsClient(c.config)
	c.Student = NewStudentClient(c.config)
	c.Subject = NewSubjectClient(c.config)
	c.Term = NewTermClient(c.config)
	c.Year = NewYearClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Activity:      NewActivityClient(cfg),
		Agency:        NewAgencyClient(cfg),
		Continent:     NewContinentClient(cfg),
		Country:       NewCountryClient(cfg),
		Course:        NewCourseClient(cfg),
		Degree:        NewDegreeClient(cfg),
		Emp:           NewEmpClient(cfg),
		Faculty:       NewFacultyClient(cfg),
		Gender:        NewGenderClient(cfg),
		Institution:   NewInstitutionClient(cfg),
		Place:         NewPlaceClient(cfg),
		Prefix:        NewPrefixClient(cfg),
		Professor:     NewProfessorClient(cfg),
		Professorship: NewProfessorshipClient(cfg),
		Province:      NewProvinceClient(cfg),
		Region:        NewRegionClient(cfg),
		Results:       NewResultsClient(cfg),
		Student:       NewStudentClient(cfg),
		Subject:       NewSubjectClient(cfg),
		Term:          NewTermClient(cfg),
		Year:          NewYearClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:        cfg,
		Activity:      NewActivityClient(cfg),
		Agency:        NewAgencyClient(cfg),
		Continent:     NewContinentClient(cfg),
		Country:       NewCountryClient(cfg),
		Course:        NewCourseClient(cfg),
		Degree:        NewDegreeClient(cfg),
		Emp:           NewEmpClient(cfg),
		Faculty:       NewFacultyClient(cfg),
		Gender:        NewGenderClient(cfg),
		Institution:   NewInstitutionClient(cfg),
		Place:         NewPlaceClient(cfg),
		Prefix:        NewPrefixClient(cfg),
		Professor:     NewProfessorClient(cfg),
		Professorship: NewProfessorshipClient(cfg),
		Province:      NewProvinceClient(cfg),
		Region:        NewRegionClient(cfg),
		Results:       NewResultsClient(cfg),
		Student:       NewStudentClient(cfg),
		Subject:       NewSubjectClient(cfg),
		Term:          NewTermClient(cfg),
		Year:          NewYearClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Activity.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Activity.Use(hooks...)
	c.Agency.Use(hooks...)
	c.Continent.Use(hooks...)
	c.Country.Use(hooks...)
	c.Course.Use(hooks...)
	c.Degree.Use(hooks...)
	c.Emp.Use(hooks...)
	c.Faculty.Use(hooks...)
	c.Gender.Use(hooks...)
	c.Institution.Use(hooks...)
	c.Place.Use(hooks...)
	c.Prefix.Use(hooks...)
	c.Professor.Use(hooks...)
	c.Professorship.Use(hooks...)
	c.Province.Use(hooks...)
	c.Region.Use(hooks...)
	c.Results.Use(hooks...)
	c.Student.Use(hooks...)
	c.Subject.Use(hooks...)
	c.Term.Use(hooks...)
	c.Year.Use(hooks...)
}

// ActivityClient is a client for the Activity schema.
type ActivityClient struct {
	config
}

// NewActivityClient returns a client for the Activity from the given config.
func NewActivityClient(c config) *ActivityClient {
	return &ActivityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activity.Hooks(f(g(h())))`.
func (c *ActivityClient) Use(hooks ...Hook) {
	c.hooks.Activity = append(c.hooks.Activity, hooks...)
}

// Create returns a create builder for Activity.
func (c *ActivityClient) Create() *ActivityCreate {
	mutation := newActivityMutation(c.config, OpCreate)
	return &ActivityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Activity.
func (c *ActivityClient) Update() *ActivityUpdate {
	mutation := newActivityMutation(c.config, OpUpdate)
	return &ActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityClient) UpdateOne(a *Activity) *ActivityUpdateOne {
	mutation := newActivityMutation(c.config, OpUpdateOne, withActivity(a))
	return &ActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityClient) UpdateOneID(id int) *ActivityUpdateOne {
	mutation := newActivityMutation(c.config, OpUpdateOne, withActivityID(id))
	return &ActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Activity.
func (c *ActivityClient) Delete() *ActivityDelete {
	mutation := newActivityMutation(c.config, OpDelete)
	return &ActivityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ActivityClient) DeleteOne(a *Activity) *ActivityDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ActivityClient) DeleteOneID(id int) *ActivityDeleteOne {
	builder := c.Delete().Where(activity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityDeleteOne{builder}
}

// Create returns a query builder for Activity.
func (c *ActivityClient) Query() *ActivityQuery {
	return &ActivityQuery{config: c.config}
}

// Get returns a Activity entity by its id.
func (c *ActivityClient) Get(ctx context.Context, id int) (*Activity, error) {
	return c.Query().Where(activity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityClient) GetX(ctx context.Context, id int) *Activity {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryActiStud queries the acti_stud edge of a Activity.
func (c *ActivityClient) QueryActiStud(a *Activity) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activity.Table, activity.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activity.ActiStudTable, activity.ActiStudColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiPlace queries the acti_place edge of a Activity.
func (c *ActivityClient) QueryActiPlace(a *Activity) *PlaceQuery {
	query := &PlaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activity.Table, activity.FieldID, id),
			sqlgraph.To(place.Table, place.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activity.ActiPlaceTable, activity.ActiPlaceColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiAgen queries the acti_agen edge of a Activity.
func (c *ActivityClient) QueryActiAgen(a *Activity) *AgencyQuery {
	query := &AgencyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activity.Table, activity.FieldID, id),
			sqlgraph.To(agency.Table, agency.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activity.ActiAgenTable, activity.ActiAgenColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiYear queries the acti_year edge of a Activity.
func (c *ActivityClient) QueryActiYear(a *Activity) *YearQuery {
	query := &YearQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activity.Table, activity.FieldID, id),
			sqlgraph.To(year.Table, year.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activity.ActiYearTable, activity.ActiYearColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiTerm queries the acti_term edge of a Activity.
func (c *ActivityClient) QueryActiTerm(a *Activity) *TermQuery {
	query := &TermQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activity.Table, activity.FieldID, id),
			sqlgraph.To(term.Table, term.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activity.ActiTermTable, activity.ActiTermColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityClient) Hooks() []Hook {
	return c.hooks.Activity
}

// AgencyClient is a client for the Agency schema.
type AgencyClient struct {
	config
}

// NewAgencyClient returns a client for the Agency from the given config.
func NewAgencyClient(c config) *AgencyClient {
	return &AgencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agency.Hooks(f(g(h())))`.
func (c *AgencyClient) Use(hooks ...Hook) {
	c.hooks.Agency = append(c.hooks.Agency, hooks...)
}

// Create returns a create builder for Agency.
func (c *AgencyClient) Create() *AgencyCreate {
	mutation := newAgencyMutation(c.config, OpCreate)
	return &AgencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Agency.
func (c *AgencyClient) Update() *AgencyUpdate {
	mutation := newAgencyMutation(c.config, OpUpdate)
	return &AgencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgencyClient) UpdateOne(a *Agency) *AgencyUpdateOne {
	mutation := newAgencyMutation(c.config, OpUpdateOne, withAgency(a))
	return &AgencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgencyClient) UpdateOneID(id int) *AgencyUpdateOne {
	mutation := newAgencyMutation(c.config, OpUpdateOne, withAgencyID(id))
	return &AgencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agency.
func (c *AgencyClient) Delete() *AgencyDelete {
	mutation := newAgencyMutation(c.config, OpDelete)
	return &AgencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AgencyClient) DeleteOne(a *Agency) *AgencyDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AgencyClient) DeleteOneID(id int) *AgencyDeleteOne {
	builder := c.Delete().Where(agency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgencyDeleteOne{builder}
}

// Create returns a query builder for Agency.
func (c *AgencyClient) Query() *AgencyQuery {
	return &AgencyQuery{config: c.config}
}

// Get returns a Agency entity by its id.
func (c *AgencyClient) Get(ctx context.Context, id int) (*Agency, error) {
	return c.Query().Where(agency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgencyClient) GetX(ctx context.Context, id int) *Agency {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryAgenActi queries the agen_acti edge of a Agency.
func (c *AgencyClient) QueryAgenActi(a *Agency) *ActivityQuery {
	query := &ActivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agency.Table, agency.FieldID, id),
			sqlgraph.To(activity.Table, activity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agency.AgenActiTable, agency.AgenActiColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgencyClient) Hooks() []Hook {
	return c.hooks.Agency
}

// ContinentClient is a client for the Continent schema.
type ContinentClient struct {
	config
}

// NewContinentClient returns a client for the Continent from the given config.
func NewContinentClient(c config) *ContinentClient {
	return &ContinentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `continent.Hooks(f(g(h())))`.
func (c *ContinentClient) Use(hooks ...Hook) {
	c.hooks.Continent = append(c.hooks.Continent, hooks...)
}

// Create returns a create builder for Continent.
func (c *ContinentClient) Create() *ContinentCreate {
	mutation := newContinentMutation(c.config, OpCreate)
	return &ContinentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Continent.
func (c *ContinentClient) Update() *ContinentUpdate {
	mutation := newContinentMutation(c.config, OpUpdate)
	return &ContinentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContinentClient) UpdateOne(co *Continent) *ContinentUpdateOne {
	mutation := newContinentMutation(c.config, OpUpdateOne, withContinent(co))
	return &ContinentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContinentClient) UpdateOneID(id int) *ContinentUpdateOne {
	mutation := newContinentMutation(c.config, OpUpdateOne, withContinentID(id))
	return &ContinentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Continent.
func (c *ContinentClient) Delete() *ContinentDelete {
	mutation := newContinentMutation(c.config, OpDelete)
	return &ContinentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ContinentClient) DeleteOne(co *Continent) *ContinentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ContinentClient) DeleteOneID(id int) *ContinentDeleteOne {
	builder := c.Delete().Where(continent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContinentDeleteOne{builder}
}

// Create returns a query builder for Continent.
func (c *ContinentClient) Query() *ContinentQuery {
	return &ContinentQuery{config: c.config}
}

// Get returns a Continent entity by its id.
func (c *ContinentClient) Get(ctx context.Context, id int) (*Continent, error) {
	return c.Query().Where(continent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContinentClient) GetX(ctx context.Context, id int) *Continent {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryContProv queries the cont_prov edge of a Continent.
func (c *ContinentClient) QueryContProv(co *Continent) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(continent.Table, continent.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, continent.ContProvTable, continent.ContProvColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContinentClient) Hooks() []Hook {
	return c.hooks.Continent
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Create returns a create builder for Country.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id int) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CountryClient) DeleteOneID(id int) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Create returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{config: c.config}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id int) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id int) *Country {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryCounProv queries the coun_prov edge of a Country.
func (c *CountryClient) QueryCounProv(co *Country) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.CounProvTable, country.CounProvColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	return c.hooks.Country
}

// CourseClient is a client for the Course schema.
type CourseClient struct {
	config
}

// NewCourseClient returns a client for the Course from the given config.
func NewCourseClient(c config) *CourseClient {
	return &CourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `course.Hooks(f(g(h())))`.
func (c *CourseClient) Use(hooks ...Hook) {
	c.hooks.Course = append(c.hooks.Course, hooks...)
}

// Create returns a create builder for Course.
func (c *CourseClient) Create() *CourseCreate {
	mutation := newCourseMutation(c.config, OpCreate)
	return &CourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Course.
func (c *CourseClient) Update() *CourseUpdate {
	mutation := newCourseMutation(c.config, OpUpdate)
	return &CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseClient) UpdateOne(co *Course) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourse(co))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseClient) UpdateOneID(id int) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourseID(id))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Course.
func (c *CourseClient) Delete() *CourseDelete {
	mutation := newCourseMutation(c.config, OpDelete)
	return &CourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CourseClient) DeleteOne(co *Course) *CourseDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CourseClient) DeleteOneID(id int) *CourseDeleteOne {
	builder := c.Delete().Where(course.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseDeleteOne{builder}
}

// Create returns a query builder for Course.
func (c *CourseClient) Query() *CourseQuery {
	return &CourseQuery{config: c.config}
}

// Get returns a Course entity by its id.
func (c *CourseClient) Get(ctx context.Context, id int) (*Course, error) {
	return c.Query().Where(course.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseClient) GetX(ctx context.Context, id int) *Course {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryCourFacu queries the cour_facu edge of a Course.
func (c *CourseClient) QueryCourFacu(co *Course) *FacultyQuery {
	query := &FacultyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(faculty.Table, faculty.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.CourFacuTable, course.CourFacuColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourDegr queries the cour_degr edge of a Course.
func (c *CourseClient) QueryCourDegr(co *Course) *DegreeQuery {
	query := &DegreeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(degree.Table, degree.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.CourDegrTable, course.CourDegrColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourInst queries the cour_inst edge of a Course.
func (c *CourseClient) QueryCourInst(co *Course) *InstitutionQuery {
	query := &InstitutionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(institution.Table, institution.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.CourInstTable, course.CourInstColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseClient) Hooks() []Hook {
	return c.hooks.Course
}

// DegreeClient is a client for the Degree schema.
type DegreeClient struct {
	config
}

// NewDegreeClient returns a client for the Degree from the given config.
func NewDegreeClient(c config) *DegreeClient {
	return &DegreeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `degree.Hooks(f(g(h())))`.
func (c *DegreeClient) Use(hooks ...Hook) {
	c.hooks.Degree = append(c.hooks.Degree, hooks...)
}

// Create returns a create builder for Degree.
func (c *DegreeClient) Create() *DegreeCreate {
	mutation := newDegreeMutation(c.config, OpCreate)
	return &DegreeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Degree.
func (c *DegreeClient) Update() *DegreeUpdate {
	mutation := newDegreeMutation(c.config, OpUpdate)
	return &DegreeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DegreeClient) UpdateOne(d *Degree) *DegreeUpdateOne {
	mutation := newDegreeMutation(c.config, OpUpdateOne, withDegree(d))
	return &DegreeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DegreeClient) UpdateOneID(id int) *DegreeUpdateOne {
	mutation := newDegreeMutation(c.config, OpUpdateOne, withDegreeID(id))
	return &DegreeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Degree.
func (c *DegreeClient) Delete() *DegreeDelete {
	mutation := newDegreeMutation(c.config, OpDelete)
	return &DegreeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DegreeClient) DeleteOne(d *Degree) *DegreeDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DegreeClient) DeleteOneID(id int) *DegreeDeleteOne {
	builder := c.Delete().Where(degree.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DegreeDeleteOne{builder}
}

// Create returns a query builder for Degree.
func (c *DegreeClient) Query() *DegreeQuery {
	return &DegreeQuery{config: c.config}
}

// Get returns a Degree entity by its id.
func (c *DegreeClient) Get(ctx context.Context, id int) (*Degree, error) {
	return c.Query().Where(degree.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DegreeClient) GetX(ctx context.Context, id int) *Degree {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QueryDegrStud queries the degr_stud edge of a Degree.
func (c *DegreeClient) QueryDegrStud(d *Degree) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(degree.Table, degree.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, degree.DegrStudTable, degree.DegrStudColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDegrCour queries the degr_cour edge of a Degree.
func (c *DegreeClient) QueryDegrCour(d *Degree) *CourseQuery {
	query := &CourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(degree.Table, degree.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, degree.DegrCourTable, degree.DegrCourColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DegreeClient) Hooks() []Hook {
	return c.hooks.Degree
}

// EmpClient is a client for the Emp schema.
type EmpClient struct {
	config
}

// NewEmpClient returns a client for the Emp from the given config.
func NewEmpClient(c config) *EmpClient {
	return &EmpClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emp.Hooks(f(g(h())))`.
func (c *EmpClient) Use(hooks ...Hook) {
	c.hooks.Emp = append(c.hooks.Emp, hooks...)
}

// Create returns a create builder for Emp.
func (c *EmpClient) Create() *EmpCreate {
	mutation := newEmpMutation(c.config, OpCreate)
	return &EmpCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Emp.
func (c *EmpClient) Update() *EmpUpdate {
	mutation := newEmpMutation(c.config, OpUpdate)
	return &EmpUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmpClient) UpdateOne(e *Emp) *EmpUpdateOne {
	mutation := newEmpMutation(c.config, OpUpdateOne, withEmp(e))
	return &EmpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmpClient) UpdateOneID(id int) *EmpUpdateOne {
	mutation := newEmpMutation(c.config, OpUpdateOne, withEmpID(id))
	return &EmpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Emp.
func (c *EmpClient) Delete() *EmpDelete {
	mutation := newEmpMutation(c.config, OpDelete)
	return &EmpDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EmpClient) DeleteOne(e *Emp) *EmpDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EmpClient) DeleteOneID(id int) *EmpDeleteOne {
	builder := c.Delete().Where(emp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmpDeleteOne{builder}
}

// Create returns a query builder for Emp.
func (c *EmpClient) Query() *EmpQuery {
	return &EmpQuery{config: c.config}
}

// Get returns a Emp entity by its id.
func (c *EmpClient) Get(ctx context.Context, id int) (*Emp, error) {
	return c.Query().Where(emp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmpClient) GetX(ctx context.Context, id int) *Emp {
	e, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return e
}

// Hooks returns the client hooks.
func (c *EmpClient) Hooks() []Hook {
	return c.hooks.Emp
}

// FacultyClient is a client for the Faculty schema.
type FacultyClient struct {
	config
}

// NewFacultyClient returns a client for the Faculty from the given config.
func NewFacultyClient(c config) *FacultyClient {
	return &FacultyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `faculty.Hooks(f(g(h())))`.
func (c *FacultyClient) Use(hooks ...Hook) {
	c.hooks.Faculty = append(c.hooks.Faculty, hooks...)
}

// Create returns a create builder for Faculty.
func (c *FacultyClient) Create() *FacultyCreate {
	mutation := newFacultyMutation(c.config, OpCreate)
	return &FacultyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Faculty.
func (c *FacultyClient) Update() *FacultyUpdate {
	mutation := newFacultyMutation(c.config, OpUpdate)
	return &FacultyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FacultyClient) UpdateOne(f *Faculty) *FacultyUpdateOne {
	mutation := newFacultyMutation(c.config, OpUpdateOne, withFaculty(f))
	return &FacultyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FacultyClient) UpdateOneID(id int) *FacultyUpdateOne {
	mutation := newFacultyMutation(c.config, OpUpdateOne, withFacultyID(id))
	return &FacultyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Faculty.
func (c *FacultyClient) Delete() *FacultyDelete {
	mutation := newFacultyMutation(c.config, OpDelete)
	return &FacultyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FacultyClient) DeleteOne(f *Faculty) *FacultyDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FacultyClient) DeleteOneID(id int) *FacultyDeleteOne {
	builder := c.Delete().Where(faculty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FacultyDeleteOne{builder}
}

// Create returns a query builder for Faculty.
func (c *FacultyClient) Query() *FacultyQuery {
	return &FacultyQuery{config: c.config}
}

// Get returns a Faculty entity by its id.
func (c *FacultyClient) Get(ctx context.Context, id int) (*Faculty, error) {
	return c.Query().Where(faculty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FacultyClient) GetX(ctx context.Context, id int) *Faculty {
	f, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return f
}

// QueryFacuCour queries the facu_cour edge of a Faculty.
func (c *FacultyClient) QueryFacuCour(f *Faculty) *CourseQuery {
	query := &CourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faculty.Table, faculty.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, faculty.FacuCourTable, faculty.FacuCourColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFacuProf queries the facu_prof edge of a Faculty.
func (c *FacultyClient) QueryFacuProf(f *Faculty) *ProfessorQuery {
	query := &ProfessorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faculty.Table, faculty.FieldID, id),
			sqlgraph.To(professor.Table, professor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, faculty.FacuProfTable, faculty.FacuProfColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FacultyClient) Hooks() []Hook {
	return c.hooks.Faculty
}

// GenderClient is a client for the Gender schema.
type GenderClient struct {
	config
}

// NewGenderClient returns a client for the Gender from the given config.
func NewGenderClient(c config) *GenderClient {
	return &GenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gender.Hooks(f(g(h())))`.
func (c *GenderClient) Use(hooks ...Hook) {
	c.hooks.Gender = append(c.hooks.Gender, hooks...)
}

// Create returns a create builder for Gender.
func (c *GenderClient) Create() *GenderCreate {
	mutation := newGenderMutation(c.config, OpCreate)
	return &GenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Gender.
func (c *GenderClient) Update() *GenderUpdate {
	mutation := newGenderMutation(c.config, OpUpdate)
	return &GenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenderClient) UpdateOne(ge *Gender) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGender(ge))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenderClient) UpdateOneID(id int) *GenderUpdateOne {
	mutation := newGenderMutation(c.config, OpUpdateOne, withGenderID(id))
	return &GenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gender.
func (c *GenderClient) Delete() *GenderDelete {
	mutation := newGenderMutation(c.config, OpDelete)
	return &GenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GenderClient) DeleteOne(ge *Gender) *GenderDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GenderClient) DeleteOneID(id int) *GenderDeleteOne {
	builder := c.Delete().Where(gender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenderDeleteOne{builder}
}

// Create returns a query builder for Gender.
func (c *GenderClient) Query() *GenderQuery {
	return &GenderQuery{config: c.config}
}

// Get returns a Gender entity by its id.
func (c *GenderClient) Get(ctx context.Context, id int) (*Gender, error) {
	return c.Query().Where(gender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenderClient) GetX(ctx context.Context, id int) *Gender {
	ge, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ge
}

// QueryGendStud queries the gend_stud edge of a Gender.
func (c *GenderClient) QueryGendStud(ge *Gender) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gender.Table, gender.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gender.GendStudTable, gender.GendStudColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenderClient) Hooks() []Hook {
	return c.hooks.Gender
}

// InstitutionClient is a client for the Institution schema.
type InstitutionClient struct {
	config
}

// NewInstitutionClient returns a client for the Institution from the given config.
func NewInstitutionClient(c config) *InstitutionClient {
	return &InstitutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `institution.Hooks(f(g(h())))`.
func (c *InstitutionClient) Use(hooks ...Hook) {
	c.hooks.Institution = append(c.hooks.Institution, hooks...)
}

// Create returns a create builder for Institution.
func (c *InstitutionClient) Create() *InstitutionCreate {
	mutation := newInstitutionMutation(c.config, OpCreate)
	return &InstitutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Institution.
func (c *InstitutionClient) Update() *InstitutionUpdate {
	mutation := newInstitutionMutation(c.config, OpUpdate)
	return &InstitutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstitutionClient) UpdateOne(i *Institution) *InstitutionUpdateOne {
	mutation := newInstitutionMutation(c.config, OpUpdateOne, withInstitution(i))
	return &InstitutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstitutionClient) UpdateOneID(id int) *InstitutionUpdateOne {
	mutation := newInstitutionMutation(c.config, OpUpdateOne, withInstitutionID(id))
	return &InstitutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Institution.
func (c *InstitutionClient) Delete() *InstitutionDelete {
	mutation := newInstitutionMutation(c.config, OpDelete)
	return &InstitutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InstitutionClient) DeleteOne(i *Institution) *InstitutionDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InstitutionClient) DeleteOneID(id int) *InstitutionDeleteOne {
	builder := c.Delete().Where(institution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstitutionDeleteOne{builder}
}

// Create returns a query builder for Institution.
func (c *InstitutionClient) Query() *InstitutionQuery {
	return &InstitutionQuery{config: c.config}
}

// Get returns a Institution entity by its id.
func (c *InstitutionClient) Get(ctx context.Context, id int) (*Institution, error) {
	return c.Query().Where(institution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstitutionClient) GetX(ctx context.Context, id int) *Institution {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryInstCour queries the inst_cour edge of a Institution.
func (c *InstitutionClient) QueryInstCour(i *Institution) *CourseQuery {
	query := &CourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(institution.Table, institution.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, institution.InstCourTable, institution.InstCourColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstitutionClient) Hooks() []Hook {
	return c.hooks.Institution
}

// PlaceClient is a client for the Place schema.
type PlaceClient struct {
	config
}

// NewPlaceClient returns a client for the Place from the given config.
func NewPlaceClient(c config) *PlaceClient {
	return &PlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `place.Hooks(f(g(h())))`.
func (c *PlaceClient) Use(hooks ...Hook) {
	c.hooks.Place = append(c.hooks.Place, hooks...)
}

// Create returns a create builder for Place.
func (c *PlaceClient) Create() *PlaceCreate {
	mutation := newPlaceMutation(c.config, OpCreate)
	return &PlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Place.
func (c *PlaceClient) Update() *PlaceUpdate {
	mutation := newPlaceMutation(c.config, OpUpdate)
	return &PlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaceClient) UpdateOne(pl *Place) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlace(pl))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaceClient) UpdateOneID(id int) *PlaceUpdateOne {
	mutation := newPlaceMutation(c.config, OpUpdateOne, withPlaceID(id))
	return &PlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Place.
func (c *PlaceClient) Delete() *PlaceDelete {
	mutation := newPlaceMutation(c.config, OpDelete)
	return &PlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PlaceClient) DeleteOne(pl *Place) *PlaceDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PlaceClient) DeleteOneID(id int) *PlaceDeleteOne {
	builder := c.Delete().Where(place.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaceDeleteOne{builder}
}

// Create returns a query builder for Place.
func (c *PlaceClient) Query() *PlaceQuery {
	return &PlaceQuery{config: c.config}
}

// Get returns a Place entity by its id.
func (c *PlaceClient) Get(ctx context.Context, id int) (*Place, error) {
	return c.Query().Where(place.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaceClient) GetX(ctx context.Context, id int) *Place {
	pl, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pl
}

// QueryPlaceActi queries the place_acti edge of a Place.
func (c *PlaceClient) QueryPlaceActi(pl *Place) *ActivityQuery {
	query := &ActivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(place.Table, place.FieldID, id),
			sqlgraph.To(activity.Table, activity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, place.PlaceActiTable, place.PlaceActiColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaceClient) Hooks() []Hook {
	return c.hooks.Place
}

// PrefixClient is a client for the Prefix schema.
type PrefixClient struct {
	config
}

// NewPrefixClient returns a client for the Prefix from the given config.
func NewPrefixClient(c config) *PrefixClient {
	return &PrefixClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prefix.Hooks(f(g(h())))`.
func (c *PrefixClient) Use(hooks ...Hook) {
	c.hooks.Prefix = append(c.hooks.Prefix, hooks...)
}

// Create returns a create builder for Prefix.
func (c *PrefixClient) Create() *PrefixCreate {
	mutation := newPrefixMutation(c.config, OpCreate)
	return &PrefixCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Prefix.
func (c *PrefixClient) Update() *PrefixUpdate {
	mutation := newPrefixMutation(c.config, OpUpdate)
	return &PrefixUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrefixClient) UpdateOne(pr *Prefix) *PrefixUpdateOne {
	mutation := newPrefixMutation(c.config, OpUpdateOne, withPrefix(pr))
	return &PrefixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrefixClient) UpdateOneID(id int) *PrefixUpdateOne {
	mutation := newPrefixMutation(c.config, OpUpdateOne, withPrefixID(id))
	return &PrefixUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prefix.
func (c *PrefixClient) Delete() *PrefixDelete {
	mutation := newPrefixMutation(c.config, OpDelete)
	return &PrefixDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PrefixClient) DeleteOne(pr *Prefix) *PrefixDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PrefixClient) DeleteOneID(id int) *PrefixDeleteOne {
	builder := c.Delete().Where(prefix.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrefixDeleteOne{builder}
}

// Create returns a query builder for Prefix.
func (c *PrefixClient) Query() *PrefixQuery {
	return &PrefixQuery{config: c.config}
}

// Get returns a Prefix entity by its id.
func (c *PrefixClient) Get(ctx context.Context, id int) (*Prefix, error) {
	return c.Query().Where(prefix.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrefixClient) GetX(ctx context.Context, id int) *Prefix {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryPreProf queries the pre_prof edge of a Prefix.
func (c *PrefixClient) QueryPreProf(pr *Prefix) *ProfessorQuery {
	query := &ProfessorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prefix.Table, prefix.FieldID, id),
			sqlgraph.To(professor.Table, professor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prefix.PreProfTable, prefix.PreProfColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrefStud queries the pref_stud edge of a Prefix.
func (c *PrefixClient) QueryPrefStud(pr *Prefix) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prefix.Table, prefix.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prefix.PrefStudTable, prefix.PrefStudColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrefixClient) Hooks() []Hook {
	return c.hooks.Prefix
}

// ProfessorClient is a client for the Professor schema.
type ProfessorClient struct {
	config
}

// NewProfessorClient returns a client for the Professor from the given config.
func NewProfessorClient(c config) *ProfessorClient {
	return &ProfessorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `professor.Hooks(f(g(h())))`.
func (c *ProfessorClient) Use(hooks ...Hook) {
	c.hooks.Professor = append(c.hooks.Professor, hooks...)
}

// Create returns a create builder for Professor.
func (c *ProfessorClient) Create() *ProfessorCreate {
	mutation := newProfessorMutation(c.config, OpCreate)
	return &ProfessorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Professor.
func (c *ProfessorClient) Update() *ProfessorUpdate {
	mutation := newProfessorMutation(c.config, OpUpdate)
	return &ProfessorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfessorClient) UpdateOne(pr *Professor) *ProfessorUpdateOne {
	mutation := newProfessorMutation(c.config, OpUpdateOne, withProfessor(pr))
	return &ProfessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfessorClient) UpdateOneID(id int) *ProfessorUpdateOne {
	mutation := newProfessorMutation(c.config, OpUpdateOne, withProfessorID(id))
	return &ProfessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Professor.
func (c *ProfessorClient) Delete() *ProfessorDelete {
	mutation := newProfessorMutation(c.config, OpDelete)
	return &ProfessorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProfessorClient) DeleteOne(pr *Professor) *ProfessorDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProfessorClient) DeleteOneID(id int) *ProfessorDeleteOne {
	builder := c.Delete().Where(professor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfessorDeleteOne{builder}
}

// Create returns a query builder for Professor.
func (c *ProfessorClient) Query() *ProfessorQuery {
	return &ProfessorQuery{config: c.config}
}

// Get returns a Professor entity by its id.
func (c *ProfessorClient) Get(ctx context.Context, id int) (*Professor, error) {
	return c.Query().Where(professor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfessorClient) GetX(ctx context.Context, id int) *Professor {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryProfPre queries the prof_pre edge of a Professor.
func (c *ProfessorClient) QueryProfPre(pr *Professor) *PrefixQuery {
	query := &PrefixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(professor.Table, professor.FieldID, id),
			sqlgraph.To(prefix.Table, prefix.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, professor.ProfPreTable, professor.ProfPreColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfFacu queries the prof_facu edge of a Professor.
func (c *ProfessorClient) QueryProfFacu(pr *Professor) *FacultyQuery {
	query := &FacultyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(professor.Table, professor.FieldID, id),
			sqlgraph.To(faculty.Table, faculty.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, professor.ProfFacuTable, professor.ProfFacuColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfPros queries the prof_pros edge of a Professor.
func (c *ProfessorClient) QueryProfPros(pr *Professor) *ProfessorshipQuery {
	query := &ProfessorshipQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(professor.Table, professor.FieldID, id),
			sqlgraph.To(professorship.Table, professorship.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, professor.ProfProsTable, professor.ProfProsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfessorClient) Hooks() []Hook {
	return c.hooks.Professor
}

// ProfessorshipClient is a client for the Professorship schema.
type ProfessorshipClient struct {
	config
}

// NewProfessorshipClient returns a client for the Professorship from the given config.
func NewProfessorshipClient(c config) *ProfessorshipClient {
	return &ProfessorshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `professorship.Hooks(f(g(h())))`.
func (c *ProfessorshipClient) Use(hooks ...Hook) {
	c.hooks.Professorship = append(c.hooks.Professorship, hooks...)
}

// Create returns a create builder for Professorship.
func (c *ProfessorshipClient) Create() *ProfessorshipCreate {
	mutation := newProfessorshipMutation(c.config, OpCreate)
	return &ProfessorshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Professorship.
func (c *ProfessorshipClient) Update() *ProfessorshipUpdate {
	mutation := newProfessorshipMutation(c.config, OpUpdate)
	return &ProfessorshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfessorshipClient) UpdateOne(pr *Professorship) *ProfessorshipUpdateOne {
	mutation := newProfessorshipMutation(c.config, OpUpdateOne, withProfessorship(pr))
	return &ProfessorshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfessorshipClient) UpdateOneID(id int) *ProfessorshipUpdateOne {
	mutation := newProfessorshipMutation(c.config, OpUpdateOne, withProfessorshipID(id))
	return &ProfessorshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Professorship.
func (c *ProfessorshipClient) Delete() *ProfessorshipDelete {
	mutation := newProfessorshipMutation(c.config, OpDelete)
	return &ProfessorshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProfessorshipClient) DeleteOne(pr *Professorship) *ProfessorshipDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProfessorshipClient) DeleteOneID(id int) *ProfessorshipDeleteOne {
	builder := c.Delete().Where(professorship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfessorshipDeleteOne{builder}
}

// Create returns a query builder for Professorship.
func (c *ProfessorshipClient) Query() *ProfessorshipQuery {
	return &ProfessorshipQuery{config: c.config}
}

// Get returns a Professorship entity by its id.
func (c *ProfessorshipClient) Get(ctx context.Context, id int) (*Professorship, error) {
	return c.Query().Where(professorship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfessorshipClient) GetX(ctx context.Context, id int) *Professorship {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryProsProf queries the pros_prof edge of a Professorship.
func (c *ProfessorshipClient) QueryProsProf(pr *Professorship) *ProfessorQuery {
	query := &ProfessorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(professorship.Table, professorship.FieldID, id),
			sqlgraph.To(professor.Table, professor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, professorship.ProsProfTable, professorship.ProsProfColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfessorshipClient) Hooks() []Hook {
	return c.hooks.Professorship
}

// ProvinceClient is a client for the Province schema.
type ProvinceClient struct {
	config
}

// NewProvinceClient returns a client for the Province from the given config.
func NewProvinceClient(c config) *ProvinceClient {
	return &ProvinceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `province.Hooks(f(g(h())))`.
func (c *ProvinceClient) Use(hooks ...Hook) {
	c.hooks.Province = append(c.hooks.Province, hooks...)
}

// Create returns a create builder for Province.
func (c *ProvinceClient) Create() *ProvinceCreate {
	mutation := newProvinceMutation(c.config, OpCreate)
	return &ProvinceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Province.
func (c *ProvinceClient) Update() *ProvinceUpdate {
	mutation := newProvinceMutation(c.config, OpUpdate)
	return &ProvinceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvinceClient) UpdateOne(pr *Province) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvince(pr))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvinceClient) UpdateOneID(id int) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvinceID(id))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Province.
func (c *ProvinceClient) Delete() *ProvinceDelete {
	mutation := newProvinceMutation(c.config, OpDelete)
	return &ProvinceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProvinceClient) DeleteOne(pr *Province) *ProvinceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProvinceClient) DeleteOneID(id int) *ProvinceDeleteOne {
	builder := c.Delete().Where(province.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvinceDeleteOne{builder}
}

// Create returns a query builder for Province.
func (c *ProvinceClient) Query() *ProvinceQuery {
	return &ProvinceQuery{config: c.config}
}

// Get returns a Province entity by its id.
func (c *ProvinceClient) Get(ctx context.Context, id int) (*Province, error) {
	return c.Query().Where(province.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvinceClient) GetX(ctx context.Context, id int) *Province {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryProvRegi queries the prov_regi edge of a Province.
func (c *ProvinceClient) QueryProvRegi(pr *Province) *RegionQuery {
	query := &RegionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, province.ProvRegiTable, province.ProvRegiColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvCoun queries the prov_coun edge of a Province.
func (c *ProvinceClient) QueryProvCoun(pr *Province) *CountryQuery {
	query := &CountryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, province.ProvCounTable, province.ProvCounColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvCont queries the prov_cont edge of a Province.
func (c *ProvinceClient) QueryProvCont(pr *Province) *ContinentQuery {
	query := &ContinentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(continent.Table, continent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, province.ProvContTable, province.ProvContColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvStud queries the prov_stud edge of a Province.
func (c *ProvinceClient) QueryProvStud(pr *Province) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.ProvStudTable, province.ProvStudColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistStud queries the dist_stud edge of a Province.
func (c *ProvinceClient) QueryDistStud(pr *Province) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.DistStudTable, province.DistStudColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubdStud queries the subd_stud edge of a Province.
func (c *ProvinceClient) QuerySubdStud(pr *Province) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.SubdStudTable, province.SubdStudColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostStud queries the post_stud edge of a Province.
func (c *ProvinceClient) QueryPostStud(pr *Province) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.PostStudTable, province.PostStudColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvinceClient) Hooks() []Hook {
	return c.hooks.Province
}

// RegionClient is a client for the Region schema.
type RegionClient struct {
	config
}

// NewRegionClient returns a client for the Region from the given config.
func NewRegionClient(c config) *RegionClient {
	return &RegionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `region.Hooks(f(g(h())))`.
func (c *RegionClient) Use(hooks ...Hook) {
	c.hooks.Region = append(c.hooks.Region, hooks...)
}

// Create returns a create builder for Region.
func (c *RegionClient) Create() *RegionCreate {
	mutation := newRegionMutation(c.config, OpCreate)
	return &RegionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Region.
func (c *RegionClient) Update() *RegionUpdate {
	mutation := newRegionMutation(c.config, OpUpdate)
	return &RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegionClient) UpdateOne(r *Region) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegion(r))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegionClient) UpdateOneID(id int) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegionID(id))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Region.
func (c *RegionClient) Delete() *RegionDelete {
	mutation := newRegionMutation(c.config, OpDelete)
	return &RegionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RegionClient) DeleteOne(r *Region) *RegionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RegionClient) DeleteOneID(id int) *RegionDeleteOne {
	builder := c.Delete().Where(region.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegionDeleteOne{builder}
}

// Create returns a query builder for Region.
func (c *RegionClient) Query() *RegionQuery {
	return &RegionQuery{config: c.config}
}

// Get returns a Region entity by its id.
func (c *RegionClient) Get(ctx context.Context, id int) (*Region, error) {
	return c.Query().Where(region.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegionClient) GetX(ctx context.Context, id int) *Region {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryRegiProv queries the regi_prov edge of a Region.
func (c *RegionClient) QueryRegiProv(r *Region) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.RegiProvTable, region.RegiProvColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RegionClient) Hooks() []Hook {
	return c.hooks.Region
}

// ResultsClient is a client for the Results schema.
type ResultsClient struct {
	config
}

// NewResultsClient returns a client for the Results from the given config.
func NewResultsClient(c config) *ResultsClient {
	return &ResultsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `results.Hooks(f(g(h())))`.
func (c *ResultsClient) Use(hooks ...Hook) {
	c.hooks.Results = append(c.hooks.Results, hooks...)
}

// Create returns a create builder for Results.
func (c *ResultsClient) Create() *ResultsCreate {
	mutation := newResultsMutation(c.config, OpCreate)
	return &ResultsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Results.
func (c *ResultsClient) Update() *ResultsUpdate {
	mutation := newResultsMutation(c.config, OpUpdate)
	return &ResultsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResultsClient) UpdateOne(r *Results) *ResultsUpdateOne {
	mutation := newResultsMutation(c.config, OpUpdateOne, withResults(r))
	return &ResultsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResultsClient) UpdateOneID(id int) *ResultsUpdateOne {
	mutation := newResultsMutation(c.config, OpUpdateOne, withResultsID(id))
	return &ResultsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Results.
func (c *ResultsClient) Delete() *ResultsDelete {
	mutation := newResultsMutation(c.config, OpDelete)
	return &ResultsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ResultsClient) DeleteOne(r *Results) *ResultsDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ResultsClient) DeleteOneID(id int) *ResultsDeleteOne {
	builder := c.Delete().Where(results.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResultsDeleteOne{builder}
}

// Create returns a query builder for Results.
func (c *ResultsClient) Query() *ResultsQuery {
	return &ResultsQuery{config: c.config}
}

// Get returns a Results entity by its id.
func (c *ResultsClient) Get(ctx context.Context, id int) (*Results, error) {
	return c.Query().Where(results.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResultsClient) GetX(ctx context.Context, id int) *Results {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryResuYear queries the resu_year edge of a Results.
func (c *ResultsClient) QueryResuYear(r *Results) *YearQuery {
	query := &YearQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(results.Table, results.FieldID, id),
			sqlgraph.To(year.Table, year.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, results.ResuYearTable, results.ResuYearColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResuSubj queries the resu_subj edge of a Results.
func (c *ResultsClient) QueryResuSubj(r *Results) *SubjectQuery {
	query := &SubjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(results.Table, results.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, results.ResuSubjTable, results.ResuSubjColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResuStud queries the resu_stud edge of a Results.
func (c *ResultsClient) QueryResuStud(r *Results) *StudentQuery {
	query := &StudentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(results.Table, results.FieldID, id),
			sqlgraph.To(student.Table, student.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, results.ResuStudTable, results.ResuStudColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResuTerm queries the resu_term edge of a Results.
func (c *ResultsClient) QueryResuTerm(r *Results) *TermQuery {
	query := &TermQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(results.Table, results.FieldID, id),
			sqlgraph.To(term.Table, term.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, results.ResuTermTable, results.ResuTermColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResultsClient) Hooks() []Hook {
	return c.hooks.Results
}

// StudentClient is a client for the Student schema.
type StudentClient struct {
	config
}

// NewStudentClient returns a client for the Student from the given config.
func NewStudentClient(c config) *StudentClient {
	return &StudentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `student.Hooks(f(g(h())))`.
func (c *StudentClient) Use(hooks ...Hook) {
	c.hooks.Student = append(c.hooks.Student, hooks...)
}

// Create returns a create builder for Student.
func (c *StudentClient) Create() *StudentCreate {
	mutation := newStudentMutation(c.config, OpCreate)
	return &StudentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Student.
func (c *StudentClient) Update() *StudentUpdate {
	mutation := newStudentMutation(c.config, OpUpdate)
	return &StudentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StudentClient) UpdateOne(s *Student) *StudentUpdateOne {
	mutation := newStudentMutation(c.config, OpUpdateOne, withStudent(s))
	return &StudentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StudentClient) UpdateOneID(id int) *StudentUpdateOne {
	mutation := newStudentMutation(c.config, OpUpdateOne, withStudentID(id))
	return &StudentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Student.
func (c *StudentClient) Delete() *StudentDelete {
	mutation := newStudentMutation(c.config, OpDelete)
	return &StudentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *StudentClient) DeleteOne(s *Student) *StudentDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *StudentClient) DeleteOneID(id int) *StudentDeleteOne {
	builder := c.Delete().Where(student.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StudentDeleteOne{builder}
}

// Create returns a query builder for Student.
func (c *StudentClient) Query() *StudentQuery {
	return &StudentQuery{config: c.config}
}

// Get returns a Student entity by its id.
func (c *StudentClient) Get(ctx context.Context, id int) (*Student, error) {
	return c.Query().Where(student.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StudentClient) GetX(ctx context.Context, id int) *Student {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryStudGend queries the stud_gend edge of a Student.
func (c *StudentClient) QueryStudGend(s *Student) *GenderQuery {
	query := &GenderQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(gender.Table, gender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudGendTable, student.StudGendColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudActi queries the stud_acti edge of a Student.
func (c *StudentClient) QueryStudActi(s *Student) *ActivityQuery {
	query := &ActivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(activity.Table, activity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, student.StudActiTable, student.StudActiColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudResu queries the stud_resu edge of a Student.
func (c *StudentClient) QueryStudResu(s *Student) *ResultsQuery {
	query := &ResultsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(results.Table, results.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, student.StudResuTable, student.StudResuColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudProv queries the stud_prov edge of a Student.
func (c *StudentClient) QueryStudProv(s *Student) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudProvTable, student.StudProvColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudDist queries the stud_dist edge of a Student.
func (c *StudentClient) QueryStudDist(s *Student) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudDistTable, student.StudDistColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudSubd queries the stud_subd edge of a Student.
func (c *StudentClient) QueryStudSubd(s *Student) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudSubdTable, student.StudSubdColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudPost queries the stud_post edge of a Student.
func (c *StudentClient) QueryStudPost(s *Student) *ProvinceQuery {
	query := &ProvinceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudPostTable, student.StudPostColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudPref queries the stud_pref edge of a Student.
func (c *StudentClient) QueryStudPref(s *Student) *PrefixQuery {
	query := &PrefixQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(prefix.Table, prefix.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudPrefTable, student.StudPrefColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudDegr queries the stud_degr edge of a Student.
func (c *StudentClient) QueryStudDegr(s *Student) *DegreeQuery {
	query := &DegreeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(student.Table, student.FieldID, id),
			sqlgraph.To(degree.Table, degree.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, student.StudDegrTable, student.StudDegrColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StudentClient) Hooks() []Hook {
	return c.hooks.Student
}

// SubjectClient is a client for the Subject schema.
type SubjectClient struct {
	config
}

// NewSubjectClient returns a client for the Subject from the given config.
func NewSubjectClient(c config) *SubjectClient {
	return &SubjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subject.Hooks(f(g(h())))`.
func (c *SubjectClient) Use(hooks ...Hook) {
	c.hooks.Subject = append(c.hooks.Subject, hooks...)
}

// Create returns a create builder for Subject.
func (c *SubjectClient) Create() *SubjectCreate {
	mutation := newSubjectMutation(c.config, OpCreate)
	return &SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Subject.
func (c *SubjectClient) Update() *SubjectUpdate {
	mutation := newSubjectMutation(c.config, OpUpdate)
	return &SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectClient) UpdateOne(s *Subject) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubject(s))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectClient) UpdateOneID(id int) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubjectID(id))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subject.
func (c *SubjectClient) Delete() *SubjectDelete {
	mutation := newSubjectMutation(c.config, OpDelete)
	return &SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SubjectClient) DeleteOne(s *Subject) *SubjectDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SubjectClient) DeleteOneID(id int) *SubjectDeleteOne {
	builder := c.Delete().Where(subject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectDeleteOne{builder}
}

// Create returns a query builder for Subject.
func (c *SubjectClient) Query() *SubjectQuery {
	return &SubjectQuery{config: c.config}
}

// Get returns a Subject entity by its id.
func (c *SubjectClient) Get(ctx context.Context, id int) (*Subject, error) {
	return c.Query().Where(subject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectClient) GetX(ctx context.Context, id int) *Subject {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QuerySubjResu queries the subj_resu edge of a Subject.
func (c *SubjectClient) QuerySubjResu(s *Subject) *ResultsQuery {
	query := &ResultsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(results.Table, results.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subject.SubjResuTable, subject.SubjResuColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectClient) Hooks() []Hook {
	return c.hooks.Subject
}

// TermClient is a client for the Term schema.
type TermClient struct {
	config
}

// NewTermClient returns a client for the Term from the given config.
func NewTermClient(c config) *TermClient {
	return &TermClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `term.Hooks(f(g(h())))`.
func (c *TermClient) Use(hooks ...Hook) {
	c.hooks.Term = append(c.hooks.Term, hooks...)
}

// Create returns a create builder for Term.
func (c *TermClient) Create() *TermCreate {
	mutation := newTermMutation(c.config, OpCreate)
	return &TermCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Term.
func (c *TermClient) Update() *TermUpdate {
	mutation := newTermMutation(c.config, OpUpdate)
	return &TermUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TermClient) UpdateOne(t *Term) *TermUpdateOne {
	mutation := newTermMutation(c.config, OpUpdateOne, withTerm(t))
	return &TermUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TermClient) UpdateOneID(id int) *TermUpdateOne {
	mutation := newTermMutation(c.config, OpUpdateOne, withTermID(id))
	return &TermUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Term.
func (c *TermClient) Delete() *TermDelete {
	mutation := newTermMutation(c.config, OpDelete)
	return &TermDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TermClient) DeleteOne(t *Term) *TermDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TermClient) DeleteOneID(id int) *TermDeleteOne {
	builder := c.Delete().Where(term.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TermDeleteOne{builder}
}

// Create returns a query builder for Term.
func (c *TermClient) Query() *TermQuery {
	return &TermQuery{config: c.config}
}

// Get returns a Term entity by its id.
func (c *TermClient) Get(ctx context.Context, id int) (*Term, error) {
	return c.Query().Where(term.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TermClient) GetX(ctx context.Context, id int) *Term {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryTermResu queries the term_resu edge of a Term.
func (c *TermClient) QueryTermResu(t *Term) *ResultsQuery {
	query := &ResultsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(term.Table, term.FieldID, id),
			sqlgraph.To(results.Table, results.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, term.TermResuTable, term.TermResuColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTermActi queries the term_acti edge of a Term.
func (c *TermClient) QueryTermActi(t *Term) *ActivityQuery {
	query := &ActivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(term.Table, term.FieldID, id),
			sqlgraph.To(activity.Table, activity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, term.TermActiTable, term.TermActiColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TermClient) Hooks() []Hook {
	return c.hooks.Term
}

// YearClient is a client for the Year schema.
type YearClient struct {
	config
}

// NewYearClient returns a client for the Year from the given config.
func NewYearClient(c config) *YearClient {
	return &YearClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `year.Hooks(f(g(h())))`.
func (c *YearClient) Use(hooks ...Hook) {
	c.hooks.Year = append(c.hooks.Year, hooks...)
}

// Create returns a create builder for Year.
func (c *YearClient) Create() *YearCreate {
	mutation := newYearMutation(c.config, OpCreate)
	return &YearCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Year.
func (c *YearClient) Update() *YearUpdate {
	mutation := newYearMutation(c.config, OpUpdate)
	return &YearUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *YearClient) UpdateOne(y *Year) *YearUpdateOne {
	mutation := newYearMutation(c.config, OpUpdateOne, withYear(y))
	return &YearUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *YearClient) UpdateOneID(id int) *YearUpdateOne {
	mutation := newYearMutation(c.config, OpUpdateOne, withYearID(id))
	return &YearUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Year.
func (c *YearClient) Delete() *YearDelete {
	mutation := newYearMutation(c.config, OpDelete)
	return &YearDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *YearClient) DeleteOne(y *Year) *YearDeleteOne {
	return c.DeleteOneID(y.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *YearClient) DeleteOneID(id int) *YearDeleteOne {
	builder := c.Delete().Where(year.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &YearDeleteOne{builder}
}

// Create returns a query builder for Year.
func (c *YearClient) Query() *YearQuery {
	return &YearQuery{config: c.config}
}

// Get returns a Year entity by its id.
func (c *YearClient) Get(ctx context.Context, id int) (*Year, error) {
	return c.Query().Where(year.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *YearClient) GetX(ctx context.Context, id int) *Year {
	y, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return y
}

// QueryYearTerm queries the year_term edge of a Year.
func (c *YearClient) QueryYearTerm(y *Year) *TermQuery {
	query := &TermQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := y.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(year.Table, year.FieldID, id),
			sqlgraph.To(term.Table, term.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, year.YearTermTable, year.YearTermColumn),
		)
		fromV = sqlgraph.Neighbors(y.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryYearResu queries the year_resu edge of a Year.
func (c *YearClient) QueryYearResu(y *Year) *ResultsQuery {
	query := &ResultsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := y.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(year.Table, year.FieldID, id),
			sqlgraph.To(results.Table, results.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, year.YearResuTable, year.YearResuColumn),
		)
		fromV = sqlgraph.Neighbors(y.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryYearActi queries the year_acti edge of a Year.
func (c *YearClient) QueryYearActi(y *Year) *ActivityQuery {
	query := &ActivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := y.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(year.Table, year.FieldID, id),
			sqlgraph.To(activity.Table, activity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, year.YearActiTable, year.YearActiColumn),
		)
		fromV = sqlgraph.Neighbors(y.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *YearClient) Hooks() []Hook {
	return c.hooks.Year
}
