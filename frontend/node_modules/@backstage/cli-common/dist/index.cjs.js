'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs2 = _interopDefault(require('fs'));
var path = require('path');

function findRootPath(searchDir, filterFunc) {
  let path2 = searchDir;
  for (let i = 0; i < 1e3; i++) {
    const packagePath = path.resolve(path2, "package.json");
    const exists = fs2.existsSync(packagePath);
    if (exists && filterFunc(packagePath)) {
      return path2;
    }
    const newPath = path.dirname(path2);
    if (newPath === path2) {
      return void 0;
    }
    path2 = newPath;
  }
  throw new Error(`Iteration limit reached when searching for root package.json at ${searchDir}`);
}
function findOwnDir(searchDir) {
  const path2 = findRootPath(searchDir, () => true);
  if (!path2) {
    throw new Error(`No package.json found while searching for package root of ${searchDir}`);
  }
  return path2;
}
function findOwnRootDir(ownDir) {
  const isLocal = fs2.existsSync(path.resolve(ownDir, "src"));
  if (!isLocal) {
    throw new Error("Tried to access monorepo package root dir outside of Backstage repository");
  }
  return path.resolve(ownDir, "../..");
}
function findPaths(searchDir) {
  const ownDir = findOwnDir(searchDir);
  const targetDir = fs2.realpathSync(process.cwd());
  let ownRoot = "";
  const getOwnRoot = () => {
    if (!ownRoot) {
      ownRoot = findOwnRootDir(ownDir);
    }
    return ownRoot;
  };
  let targetRoot = "";
  const getTargetRoot = () => {
    var _a;
    if (!targetRoot) {
      targetRoot = (_a = findRootPath(targetDir, (path2) => {
        var _a2;
        try {
          const content = fs2.readFileSync(path2, "utf8");
          const data = JSON.parse(content);
          return Boolean((_a2 = data.workspaces) == null ? void 0 : _a2.packages);
        } catch (error) {
          throw new Error(`Failed to parse package.json file while searching for root, ${error}`);
        }
      })) != null ? _a : targetDir;
    }
    return targetRoot;
  };
  return {
    ownDir,
    get ownRoot() {
      return getOwnRoot();
    },
    targetDir,
    get targetRoot() {
      return getTargetRoot();
    },
    resolveOwn: (...paths) => path.resolve(ownDir, ...paths),
    resolveOwnRoot: (...paths) => path.resolve(getOwnRoot(), ...paths),
    resolveTarget: (...paths) => path.resolve(targetDir, ...paths),
    resolveTargetRoot: (...paths) => path.resolve(getTargetRoot(), ...paths)
  };
}

exports.findPaths = findPaths;
